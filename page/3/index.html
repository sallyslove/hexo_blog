<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/hexo_blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/hexo_blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/hexo_blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/hexo_blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/page/3/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="35岁开始的博客，有点晚哦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo_blog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sallyslove.github.io/hexo_blog/page/3/">





  <title>跬步</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo_blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo_blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/hexo_blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo_blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/03/11/Java多线程数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/03/11/Java多线程数据类型/" itemprop="url">Java多线程数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T10:22:53+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇记录改成专门记录和多线程相关的数据类型</p>
<h3 id="executors"><a class="header-anchor" href="#executors"></a>Executors</h3>
<p>这个<code>Executors</code>没有继承或者实现任何其他类。就是说，他嘎嘣自己一个。实际上是一个工具类啊，更确切地说，像一个工厂类。主要功能是返回各种<code>ExecutorService</code>。<br>
其实就是<code>new</code>出各种<code>ThreadPoolExecutor</code>。如下：</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                      new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<h3 id="executorservice"><a class="header-anchor" href="#executorservice"></a>ExecutorService</h3>
<h4 id="概览"><a class="header-anchor" href="#概览"></a>概览</h4>
<pre><code>public interface ExecutorService extends Executor
</code></pre>
<ul>
<li>所以首先来说，这是一个接口</li>
<li>Executor接口很简单，只有一个execute方法。ExecutorService除了这一个方法，还增加了一些方法，增加的方法包括：<code>awaitTerminate</code>，<code>invokeAll</code>，<code>invokeAny</code>，<code>shutdown</code>，<code>shutdownNow</code>，<code>submit</code>等。</li>
<li><a href="https://www.cnblogs.com/Steven0805/p/6393443.html" target="_blank" rel="noopener">Java线程池ExecutorService</a></li>
</ul>
<h4 id="几种常用线程池的具体实现"><a class="header-anchor" href="#几种常用线程池的具体实现"></a>几种常用线程池的具体实现</h4>
<ul>
<li>然后有意思的来了：</li>
<li>Java通过Executors class提供了好几种线程池，这就是我们常用的几种了。</li>
<li><code>newFixedThreadPool</code>：就是说这个玩意，限定好了最大数目，核心数目，然后本质是一个<code>LinkedBlockingQueue</code>套了<code>runnable</code></li>
</ul>
<pre><code> public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
</code></pre>
<ul>
<li><code>newCachedThreadPool</code>：</li>
</ul>
<pre><code>   public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());    }
</code></pre>
<ul>
<li>还有<code>newScheduledThreadPool</code>和<code>newSingleThreadExecutor</code></li>
</ul>
<h4 id="一些要点"><a class="header-anchor" href="#一些要点"></a>一些要点</h4>
<ul>
<li><code>submit</code>与<code>execute</code>的区别：
<ul>
<li>submit接受runnable和callable  有返回值。</li>
<li>execute接受runnable 无返回值</li>
<li>submit方便Exception处理</li>
</ul>
</li>
<li>Runnable与Callable区别
<ul>
<li>runnable接口实现的没有返回值的并发编程。</li>
<li>callable实现的存在返回值的并发编程。使用Future获取返回值。</li>
</ul>
</li>
</ul>
<h3 id="threadpoolexecutor"><a class="header-anchor" href="#threadpoolexecutor"></a>ThreadPoolExecutor</h3>
<pre><code>public abstract class AbstractExecutorService implements ExecutorService
public class ThreadPoolExecutor extends AbstractExecutorService    
</code></pre>
<ul>
<li>从上面可以看出来，ThreadPoolExecutor也是一种Executor，继承自AbstractExecutorService，自然也实现了ExecutorService.</li>
<li><a href="https://www.cnblogs.com/zedosu/p/6665306.html" target="_blank" rel="noopener">ThreadPoolExecutor使用详解</a></li>
</ul>
<h4 id="threadpoolexecutor-shutdown"><a class="header-anchor" href="#threadpoolexecutor-shutdown"></a>ThreadPoolExecutor shutdown</h4>
<p>ThreadPoolExecutor 有三个shutdown方法： <code>shutdown</code>、<code>shutdownNow</code>、<code>awaitTermination</code></p>
<ul>
<li>
<p><code>shutdown</code>： 停止接收外部submit的任务；内部正在跑的任务和队列里等待的任务，会执行完。其实graceful shutdown的感觉啊</p>
</li>
<li>
<p><code>shutdownNow</code>： 停止接收外部提交的任务；忽略队列里等待的任务；尝试将正在跑的任务interrupt中断；返回未执行的任务列表。强制中断。线程会收到InterupptedException.</p>
<ul>
<li>需要注意的是这个方法仅仅是尝试中断线程，它通过的是调用interrupt方法，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。</li>
</ul>
</li>
<li>
<p><code>awaitTermination</code>：只是加了一个wait时间的限制</p>
<ul>
<li>很多博客的里面，这个函数会返回boolean的返回值。就是说<code>awaitTermination</code>一般和<code>shutdown</code>搭配使用，<code>awaitTermination</code>来监控线程有没有结束好。结束了返回<code>true</code>，没结束返回<code>false</code></li>
<li>这个函数还会抛出InterupptedException，但是看代码没太明白什么状况下会抛这个<code>exception</code>。但是是这个函数本身被interrupt了。</li>
<li>有一点不太明白，线程处于阻塞状态，处于阻塞状态时候，还会接收消息？只是不处理？</li>
<li>在实际工作中解决bug碰到了这组函数。事实上就是要三个一起用的。<code>awaitTermination</code>只会返回一个状态，并不会做任何的事情。所以在这个函数返回false的时候应该要调用<code>shutdownNow</code>方法来进一步中断线程</li>
</ul>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://blog.csdn.net/u012168222/article/details/52790400" target="_blank" rel="noopener">shutdown 方法</a></li>
<li><a href="https://blog.csdn.net/zaozi/article/details/38854561#commentBox" target="_blank" rel="noopener">ExecutorService的正确关闭方法</a>： 这篇文章比喻得很清楚，只是不知道正确与否</li>
</ul>
</li>
<li>
<ul>
<li><a href="https://blog.csdn.net/liwenxia626/article/details/80754886" target="_blank" rel="noopener">csdn的另一篇博客</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/03/04/TLS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/03/04/TLS/" itemprop="url">TLS - Algorithm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T14:50:11+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://xz.aliyun.com/t/2526" target="_blank" rel="noopener">SSL/TLS协议详解(上)：密码套件，哈希，加密，密钥交换算法</a>
<ul>
<li>英文版: <a href="https://www.wst.space/ssl-part1-ciphersuite-hashing-encryption/" target="_blank" rel="noopener">SSL/TLS for dummies part 1 : Ciphersuite, Hashing,Encryption</a></li>
</ul>
</li>
<li><a href="https://xz.aliyun.com/t/2530" target="_blank" rel="noopener">SSL/TLS协议详解(中)——证书颁发机构</a></li>
<li><a href="https://xz.aliyun.com/t/2531" target="_blank" rel="noopener">SSL/TLS协议详解(下)——TLS握手协议</a></li>
<li>以上是一个系列，真的是详解，非常详尽。</li>
</ul>
<h2 id="算法"><a class="header-anchor" href="#算法"></a>算法</h2>
<ul>
<li>这边主要是参考了上面参考链接里面的第一篇，总的来说，应该了解一下这些</li>
</ul>
<h3 id="哈希算法"><a class="header-anchor" href="#哈希算法"></a>哈希算法</h3>
<ul>
<li>哈希算法生成的数据格式被称为散列，散列不是一个可逆的过程。<br>
而之前说过，<code>Base64</code>只是编码，顾名思义，编码只要知道规则，是可以解码的，没有安全性可言。所以编码算法和加密算法不是一回事来着。</li>
<li>所以讲密码哈希一下，是没法看出来原始密码是什么的。</li>
<li>这边可以扩展，进一步研究的是，如果进行攻击的话，称为字典攻击，就是猜密码，将常用的，可能出现的密码都哈希算法一下，去对比。</li>
<li>哈希算法有很多种，比如<code>MD5</code>是一种，虽然之前说就是提取摘要的。<code>SHA-512</code>是另一种。</li>
</ul>
<h3 id="加密算法"><a class="header-anchor" href="#加密算法"></a>加密算法</h3>
<ul>
<li><em>Encryption lies in between hashing and encoding</em> 这句没看明白</li>
<li>加密算法可以分为对称加密和非对称加密两种</li>
</ul>
<h4 id="对称加密"><a class="header-anchor" href="#对称加密"></a>对称加密</h4>
<ul>
<li>主要来自参考链接一， 对称加密的话，文章中用一个例子来讲解：“移位”。比如有数字&quot;123&quot;，对其进行加密，都增大3，成为“456”，就是对称加密了。</li>
<li>其中的数字3就是<code>Encryption key (symmetric key)</code>。对称加密的时候，知道<code>key</code>的话，就可以进行解密了。</li>
<li><em>Anyone who knows the encryption key and can apply the reverse of Caesar’s algorithm and retrieve the original Plaintext.</em> 凯撒算法就是上面这种意味式的加密算法。</li>
<li>有此可知，在<code>TLS</code>中使用简单的对称加密不是很安全的。毕竟知道<code>Encryption key</code>就可以进行解密了。<br>
对称加密一代代发展，现在也有比较复杂的算法，比如<code>Triple Data Encryption Algorithm</code>，后面可以再进一步研究。AES（高级加密标准）和3DES（三重数据加密算法）的复杂算法也是有的</li>
<li>从过程可以知道，<code>key</code>是非常关键的。但是由于是对称加密解密，双方必须都知道约定的值，那么第一步就是传递<code>key</code>，而这个时候是没法加密的。所以就出现了不对称加密。<em>So we need a secure mechanism to exchange the keys without an attacker actually seeing it. There comes the role of Asymmetric Key Encryption.</em></li>
<li>在<code>TLS</code>中，传输和接收数据的时候，可以使用对称加密算法。事实上，很可能大部分都是使用的对称加密。不对称加密涉及双密钥架构并且密钥长度通常很大，因此加密-解密开销非常高。与对称密钥加密相比，它需要更多的时间和<code>CPU</code>占有率。</li>
</ul>
<h4 id="不对称加密"><a class="header-anchor" href="#不对称加密"></a>不对称加密</h4>
<ul>
<li>1976年，Whitfield Diffie和Martin Hellman首次提出了非对称加密的概念，该算法被称为<code>Diffie-Hellman</code>密钥交换。然后在1978年，麻省理工学院的Ron Rivest，Adi Shamir和Leonard Adleman发表了<code>RSA</code>算法。</li>
<li>不对称加密的简单解释就是：用不同的<code>key</code>来进行加密和解密。</li>
<li>非对称加密也称为公钥基础结构，又称<code>PKI public key ixxx</code></li>
<li>不对称加密通常用于在刚开始传输对称加密的<code>key</code>的时候</li>
<li>公钥用来给对方使用，比如A想给B发消息，那么A需要使用B的公钥来加密自己的消息。<br>
所以公钥是可以与任何想与你通信的人共享的，一般来说，在公钥中会指定使用何种加密算法。 <em>如果密钥对是使用RSA算法生成的，那么它们应该在加密数据时使用相同的算法。</em></li>
<li>私钥用来解密收到的消息。比如A收到了一条消息，那么A应当使用自己的私钥来解密收到的消息</li>
<li>非对称加密算法除了<code>RSA</code>、<code>Diffie-Hellman密钥交换</code>、<code>ECDH（Elliptic Curve Diffie-Hellman）</code>、<code>SRP（安全远程密码）</code>以及由TLS 1.2支持密钥交换算法<code>PSK（Pre Shared Key）</code>。总之，也是有一大堆的</li>
</ul>
<h5 id="rsa算法细节"><a class="header-anchor" href="#rsa算法细节"></a>RSA算法细节</h5>
<ul>
<li>所以<code>RSA</code>算法有几个比较重要的组成，私钥，公钥，加密算法和解密算法</li>
<li>那么一个严肃的问题就是，不同的钥匙进行计算的消息，怎么能够解开呢？接下来就是数学课的时间了。
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/dbs1215/article/details/48953589" target="_blank" rel="noopener">带你彻底理解RSA算法原理</a></li>
<li><a href="https://www.zhihu.com/question/25038691" target="_blank" rel="noopener">RSA 算法的加密原理是什么,知乎问答</a></li>
</ul>
</li>
<li>互质数： 只有一个公因子为1的数。比如6和9，都有公因子为3，那么就不是互质数；而7和9只有公因子为1，就是互质数。</li>
<li>欧拉函数：<code>φ(n)</code>。 小于或等于n的正整数中与n互质的数的数目。</li>
<li>三个横线的奇怪等号是恒等于。</li>
<li>生成公钥：随机选取两个质数<code>p1、p2</code>，<code>n=p1*p2</code>，再随机选取一个整数<code>e</code>，<code>e</code>与<code>φ(n)</code>互质。公钥就是<code>(e, n)</code>。</li>
<li>根据欧拉函数定理，<code>φ(n) = (p1-1)*(p2-1)</code></li>
<li>费马定理：若p是素数，a与p互素，则<code>a^(p-1）≡1 （mod p）</code> 没看懂这个费马定理</li>
<li>加密算法：假设<code>m</code>为需要加密的信息，那么<code>(m^e) mod n</code>就加密好了，生成加密后的信息<code>c</code></li>
<li>解密算法： 解密算法其实和加密算法的公式是一模一样的，只是这里的<code>m</code>和<code>e</code>换成<code>c</code>和<code>d</code>，成为<code>(c^d) mod n</code>。相当于采用公式都是<code>(x^y) mod n</code>，所以其实使用的公式是一样的</li>
<li>那么这里的<code>(d, n)</code>就被成为私钥。那么如何得到<code>d</code>呢？烧脑的数学就来了。果然数学系才有前途啊 😂 实在是颇为烧脑啊。</li>
<li>各个参考链接中均有实际的例子，我这里就不再烧脑来看了</li>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/qq_38313548/article/details/85387466" target="_blank" rel="noopener">如何获得d</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>(c^d) mod n = ((m^e)mod n)^d mod n = (m^ed) mod n = m
(m^φ(n)) mod n≡1 又 1^k≡1, 所以(m^k*φ(n)) mod n≡1 ，所以(m^(k*φ(n)+1)) mod n≡m
结合以上两条，ed=k*φ(n)+1 , d=(k*φ(n)+1)/e
</code></pre>
<h5 id="dh和rsa的区别"><a class="header-anchor" href="#dh和rsa的区别"></a>DH和RSA的区别</h5>
<ul>
<li>有一本书，叫做“图解密码技术”，</li>
<li><code>RSA</code>利用最大公约数（互质）来求出公钥和私钥。<code>DH密钥协商</code>则是利用生成元来得到共享密钥。</li>
<li>在第一篇参考链接中有<code>DH</code>算法的详细数学过程，暂时略过，这些需要数学基础啊。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/27/K8s概念理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/27/K8s概念理解/" itemprop="url">K8s概念理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T14:44:21+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="k8s概念"><a class="header-anchor" href="#k8s概念"></a>K8s概念</h2>
<p>这篇是从K8s的常用命令分出来的，实在是概念比较多，跟常用命令杂在一起不合适了。</p>
<h3 id="deployment"><a class="header-anchor" href="#deployment"></a>deployment</h3>
<ul>
<li>这几者的关系比较复杂。还需要进一步去看。目前先记录一下：<code>deployment</code>是实际的<code>deploy</code>，然后<code>pod</code>是根据<code>replica</code>里面的设定来起的。所以，如果将<code>deployment</code>删除掉，那么相应的<code>pod</code>和<code>replica set</code>都会没有</li>
</ul>
<h4 id="deployment-spec详解"><a class="header-anchor" href="#deployment-spec详解"></a>deployment spec详解</h4>
<p>网上基本搜索不到这方面的信息。应该是yaml文件里面的各个字段太过相似了。</p>
<ul>
<li><code>spec</code>详解：
<ul>
<li><code>metadata</code>：元数据，包含名字，标签和产品声明。元数据就是说基础信息，白描</li>
</ul>
</li>
</ul>
<h4 id="deployment参考链接"><a class="header-anchor" href="#deployment参考链接"></a>deployment参考链接</h4>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/03/metadata.html" target="_blank" rel="noopener">元数据参考链接</a></li>
</ul>
<h3 id="pod"><a class="header-anchor" href="#pod"></a>Pod</h3>
<p><code>pod</code>实在是<code>K8s</code>里面很重要的一个概念，也是很宽泛的一个概念。很多都可以是一个<code>pod</code>。</p>
<ul>
<li>All containers described as Pods.包括replication cotronller， service， deployment。<br>
<strong>不知道是不是所有的service类型都会被当做是pod，这一点有待确认</strong></li>
<li>A pod is a collection of containers that makes up a particular application, for example Redis.<br>
<strong>这句没有很明白啊，不是说pod是一个container嘛，又变成一堆container了</strong><br>
<strong>经过一段时间的学习，我想这里可能指的是initContainer之类的，所以一个pod里面可能是有很多container的</strong></li>
</ul>
<h3 id="services"><a class="header-anchor" href="#services"></a>Services</h3>
<p>service是K8s里面另一个非常重要的概念，而且实在是有点复杂。类型比较多。K8s中文文档里面的名词解释还是比较清楚的，并且给出了为什么需要service，service和pod有什么区别</p>
<p>挪到另一篇单独的博客里面了：<a href="https://sallyslove.github.io/hexo_blog/2019/10/11/K8s-Service/">K8s_Service</a></p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.kubernetes.org.cn/kubernetes-services" target="_blank" rel="noopener">名词解释 Services</a></li>
</ul>
</li>
</ul>
<h3 id="configmap"><a class="header-anchor" href="#configmap"></a>configmap</h3>
<h4 id="configmap的作用"><a class="header-anchor" href="#configmap的作用"></a>configmap的作用</h4>
<ul>
<li><em>In Kubernetes, a ConfigMap is simply a container for storing configuration data. Other things, like pods, can access the data in a ConfigMap.</em></li>
</ul>
<h4 id="创建configmap"><a class="header-anchor" href="#创建configmap"></a>创建configmap</h4>
<ul>
<li>
<p>可以通过命令行创建<code>kubectl create configmap</code>,当然也可以用<code>yaml</code>文件的方式创建。</p>
</li>
<li>
<p>以下的例子里面是直接给出了一个键值对，事实上，可以从文件<code>--from-file</code>或者目录来创建</p>
<pre><code>$ kubectl create configmap special-config --from-literal=special.how=very
configmap &quot;special-config&quot; created
$ kubectl get configmap special-config -o go-template='{{.data}}'
map[special.how:very]
</code></pre>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.jianshu.com/p/b1d516f02ecd" target="_blank" rel="noopener">k8s – ConfigMap</a></li>
</ul>
</li>
</ul>
<h4 id="pod调用configmap"><a class="header-anchor" href="#pod调用configmap"></a>POD调用configmap</h4>
<h3 id="secrets"><a class="header-anchor" href="#secrets"></a>secrets</h3>
<h3 id="persistentvolumnclumns"><a class="header-anchor" href="#persistentvolumnclumns"></a>PersistentVolumnClumns</h3>
<ul>
<li>PVC在定义的时候有个storageclass。这个storageclass是定义在<code>kube-system</code>的namespace里面的</li>
<li>在安装时候，share C盘遇到了问题，用“docker for desktop”的默认的storageclass：hostpath来创PVC，就起不来了。于是在大神的教导下另创了一个StorageClass，将其映射到docker machine的虚机里面。解决了这个问题。</li>
<li>在尝试解决这个C盘没法share的问题时候参考了很多资料。工作电脑由于系统关系，没有办法创建administrator group的user，所以绕不过去。</li>
<li>参考的链接有：
<ul>
<li><a href="https://dotblogs.com.tw/swater111/2017/01/26/101009" target="_blank" rel="noopener">share C盘总结</a>：这篇资料还是不错的，里面汇总了可能遇到的好几个问题。</li>
<li><a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank" rel="noopener">share C盘家里咋整</a></li>
<li><a href="https://tomssl.com/2018/01/11/sharing-your-c-drive-with-docker-for-windows-when-using-azure-active-directory-azuread-aad/" target="_blank" rel="noopener">local user方法</a></li>
</ul>
</li>
</ul>
<h3 id="namespace"><a class="header-anchor" href="#namespace"></a>namespace</h3>
<ul>
<li>
<p>当团队或项目中具有许多用户时，可以考虑使用Namespace来区分。</p>
</li>
<li>
<p>默认情况下，相同Namespace中的对象将具有相同的访问控制策略。</p>
</li>
<li>
<p>Kubernetes从两个初始的Namespace开始：</p>
<ul>
<li>
<p>default</p>
</li>
<li>
<p>kube-system 由Kubernetes系统创建的对象的Namespace</p>
</li>
<li>
<p>自己电脑上面装好的docker for desktop里面有以下的namespace</p>
<pre><code>$ kubectl get namespaces
NAME           STATUS    AGE
default        Active    15d
docker         Active    15d
kube-public    Active    15d
kube-system    Active    15d
</code></pre>
</li>
</ul>
</li>
<li>
<p>大多数<code>Kubernetes</code>资源（例如<code>pod</code>、<code>services</code>、<code>replication controllers</code>或其他）都在某些Namespace中，但Namespace资源本身并不在Namespace中。而低级别资源（如<code>Node</code>和<code>persistentVolumes</code>）不在任何Namespace中。</p>
</li>
<li>
<p><code>Events</code>是一个例外：它们可能有也可能没有Namespace，具体取决于<code>Events</code>的对象。</p>
</li>
<li>
<p>参考链接：<a href="http://docs.kubernetes.org.cn/242.html" target="_blank" rel="noopener">Kubernetes Namespaces</a></p>
</li>
</ul>
<h3 id="replication-controller"><a class="header-anchor" href="#replication-controller"></a>replication controller</h3>
<ul>
<li>The replication controller defines how many instances should be running, the Docker Image to use, and a name to identify the service.<br>
<strong>决定多少个instance可以理解，不同的instance可以使用不同的image吗</strong></li>
</ul>
<h3 id="ingress"><a class="header-anchor" href="#ingress"></a>Ingress</h3>
<p><code>Ingress</code>的内容也已经挪到新的一篇博客里面去了：<a href="https://sallyslove.github.io/hexo_blog/2020/02/11/K8s-Ingress/">K8s-Ingress</a></p>
<h3 id="daemonset"><a class="header-anchor" href="#daemonset"></a>DaemonSet</h3>
<ul>
<li>一个<code>DaemonSet</code>对象能确保其创建的<code>Pod</code>在集群中的每一台（或指定）<code>Node</code>上都运行一个副本。</li>
<li>在<code>Kubernetes 1.8</code>之后，必须指定<code>.spec.selector</code>来确定这个<code>DaemonSet</code>对象管理的<code>Pod</code>，通常与<code>.spec.template.metadata.labels</code>中定义的<code>Pod</code>的<code>label</code>一致。</li>
<li>也可以通过指定参数要求<code>DaemonSet</code>将<code>POD</code>建在指定的<code>Node</code>上面，细节看参考链接里面</li>
</ul>
<h4 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h4>
<ul>
<li><a href="https://www.jianshu.com/p/79981db6d4e6" target="_blank" rel="noopener">K8s – DaemonSet</a></li>
</ul>
<h3 id="custom-resource-definition"><a class="header-anchor" href="#custom-resource-definition"></a>Custom Resource Definition</h3>
<h4 id="custom-resource"><a class="header-anchor" href="#custom-resource"></a>Custom Resource</h4>
<ul>
<li>官方文档解释有点难以理解，<em>A resource is an endpoint in the Kubernetes API that stores a collection of API objects of a certain kind. For example, the built-in pods resource contains a collection of Pod objects.</em> 一个资源就是某种类型的物体的集合的统称。比如<code>pod resource</code>就是自带的资源。</li>
<li>所以就是说自己定义的类似<code>pod</code>，<code>service</code>之类的资源。</li>
</ul>
<h4 id="crd"><a class="header-anchor" href="#crd"></a>CRD</h4>
<ul>
<li>
<p>部署一个<code>CRD</code>到集群中，<code>kube-apiserver</code>会帮助你安装好路由和提供自定义资源的一般服务端实现。</p>
</li>
<li>
<p>例子：</p>
<pre><code>{
&quot;apiVersion&quot;: &quot;apiextensions.k8s.io/v1beta1&quot;,
&quot;kind&quot;: &quot;CustomResourceDefinition&quot;,
...
&quot;spec&quot;: {
  # group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;
  &quot;group&quot;: &quot;stable.netease&quot;,
    ...
      &quot;kind&quot;: &quot;Task&quot;,
      # shortNames allow shorter string to match your resource on the CLI
      &quot;shortNames&quot;: [
          &quot;task&quot;
      ]
  }
}
</code></pre>
</li>
</ul>
<h4 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h4>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-resources" target="_blank" rel="noopener">官方文档Custom Resource</a></li>
<li><a href="https://sq.163yun.com/blog/article/193062240727805952" target="_blank" rel="noopener">CRD 和 CR定义的例子</a></li>
<li><a href="https://k2r2bai.com/2019/10/04/ironman2020/day19/" target="_blank" rel="noopener">K8s的架构，CRD所在位置</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/26/Helm入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/26/Helm入门/" itemprop="url">Helm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T15:50:36+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="helm"><a class="header-anchor" href="#helm"></a>Helm</h2>
<p><code>Helm</code>入门篇。感觉有点类似<code>maven</code>，总归有这样一个管理工具。</p>
<p>写了一阵之后再看看，会发现有些看不明白的地方。果然，我写博客的风格和上学年代记笔记的风格一样，喜欢简略而不够详尽啊。这是说好多年没有变化和进步嘛 😂</p>
<h3 id="helm版本"><a class="header-anchor" href="#helm版本"></a>Helm版本</h3>
<ul>
<li>在工作中发现，<code>Helm</code>发展很快。但是也从侧面说明现在问题很多。</li>
<li>我们自己产品里面还是<code>1.x</code>的版本，实际已经发展到<code>3.x</code>了。</li>
<li>而从文档来看，<code>Helm</code>从<code>1.x</code>到<code>3.x</code>变化还是挺大的。甚至<code>Tiller</code>都被移除了!</li>
<li>目前的一个问题是，不同的版本支持的功能有一定差异，目前发现的有：<br>
1、有的<code>yaml</code>文件在比较高的<code>Helm</code>版本里面反而校验不过。应该是校验的规则加强了<br>
2、<code>--set-file</code>在<code>2.10.0</code>之前并不支持</li>
</ul>
<h3 id="helm是什么"><a class="header-anchor" href="#helm是什么"></a>Helm是什么</h3>
<ul>
<li><code>Helm</code>是在Kubernetes中安装部署容器的一个工具。</li>
<li><em>Helm is a tool for managing Kubernetes charts.</em></li>
<li><code>Helm</code>由<code>Helm</code>客户端、<code>Tiller</code>服务器端和<code>Chart</code>仓库所组成
<ul>
<li><code>Helm</code>客户端： 客户端交互</li>
<li><code>Tiller</code>服务器端： 装在k8s的cluster里面，管理<code>chart</code></li>
<li><code>Chart</code>仓库：创建<code>Kubernetes</code>应用实例的信息集合
<ul>
<li><code>Chart</code>由两个部分组成，第一个部分是A description of the package (Chart.yaml)</li>
<li>One or more templates, which contain Kubernetes manifest files。这个templates的话，应该也是yaml文件吧。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常用的helm命令"><a class="header-anchor" href="#常用的helm命令"></a>常用的helm命令</h3>
<ul>
<li><code>helm status &lt;namespace&gt;</code> 查看<code>Helm</code>的状态</li>
<li><code>helm install</code>: 实际将<code>helm</code>里面的内容安装到当前的<code>k8s</code>上面。比如我创了一个<code>configMap.yaml</code>的<code>templete</code>，那么就会安装上去。
<ul>
<li>如果只是想看看<code>template</code>的<code>rending</code>，那么使用命令<code>helm install ./mychart --debug --dry-run</code></li>
<li>如果想传值进去，可以使用<code>-f</code> 命令，比如<code>helm install -f myvals.yaml ./mychart</code>。这样传的值，可以用<code>.Value</code>来访问</li>
<li>单独传值是<code>--set foo=bar</code>，<code>--set</code>比文件的级别高，可以覆盖文件里面的值</li>
<li>以下命令里面将<code>livenessProbe.httpGet</code>删除掉了。但是参考上一章的<code>Helm</code>版本的描述，这个功能也是在较高的版本里面才实现。</li>
</ul>
</li>
</ul>
<pre><code>helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null

$ helm install ./mychart
  NAME:   guiding-ocelot
  LAST DEPLOYED: Mon Aug 19 17:23:00 2019
  NAMESPACE: gear-1
  STATUS: DEPLOYED

  RESOURCES:
      ==&gt; v1/ConfigMap
      NAME               DATA  AGE
      mychart-configmap  1     0s
</code></pre>
<ul>
<li>
<p><code>helm get manifest &lt;release name&gt;</code>: 比如上面的这个<code>guiding-ocelot</code></p>
<pre><code> $ helm get manifest guiding-ocelot

 ---
  # Source: myChart/templates/configmap.yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mychart-configmap
  data:
    myvalue: &quot;Hello World&quot;
</code></pre>
</li>
<li>
<p><code>helm init</code>:安装tiller服务器端</p>
<ul>
<li>在工作中碰到一个问题，在做<code>helm init</code>的时候没有带上<code>--client-only</code>选项，结果将服务器端的<code>Tiller</code>给更新了。</li>
<li>话说我在博客上面这样写了啊。其实客户端也是更新的</li>
</ul>
</li>
<li>
<p><code>helm delete --purge &lt;release name&gt;</code></p>
</li>
<li>
<p><code>helm repo add &lt;repo name&gt; &lt;repo address&gt;</code></p>
</li>
<li>
<p><code>helm create &lt;chart name&gt;</code>: 生成一个目录</p>
<pre><code>$ find myChart/
  myChart/
  myChart/.helmignore
  myChart/Chart.yaml
  myChart/charts
  myChart/templates
  myChart/templates/deployment.yaml
  myChart/templates/ingress.yaml
  myChart/templates/NOTES.txt
  myChart/templates/service.yaml
  myChart/templates/tests
  myChart/templates/tests/test-connection.yaml
  myChart/templates/_helpers.tpl
  myChart/values.yaml
</code></pre>
</li>
</ul>
<h3 id="helm-chart"><a class="header-anchor" href="#helm-chart"></a>Helm Chart</h3>
<h4 id="helm-chart-dependency-management"><a class="header-anchor" href="#helm-chart-dependency-management"></a>Helm Chart Dependency Management</h4>
<ul>
<li><code>3.x</code>的时候，<code>Chart</code>依赖关键由<code>requirements.yaml</code>和<code>requirements.lock</code>挪到了<code>chart.yaml</code>和<code>chart.lock</code>里面去了。但是还是会兼容<code>1.x</code>的<code>requirements.yaml</code>和<code>requirements.lock</code></li>
<li>不论<code>Helm2</code>还是<code>Helm3</code>都可以使用<code>tag</code>或者<code>condition</code>来劲依赖的控制管理</li>
</ul>
<pre><code>condition: somechart.enabled
tags:
  - webaccelerator
</code></pre>
<ul>
<li>不论是<code>tag</code>还是<code>condition</code>，都需要在<code>values.yaml</code>里面定义。<code>tag</code>必须是<code>global</code>下面的一层。自己为顶层的意思。</li>
<li>区别在于，<code>tag</code>可以用于很多<code>subchart</code>，如果设为<code>true</code>，那么被这个标签标示的<code>subchart</code>都会被装上。而<code>condition</code>应该是只有第一个会有效。但是这点需要验证一下。<em>Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.</em></li>
<li>在我们产品里面的<code>Helm1.x</code>里面，这个功能有一个致命的问题，就是当<code>Helm Upgrade</code>之后就会失效。
<ul>
<li>第一次<code>helm upgrade</code>时候将<code>somechart.enabled</code>改为了<code>true</code>，也顺利地将<code>subchart</code>加到了同一个release里面。</li>
<li>使用<code>helm upgrade</code>修改其他参数，在第一步中被安装上的<code>subchart</code>又丢了。即使这个时候<code>somechart.enabled</code>参数在<code>helm get values</code>里面仍旧维持着<code>true</code></li>
<li>在网上也看到一些类似的问题：
<ul>
<li><a href="https://github.com/helm/helm/issues/3796" target="_blank" rel="noopener">condition problem</a></li>
<li><a href="https://github.com/helm/helm/issues/6313" target="_blank" rel="noopener">helm upgrade issue</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="helm-template"><a class="header-anchor" href="#helm-template"></a>Helm Template</h3>
<ul>
<li>参考以上，默认生成一套chart的时候会生成template目录。
<ul>
<li><em>NOTES.txt: The “help text” for your chart. This will be displayed to your users when they run helm install.</em></li>
<li><em>deployment.yaml: A basic manifest for creating a Kubernetes deployment</em></li>
<li><em>service.yaml: A basic manifest for creating a service endpoint for your deployment</em></li>
<li>_ <em>helpers.tpl: A place to put template helpers that you can re-use throughout the chart</em></li>
</ul>
</li>
</ul>
<h4 id="template-values"><a class="header-anchor" href="#template-values"></a>Template Values</h4>
<ul>
<li>
<p>E.g. <code>name：</code>，下面这个例子里面用<code>release name</code> 来做前缀。话说这个<code>release name</code>在哪里定义的，我没找到。</p>
<ul>
<li>
<p><em>So we could read <code>.Release.Name</code> as “start at the top namespace, find the <code>Release</code> object, then look inside of it for an object called <code>Name</code>”.</em></p>
</li>
<li>
<p><code>.Release</code>表示<code>Release</code>是顶级的object</p>
<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p>顶级的自带的object包括： <code>Release</code>,<code>Value</code>,<code>Chart</code>,<code>Template</code>, <code>Capabilities</code>还有<code>File</code>。后两个还不是很理解</p>
<ul>
<li>
<p><code>Release</code>里面包含很多变量，有<code>Release.Time</code>,<code>Release.Namespace</code>, <code>Release.Revision</code>,详情可以看官方文档</p>
</li>
<li>
<p><code>Values</code>里面的其实是从<code>values.yaml</code>里面来的</p>
</li>
<li>
<p><code>Template</code>: 包含当前正在执行的<code>template</code>的信息</p>
</li>
<li>
<p><code>Chart</code> 里面的就是<code>chart.yaml</code>来的。比如</p>
<pre><code>{{.Chart.Name}}-{{.Chart.Version}} 
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="template-functions"><a class="header-anchor" href="#template-functions"></a>Template Functions</h4>
<ul>
<li>
<p><em>Helm has over 60 available functions.</em> 其中一些是调用<code>GO</code>语言里面<code>tamplate</code>定义的函数。在<a href="https://godoc.org/text/template" target="_blank" rel="noopener">Go Template Function</a>可以查询到</p>
</li>
<li>
<p>其实<code>Helm Template</code>并不是Helm自身做出来的，其实是从Go这些来的。就是个拿来再集成一下。并不是Helm自己的。</p>
</li>
<li>
<p><code>Helm functions</code>支持管道<code>pipeline</code>。这里的<code>pipeline</code>和<code>Unix</code>里面的同样含义。如下面的例子里面的：</p>
<pre><code>food: {{ .Values.favorite.food | upper | quote }}
drink: {{ .Values.favorite.drink | repeat 5 | quote }}
</code></pre>
</li>
</ul>
<h5 id="常用函数"><a class="header-anchor" href="#常用函数"></a>常用函数</h5>
<ul>
<li>
<p><code>default</code>：用来指定默认值</p>
<pre><code>  drink: {{ .Values.favorite.drink | default "tea" | quote }}
</code></pre>
</li>
<li>
<p><code>toyaml</code>: 转成yaml格式 <strong><em>其实不明白啥叫做Yaml格式</em></strong></p>
</li>
</ul>
<h5 id="函数控制和操作运算符"><a class="header-anchor" href="#函数控制和操作运算符"></a>函数控制和操作运算符</h5>
<ul>
<li><code>Helm Template</code>的函数是可以引入逻辑控制的</li>
<li>运算符有：
<ul>
<li><code>if/else</code> for creating conditional blocks： <code>if</code>判断有点不一样的是空的字符串或者空的集合也会被认为是<code>false</code>，还有数字0</li>
<li><code>with</code> to specify a scope</li>
<li><code>range</code> which provides a “for each”-style loop</li>
</ul>
</li>
</ul>
<h6 id="function-if-else"><a class="header-anchor" href="#function-if-else"></a>Function if/else</h6>
<ul>
<li>
<p>逻辑稍微有点难理解。就是<code>if</code>语句里面的内容是判断条件成立的时候包含的。然后关系运算符在前，这里是<code>or</code>运算符</p>
<pre><code>  {{/* include the body of this if statement when the variable .Values.anUnsetVariable is set or .values.aSetVariable is not set */}}
  {{ if or .Values.anUnsetVariable (not    .Values.aSetVariable) }}
   {{ ... }}
  {{ end }}
</code></pre>
</li>
</ul>
<h6 id="function-range"><a class="header-anchor" href="#function-range"></a>Function Range</h6>
<ul>
<li>
<p><code>range</code>相当于是<code>foreach</code>,比如以下是一个<code>slice</code>，其实就是列表。</p>
<pre><code>pizzaToppings:
 - mushrooms
 - cheese
 - peppers
 - onions
</code></pre>
<p>我们可以这样操作：</p>
<pre><code> toppings: |-
  {{- range .Values.pizzaToppings }}
  - {{ . | title | quote }}
  {{- end }}
</code></pre>
<ul>
<li>以上<code>range</code>函数遍历<code>pizzaToppings</code>里面的每个数值， <code>.</code>代表其中每个数值，传递给<code>title</code>和<code>quote</code>函数。</li>
<li><code>|-</code>代表以下内容是一个长字符串。因为<code>Configmap</code>只支持键值对。</li>
</ul>
</li>
<li>
<p><code>range</code>也可以和<code>list</code>合并起来用。如下：</p>
<pre><code> sizes: |-
 {{- range list "small" "medium" "large" }}
  - {{ . }}
 {{- end }}
</code></pre>
<ul>
<li>引号里面的组成一个字符串，然后再遍历字符串</li>
</ul>
</li>
<li>
<p><code>range</code>也可以和其他集合函数联合使用，比如<code>dict</code>和<code>map</code></p>
</li>
</ul>
<h6 id="function-with"><a class="header-anchor" href="#function-with"></a>Function with</h6>
<ul>
<li>
<p><code>.</code>指的是当前作用域，比如<code>.Values</code>，就是在当前作用域的<code>Value</code>里面</p>
</li>
<li>
<p>使用<code>with</code>函数可以改变作用域，用法和<code>if</code>类似。如下：</p>
<pre><code>{{ with PIPELINE }}
# restricted scope
{{ end }}
</code></pre>
</li>
</ul>
<h5 id="空格和空行"><a class="header-anchor" href="#空格和空行"></a>空格和空行</h5>
<ul>
<li>
<p>这就是为啥每行都两个大括号加小横线的缘故，瞅着一堆小横线实在无语啊。这个两个大括号加小横线markdown还打不出来，OMG 😕</p>
<ul>
<li>
<p>以下的语句会产生一个<code>Json</code>字段<code>mug：true</code>并且没有空行</p>
<pre><code>{{ if and .Values.favorite.drink (eq .Values.favorite.drink "coffee") }}mug: true{{ end }}
</code></pre>
</li>
<li>
<p>但是如果是以下语句就会产生在这个字段之前生成一个空行。估计<code>helm</code>就是简单的将<code>if</code>语句的一行给用空格替代了</p>
<pre><code>{{if eq .Values.favorite.drink "coffee"}}
 mug: true
{{end}}
</code></pre>
</li>
<li>
<p>所以上面的语句其实较为清晰，却必须用以下样式替代，这样<code>Helm</code>就知道将这边的空格都删除掉</p>
<pre><code>{{- if eq .Values.favorite.drink "coffee"}}
 mug: true
{{- end}}
</code></pre>
</li>
<li>
<p>For the details on whitespace control in templates,see the Official <a href="https://godoc.org/text/template" target="_blank" rel="noopener">Go template documentation</a></p>
</li>
</ul>
</li>
<li>
<p>也可以更为精确得控制空格，如下。这种用法在代码里也看到很多。</p>
<pre><code>{{indent 2 "mug:true"}}
</code></pre>
</li>
<li>
<p>还可以用<code>*</code>符号，<em>Just for the sake of making this point clear, let’s adjust the above, and substitute an <code>*</code> for each whitespace that will be deleted following this rule. an <code>*</code> at the end of the line indicates a newline character that would be removed</em> 没看的太明白。这个<code>*</code>是干嘛用的。</p>
<pre><code>**{{- if eq .Values.favorite.drink "coffee"}}
  mug: true*
**{{- end}}
</code></pre>
</li>
</ul>
<h4 id="变量"><a class="header-anchor" href="#变量"></a>变量</h4>
<ul>
<li>
<p>变量是用<code>:=</code>来定义的。</p>
</li>
<li>
<p>如下。原本在使用了<code>with</code>之后作用域已经改变了，找不到<code>Release</code>了，但是使用了变量，就又可以访问了。</p>
<pre><code>data:
myvalue: &quot;Hello World&quot;
{{- $relname := .Release.Name -}}
{{- with .Values.favorite }}
drink: {{ .drink | default "tea" | quote }}
food: {{ .food | upper | quote }}
release: {{ $relname }}
{{- end }}
</code></pre>
</li>
<li>
<p>可以和<code>range</code>结合起来用。</p>
<ul>
<li>
<p>遍历一个列表。<code>index</code>变量是下标，从<code>0</code>开始</p>
<pre><code>toppings: |-
  {{- range $index, $topping := .Values.pizzaToppings }}
    {{ $index }}: {{ $topping }}
  {{- end }}
</code></pre>
</li>
<li>
<p>键值对。注意<code>Values.favorite</code>是键值对的集合。所以第一次是一对，第二次是第二对</p>
<pre><code>{{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
{{- end}}
</code></pre>
</li>
</ul>
</li>
<li>
<p>变量是有作用域的。顶层声明的就是整个<code>template</code>可用，<code>range</code>里面声明的，就是<code>range</code>里面可用。比如上面这个例子，出了<code>end</code>就没用了。</p>
</li>
<li>
<p><strong>有一个特殊的变量 <code>$</code>，代表根作用域！</strong></p>
</li>
</ul>
<h4 id="已命名的template"><a class="header-anchor" href="#已命名的template"></a>已命名的Template</h4>
<p>就是介绍一下如何引用啊，命名之类。需要注意的是名字是全局的，不管这个<code>template</code>是不是包在其他的<code>template</code>里面。<br>
__需要的一点是，名字中有下划线的<code>template</code>是不会被部署到<code>kubernate</code>上面的。但是可以被其他<code>template</code>引用</p>
<h5 id="define"><a class="header-anchor" href="#define"></a>define</h5>
<ul>
<li>
<p>使用<code>define</code>可以在一个<code>template</code>内部创建一个新的<code>template</code>。语法如下：</p>
<pre><code>{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
</code></pre>
</li>
<li></li>
</ul>
<h5 id="template和include"><a class="header-anchor" href="#template和include"></a>template和include</h5>
<ul>
<li>
<p><code>template</code>感觉和<code>include</code>有点相似。是调用用<code>define</code>定义的<code>template</code>的。如下：</p>
<pre><code>metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
</code></pre>
</li>
<li>
<p>通常这类<code>template</code>会被放在<code>_helpers.tpl</code>文件里面。我的感觉是，这类<code>template</code>很像<code>util</code>函数，然后放在一个集中的文件里面。一般会在前面加一个注释，如下的格式：</p>
<pre><code>{{/* ... */}}
</code></pre>
</li>
<li>
<p>但是还有一个问题，如上面例子的调用，并没有给任何的作用域，而<code>template</code>的默认作用域为空。如下的<code>template</code>里面的<code>.Chart</code>是无法生效的。所以调用时候应该用以下形式。这样传入一个作用域就可以了。</p>
<pre><code>{{/* Generate basic labels */}}
  {{- define "mychart.labels" }}
    labels:
      generator: helm
      date: {{ now | htmlDate }}
      chart: {{ .Chart.Name }}
      version: {{ .Chart.Version }}
  {{- end }}
  

{{- template "mychart.labels" .}}
</code></pre>
</li>
<li>
<p>还有一个问题，<code>template</code>有点类似<code>inline</code>，就是简单的将内容展开，并不考虑缩进的问题。为此，引入了<code>include</code>， <code>include</code>可以用<code>pipeline</code>来指定缩进。推荐使用<code>include</code>来替代<code>template</code></p>
<pre><code>{{- include "mychart.app" . | nindent 2 }}
</code></pre>
</li>
</ul>
<h4 id="引用文件"><a class="header-anchor" href="#引用文件"></a>引用文件</h4>
<ul>
<li>
<p><code>.File</code>可以将文件包含进来。需要注意的有，<code>template</code>目录下面的文件没法被包含。如下例子。<code>.File.Get</code>就是读取文件的内容的函数</p>
<pre><code> {{- $files := .Files }}
 {{- range list "config1.toml" "config2.toml" "config3.toml" }}
  {{ . }}: |-
    {{ $files.Get . }}
 {{- end }}
</code></pre>
</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li><a href="https://www.cnblogs.com/Erik_Xu/p/8893725.html" target="_blank" rel="noopener">Helm介绍</a></li>
<li><a href="https://github.com/helm/helm" target="_blank" rel="noopener">Helm GitHub页面</a></li>
<li><a href="https://helm.sh/docs/using_helm/#quickstart-guide" target="_blank" rel="noopener">Helm使用文档</a></li>
<li><a href="https://helm.sh/docs/chart_template_guide/" target="_blank" rel="noopener">Helm官方文档</a></li>
<li><a href="https://v2.helm.sh/docs/charts/#managing-dependencies-with-requirements-yaml" target="_blank" rel="noopener">Helm2官方文档</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/26/Liveness-Readiness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/26/Liveness-Readiness/" itemprop="url">Liveness & Readiness</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T14:29:11+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="liveness-readiness"><a class="header-anchor" href="#liveness-readiness"></a>Liveness &amp; Readiness</h2>
<h3 id="readiness"><a class="header-anchor" href="#readiness"></a>Readiness</h3>
<ul>
<li>Readiness Probes checks if an application is ready to start processing traffic.</li>
<li>This probe solves the problem of the container having started, but the process still warming up and configuring itself meaning it’s not ready to receive traffic.</li>
<li>The configuration is as following:<br>
readinessProbe:<br>
httpGet:<br>
path: /<br>
port: 80<br>
initialDelaySeconds: 1<br>
timeoutSeconds: 1</li>
</ul>
<h3 id="liveness"><a class="header-anchor" href="#liveness"></a>Liveness</h3>
<ul>
<li>Liveness Probes ensure that the application is healthy and capable of processing requests.</li>
<li>The configuration is as following:<br>
livenessProbe:<br>
httpGet:<br>
path: /<br>
port: 80<br>
initialDelaySeconds: 1<br>
timeoutSeconds: 1</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/" itemprop="url">Jetty Graceful shutdown</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T15:21:42+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="jetty"><a class="header-anchor" href="#jetty"></a>Jetty</h2>
<p>工作中需要了解Jetty启停的一些知识，可能不能看到全貌，这边记录下来。毕竟不是web的产品。了解得还不够深入啊。</p>
<h3 id="what-is-graceful-shutdown"><a class="header-anchor" href="#what-is-graceful-shutdown"></a>what is graceful shutdown</h3>
<ul>
<li>Graceful shutdown of a server, context or connector is when existing request/connections are allowed to gracefully complete while no new requests and/or connections are accepted.</li>
<li>It is configured on the Server instance with the setGracefulShutdown(long) method. Heres an example of setting this via the jetty.xml file, where we specify a “grace” period of 30000 milliseconds:<br>
<set name="gracefulShutdown">30000</set></li>
<li>The parameter may be already not used any more</li>
</ul>
<h3 id="how-it-works"><a class="header-anchor" href="#how-it-works"></a>How it works</h3>
<ul>
<li>As soon as the shutdown command is given, the container will close the connectors so that they do not accept any more inbound connections.</li>
<li>所以在<code>ServerControllerImpl</code>里面，如果HTTP的配置参数是false，Connector确实是一上来就停掉了。但是怎么都到<code>JettyServer的</code>getContext（）`函数里面的</li>
<li><code>ServerControllerImpl</code> 应该是HTTP server的controller</li>
</ul>
<pre><code> if (!ServerControllerImpl.this.configuration.isHttpEnabled()) {
                connectorsx = ServerControllerImpl.this.jettyServer.getConnectors();
                if (connectorsx != null) {
                     ...
                      this.stopConnector(backupConnector);
                            ServerControllerImpl.this.jettyServer.removeConnector(backupConnector);
  ...
</code></pre>
<ul>
<li>This will inform most load balancers that the server is no longer part of the cluster.</li>
<li>The contexts are closed so that they do not accept any more requests, but the requests currently inside the container will drain out and the Server instance will shutdown after the grace period expires.<br>
not very sure here. It seems that connector and context are different. I think the connector is more related with port. But context is more related with servlet.</li>
</ul>
<h3 id="elements"><a class="header-anchor" href="#elements"></a>Elements</h3>
<p>我理解在整个jetty server shutdown的时候有几个东西： connector、context、server。以下是理解，不一定准确：</p>
<ul>
<li>servlet 是在context里面的，context一旦stop掉，servlet也会跟着destroy。context是WebAppHttpContext，servlet是其中的一个web Element。</li>
<li>有三个context，一个是HttpServiceContext， 一个是WebAppHttpContext，还有servlet的context。WebAppHttpContext是jetty stop context时候停掉的，每个web app对应一个。前者是jetty server停掉的时候停掉的。感觉server停掉的时候，webAppHttpContext不一定都结束了。但是jetty server停掉的时候，HttpServiceContext是停止了。servlet的context结构是servlet里面的一个internal class，跟每个uri绑定。</li>
<li>connector是在jetty里面定义的,有几种connector，比如<code>org.eclipse.jetty.server.ssl.SslSelectChannelConnector</code>，<code>org.eclipse.jetty.server.nio.SelectChannelConnector</code>。</li>
</ul>
<p>在Connector的interface里面有个maxIdleTimeout的参数，标示这个connection在idle时候会等多久从ESTABLISH状态变成TIME_WAIT状态。但是并没有在代码里面找到调用的地方。</p>
<p>___ 这个是在停的时候调用的那个吗？果然写blog要再清楚一点才好___</p>
<ul>
<li>Connector是在jetty的配置文件里面配置的</li>
</ul>
<h3 id="jetty启动过程"><a class="header-anchor" href="#jetty启动过程"></a>Jetty启动过程</h3>
<p>大部分web容器的启动过程都差不多，分为如下几步：</p>
<ul>
<li>创建用于连接的connector，创建线程池</li>
<li>扫描当前的web程序的部署目录，为他们创建上下文环境，并对他们进行path的路由设置，这个的名字是WebAppHttpContext</li>
<li>初始化创建的web程序上下文，这里就包括创建servlet啥的。，初始化linstener啥的。并做好自己的path路由。.</li>
<li>启动connector，开始监听，整个server开始运行</li>
<li>没看出来HttpServiceContext是什么</li>
<li>参考文档：
<ul>
<li><a href="https://blog.csdn.net/kobejayandy/article/details/20291953" target="_blank" rel="noopener">Jetty的Server创建与启动</a></li>
</ul>
</li>
</ul>
<h3 id="filter-servlet-listener顺序"><a class="header-anchor" href="#filter-servlet-listener顺序"></a>Filter、Servlet、Listener顺序</h3>
<h4 id="启动顺序"><a class="header-anchor" href="#启动顺序"></a>启动顺序</h4>
<ul>
<li>filter的初始化是web server启动的时候初始化的</li>
<li>servlet的初始化是收到对应的第一条request时候进行的</li>
<li>执行时候是先执行filter，再执行servlet</li>
<li>从启动日志来看，启动的顺序为listener-&gt;Filter-&gt;servlet.</li>
</ul>
<h4 id="停止顺序"><a class="header-anchor" href="#停止顺序"></a>停止顺序</h4>
<ul>
<li>容器关闭或者context重新部署，这时候servlet先destroy掉</li>
<li>servlet之后才是filter关闭</li>
</ul>
<h4 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h4>
<ul>
<li><a href="https://www.jianshu.com/p/612c3a6673b2" target="_blank" rel="noopener">Listener、Filter、Servlet执行顺序</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/15/常用k8s命令记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/15/常用k8s命令记录/" itemprop="url">常用k8s命令记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-15T14:15:01+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用k8s命令"><a class="header-anchor" href="#常用k8s命令"></a>常用k8s命令</h2>
<p>这篇记录一下常用的k8s命令，我怕我会忘啊  -_-#<br>
没错，这是docker那篇的姐妹篇哦。棒棒哒:P</p>
<ul>
<li>
<p><code>kubectl cluster-info</code></p>
</li>
<li>
<p><code>kubectl get nodes</code>：用下面这条命令可以打出<code>node</code>的具体信息</p>
<pre><code>kubectl get nodes -o wide
</code></pre>
</li>
<li>
<p><code>kubectl run first-deployment --image=katacoda/docker-http-server --port=80</code></p>
<ul>
<li><code>-port</code>仍旧是内部的端口</li>
<li>外部端口可以用<code>--hostport=8001</code>指定， 但是这样做的话， —<em>Under the covers, this exposes the Pod via Docker Port Mapping.</em> As a result, you will not see the service listed using <code>kubectl get svc</code>。目前的理解是，因为是用的<code>docker</code>的方法，所以<code>k8s</code>不知道
<ul>
<li>用<code>docker ps</code>命令能看到这个<code>container</code>，然后可以注意到有两个<code>ps</code>进程。其中一个是<code>paused</code>状态，然后我们的端口<code>8001</code>其实开在这个<code>paused</code>的<code>ps</code>上面。</li>
<li>The ports are exposed on the Pod, not the http container itself. The Pause container is responsible for defining the network for the Pod. Other containers in the pod share the same network namespace. This improves network performance and allow multiple containers to communicate over the same network interface…感觉这段解释很关键啊。这个container的名字是： k8s_POD_“httpexposed”,最后一个字段是我们起的pod的名字</li>
</ul>
</li>
<li><code>--replicas</code>： 复制因子</li>
</ul>
</li>
<li>
<p><code>kubectl get pods</code></p>
<ul>
<li>所以get pods的话，会把replication cotronller， service， deployment都给打印出来</li>
</ul>
</li>
<li>
<p><code>kubectl get rc</code></p>
<ul>
<li>将replication controller打印出来。</li>
</ul>
</li>
<li>
<p><code>kubectl get services</code></p>
</li>
<li>
<p><code>kubectl get deployments</code></p>
<ul>
<li>感受一下这两个的区别</li>
</ul>
</li>
</ul>
<pre><code>$ kubectl get pods
NAME     READY     STATUS    RESTARTS   AGE
http-7b77c4cd66-74zqx          1/1       Running   0          4s
http-7b77c4cd66-fhlmx          1/1       Running   0          19m
http-7b77c4cd66-xrbpf          1/1       Running   0          4s
httpexposed-5c4cf8b7d8-qprzc   1/1       Running   0          11m

$ kubectl get deployments
NAME DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
http          3         3         3            3           19m
httpexposed   1         1         1            1           11m
</code></pre>
<ul>
<li><code>kubectl describe deployment http</code></li>
<li><code>kubectl describe svc http</code> 能看到很多信息，包括整个cluster对外的ip，各个node的内部ip之类</li>
<li><code>kubectl scale --replicas=3 deployment http</code> scale的命令</li>
<li><code>kubectl create -f deployment.yaml</code> 通过yaml文件创建一个deployment
<ul>
<li><code>kubectl create -f service.yaml</code> 也可以通过<code>yaml</code>文件创建<code>service</code></li>
<li><code>ymal</code>文件里面的内容还不是非常清楚。参考<a href="https://blog.csdn.net/luanpeng825485697/article/details/83753260" target="_blank" rel="noopener">k8s yaml文件详解</a></li>
</ul>
</li>
<li><code>kubectl apply -f deployment.yaml</code>如果<code>yaml</code>文件有改动的话，可以用这条命令来update</li>
</ul>
<pre><code> $ kubectl apply -f deployment.yaml
  Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
  deployment.extensions/webapp1 configured
</code></pre>
<ul>
<li><code>kubectl exec $pod -- /usr/bin/curl -s localhost/unhealthy</code></li>
<li><code>kubectl get ing</code> 可以用来看Ingress</li>
<li><code>kubectl create namespace</code>创建namespace</li>
<li><code>kubectl config set-context $(kubectl config current-context) --namespace=&lt;insert-namespace-name-here&gt;</code></li>
<li><code>kubectl config get-contexts</code></li>
<li><code>kubectl get namespaces</code></li>
<li><code>kubectl delete pvc --all --namespace default</code> 用这个命令来做<code>delete</code>。一堆都行。<code>pvc</code>换成<code>pod</code>，<code>deployments</code>，<code>secret</code>，<code>configmap</code>，<code>service</code>啥的</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li><a href="http://docs.kubernetes.org.cn/475.html" target="_blank" rel="noopener">k8s中文文档</a></li>
<li><a href="https://www.katacoda.com/courses/kubernetes/kubectl-run-containers" target="_blank" rel="noopener">codekara的在线课程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/14/常用Docker命令记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/14/常用Docker命令记录/" itemprop="url">Docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T15:16:01+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Docker</code>相关的信息都记录在这里</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://www.jianshu.com/p/f0a0f6a43907" target="_blank" rel="noopener">Dockerfile RUN，CMD，ENTRYPOINT命令区别</a></li>
</ul>
<h2 id="常用docker命令"><a class="header-anchor" href="#常用docker命令"></a>常用docker命令</h2>
<p>这篇记录一下 <code>Docker</code> 相关的知识，我怕我会忘啊 😅</p>
<ul>
<li><code>docker run -d / -it / -v / -p /--name/-l</code>
<ul>
<li><code>-d</code>: background; <code>-v</code>: 磁盘映射 ；<code>-p</code>：端口映射; <code>-l</code>: label</li>
</ul>
</li>
<li><code>docker build -t （build-directory） dockerfile</code> build docker image
<ul>
<li><code>-t</code> 指定编译出来的image的名字。可以带上版本。比如：firstImage:v1</li>
<li><code>-f</code> 指定dockerfile的名字</li>
</ul>
</li>
<li><code>docker inspect</code>看一个image的信息或者container的信息
<ul>
<li>docker inspect -f “” katacoda-label-example</li>
<li>These labels will remain even if the image has been untagged. When an image is untagged, it will have the name <none></none></li>
</ul>
</li>
<li><code>docker exec</code></li>
</ul>
<h2 id="docker的概念"><a class="header-anchor" href="#docker的概念"></a>Docker的概念</h2>
<ul>
<li><code>Label</code>就是中文含义一样的标签，<code>key-value</code>的形式，比如user=lynn，这样子。除了user，还会有version啊
<ul>
<li>LABEL vendor=Katacoda \ com.katacoda.version=0.0.5 \ com.katacoda.build-date=2016-07-01T10:47:29Z \ com.katacoda.course=Docker</li>
<li>container, image, demon都可以有label，在查看时候都可以用上</li>
</ul>
</li>
<li>参考链接：<a href="https://www.katacoda.com/courses/docker/2" target="_blank" rel="noopener">karacoda docker在线课程</a></li>
</ul>
<h2 id="dockerfile"><a class="header-anchor" href="#dockerfile"></a>Dockerfile</h2>
<h3 id="cmd-run"><a class="header-anchor" href="#cmd-run"></a>CMD &amp; RUN</h3>
<ul>
<li><code>CMD</code> 和 <code>RUN</code>都可以执行命令，两者的区别如下：
<ul>
<li><code>RUN</code>会生成新的镜像层，所以通常用来安装软件</li>
<li><code>CMD</code>则是在镜像部署完之后执行的命令</li>
</ul>
</li>
<li>如果在启动命令的时候带上命令的话，那么<code>CMD</code>的命令会被覆盖掉
<ul>
<li><code>docker run -it [image] /bin/bash</code>比如，执行了这句，那么即使有既定的<code>CMD</code>，也会不执行了。</li>
<li>所以可以利用这一点，为镜像设置默认启动命令，然后在实际启动时候替换。比如，<code>CMD echo &quot;hello world&quot;</code>, 可以在实际中启动改为<code>hello new world</code></li>
</ul>
</li>
</ul>
<h3 id="endpoint"><a class="header-anchor" href="#endpoint"></a>Endpoint</h3>
<ul>
<li><code>endPoint</code>是执行的起点，比如<code>bash</code>, <code>mysql</code>这些。
<ul>
<li>一个例子可以为<code>ENTRYPOINT [&quot;/bin/echo&quot;]</code>，<code>CMD &quot;world&quot;</code>。那么启动的时候会执行<code>echo world</code></li>
</ul>
</li>
</ul>
<h2 id="maven-docker-plugin"><a class="header-anchor" href="#maven-docker-plugin"></a>Maven Docker Plugin</h2>
<ul>
<li><code>maven</code>有好几个支持<code>Docker</code>的<code>plugin</code></li>
<li><code>io.fabric8:docker-maven-plugin</code> 就是其中的一个</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/02/14/Scala/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/02/14/Scala/" itemprop="url">Scala</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T10:18:49+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Scala/" itemprop="url" rel="index">
                    <span itemprop="name">Scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="scala"><a class="header-anchor" href="#scala"></a>Scala</h2>
<h3 id="scala概念快速解释"><a class="header-anchor" href="#scala概念快速解释"></a>Scala概念快速解释</h3>
<p>Scala有很多特有的概念。如果要看懂代码就得大致明白含义，这篇博客就是快速解释一下，其中可能会有不够准确的地方，就是不求甚解，只求迅速读懂scala代码了.<br>
隔了一段时间又开始看scala的代码，结果发现这篇博客写得太不声情并茂了。scala还是比较复杂的。这么简单写几句不太成，得给一点例子才行。</p>
<h4 id="object"><a class="header-anchor" href="#object"></a>object</h4>
<p>看了几篇博客，解释都不够清晰的感觉，还是<code>stackoverflow</code>上面解释得更清楚</p>
<ul>
<li>
<p>作为<code>static</code>函数的<code>class</code>文件，这是最常见到的用法：</p>
<pre><code> object A {
    def twice(i: Int): Int = 2*i
 }
</code></pre>
</li>
<li>
<p>参考链接：<br>
-<a href="https://stackoverflow.com/questions/1755345/difference-between-object-and-class-in-scala" target="_blank" rel="noopener">difference-between-object-and-class-in-scala</a></p>
</li>
</ul>
<h3 id="trait"><a class="header-anchor" href="#trait"></a>trait</h3>
<ul>
<li><a href="http://www.runoob.com/scala/scala-traits.html" target="_blank" rel="noopener">Scala Trait(特征)</a></li>
<li>类似java的Interface，其实更近似于抽象类</li>
<li>但是可以使用<code>with</code>关键字多重继承，很好用的感觉哦</li>
<li><code>scala</code>本身还是有<code>interface</code>关键字的，本身也可以使用<code>with</code>关键字来实现接口</li>
</ul>
<h4 id="case-class"><a class="header-anchor" href="#case-class"></a>case class</h4>
<ul>
<li><a href="https://blog.csdn.net/bluishglc/article/details/50914001" target="_blank" rel="noopener">csdn上的一篇文章</a></li>
<li>简单来说，case class会默认生成很多东西，比如伴生对象，比如工厂方法，比如toString， copy，构造方法参数同名的属性</li>
<li>最开心的用法，应该就是不用<code>new</code>出一个对象来。而是可以直接<code>methodName(构造函数参数)</code>这样来获取一个对象。其实是同名的工厂方法</li>
</ul>
<h4 id="implicit"><a class="header-anchor" href="#implicit"></a>implicit</h4>
<ul>
<li>
<p>隐式转换。例子如下：</p>
<pre><code>    def display(input:String):Unit = println(input)
    implicit def typeConvertor(input:Int):String = input.toString
    display(12)
</code></pre>
</li>
<li>
<p>本来的话，<code>display</code>函数只能接收一个字符串类型的参数，但是在相同作用域里面有隐式函数的存在，自动将整型转换成了字符串下类型</p>
</li>
<li>
<p>需要注意的一点是，在相同作用域里面，相同参数，相同返回值的函数，函数名并不关键。确实不关键，在调用<code>display(12)</code>的时候，我们并没有说，啊，请用隐式函数<code>typeConvertor</code></p>
</li>
<li>
<p>所以，如果有另一个隐式函数，也是将整型转换为字符串，<code>scala</code>会出错。因为回不知道用哪一个</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/rollenholt/p/4118567.html" target="_blank" rel="noopener">详尽解释的博客，博主其他博客也不错</a></li>
</ul>
</li>
</ul>
<h3 id="scala-环境"><a class="header-anchor" href="#scala-环境"></a>Scala 环境</h3>
<ul>
<li><a href="https://blog.csdn.net/high2011/article/details/76541233" target="_blank" rel="noopener">基本scala环境在IJ里面的搭建</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/01/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/01/28/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T16:21:54+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start"><a class="header-anchor" href="#quick-start"></a>Quick Start</h2>
<h3 id="create-a-new-post"><a class="header-anchor" href="#create-a-new-post"></a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server"><a class="header-anchor" href="#run-server"></a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files"><a class="header-anchor" href="#generate-static-files"></a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="header-anchor" href="#deploy-to-remote-sites"></a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo_blog/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/hexo_blog/">1</a><a class="page-number" href="/hexo_blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/hexo_blog/page/4/">4</a><a class="extend next" rel="next" href="/hexo_blog/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lynn Shen</p>
              <p class="site-description motion-element" itemprop="description">35岁开始的博客，有点晚哦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/hexo_blog/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/hexo_blog/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/hexo_blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/hexo_blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/hexo_blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
        <script src="https://billts.site/js/gitment.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
