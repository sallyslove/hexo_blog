<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo_blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo_blog/css/main.css">


<link rel="stylesheet" href="/hexo_blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sallyslove.github.io","root":"/hexo_blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/page/3/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lynn Shen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sallyslove.github.io/hexo_blog/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>跬步</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo_blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">跬步</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不积跬步，无以至千里</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo_blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo_blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/06/25/Cassandra_Maintain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/06/25/Cassandra_Maintain/" class="post-title-link" itemprop="url">Cassandra Maintain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-25 17:01:57" itemprop="dateCreated datePublished" datetime="2019-06-25T17:01:57+08:00">2019-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 16:24:25" itemprop="dateModified" datetime="2021-02-22T16:24:25+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/06/25/Cassandra_Maintain/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra Maintain" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/06/25/Cassandra_Maintain/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/06/25/Cassandra_Maintain/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://thelastpickle.com/blog/2016/07/27/about-deletes-and-tombstones.html" target="_blank" rel="noopener">关于Cassandra的删除和墓碑</a></li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html#defragmentation" target="_blank" rel="noopener">最新官方文档，非常清楚</a></li>
<li><a href="https://zhaoyanblog.com/archives/966.html" target="_blank" rel="noopener">有上篇文章的翻译</a></li>
<li><a href="https://www.cnblogs.com/didda/p/4728588.html" target="_blank" rel="noopener">Cassandra 的压缩策略STCS，LCS 和 DTCS</a></li>
</ul>
<h2 id="delete-data"><a class="header-anchor" href="#delete-data"></a>Delete Data</h2>
<ul>
<li>找了一下博客，发现居然都没有一个章节是关于删除数据的</li>
<li>事实上，<code>Cassandra</code>里面的删除是一种写操作，会插入墓碑。在上面的参加链接里面详尽描述了这个过程</li>
<li>可以使用<code>SSTabledump</code>命令来进行查询。<strong><em>但是并没有在我们的环境中找到这个命令</em></strong></li>
<li>需要注意的是这里讨论的都是删除之后再<code>flush</code>到<code>SSTable</code>里的情况，<code>Memtable</code>里面的数据删除会有所不痛</li>
<li><code>gc_grace_seconds</code>：在删除数据之后会保存一段时间的墓碑，以此来保证数据同步。</li>
</ul>
<h3 id="删除某一行的某个数据"><a class="header-anchor" href="#删除某一行的某个数据"></a>删除某一行的某个数据</h3>
<ul>
<li>
<p>可以只删除某一行的某一个数据，如下</p>
</li>
<li>
<p>当删除掉某一行的某个数据的时候，使用上面的<code>SSTabledump</code>命令，这一行数据将没有<code>liveness_info</code></p>
<pre><code>DELETE crates FROM tlp_lab.tombstones WHERE fruit='apple' AND date ='20160617';
</code></pre>
</li>
</ul>
<p>那么这个数据会显示<code>null</code></p>
<pre><code>  alain$ echo &quot;SELECT * FROM tlp_lab.tombstones LIMIT 100;&quot; | cqlsh
  fruit   | date     | crates
  ---------+----------+-----------------
  apple | 20160617 |            null
</code></pre>
<h3 id="删除一行的数据"><a class="header-anchor" href="#删除一行的数据"></a>删除一行的数据</h3>
<ul>
<li>
<p>删除掉一行之后，这一行的数据的<code>cell</code>也将没有任何数据</p>
<pre><code>&quot;rows&quot; : [
{
  &quot;type&quot; : &quot;row&quot;,
  &quot;position&quot; : 19,
  &quot;clustering&quot; : [ &quot;20160617&quot; ],
  &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:31:41.142454Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:31:41Z&quot; },
  &quot;cells&quot; : [ ]
}

&quot;rows&quot; : [
{
  &quot;type&quot; : &quot;row&quot;,
  &quot;position&quot; : 125,
  &quot;clustering&quot; : [ &quot;20160616&quot; ],
  &quot;liveness_info&quot; : { &quot;tstamp&quot; : &quot;2016-06-16T18:52:41.903751Z&quot;, &quot;ttl&quot; : 2592000, &quot;expires_at&quot; : &quot;2016-07-16T18:52:41Z&quot;, &quot;expired&quot; : false },
  &quot;cells&quot; : [
    { &quot;name&quot; : &quot;crates&quot;, &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T18:52:41.903750Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T18:52:41Z&quot; } },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;6&quot; ], &quot;value&quot; : &quot;&quot; },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;7&quot; ], &quot;value&quot; : &quot;&quot; },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;8&quot; ], &quot;value&quot; : &quot;&quot; }
  ]
}
</code></pre>
</li>
</ul>
<h3 id="删除一个范围内的数据"><a class="header-anchor" href="#删除一个范围内的数据"></a>删除一个范围内的数据</h3>
<ul>
<li>
<p>这个含义就是，比如下面的命令，这样可以一次性删除好几行数据</p>
<pre><code>DELETE FROM tlp_lab.tombstones WHERE fruit='apple' AND date &gt; '20160615';
</code></pre>
</li>
<li>
<p>那么存下来的数据会变为，<code>type</code>变化了</p>
<pre><code>&quot;rows&quot; : [
    {
      &quot;type&quot; : &quot;range_tombstone_bound&quot;,
      &quot;start&quot; : {
        &quot;type&quot; : &quot;exclusive&quot;,
        &quot;clustering&quot; : [ &quot;20160615&quot; ],
        &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:53:21.133300Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:53:21Z&quot; }
      }
    },
    {
      &quot;type&quot; : &quot;range_tombstone_bound&quot;,
      &quot;end&quot; : {
        &quot;type&quot; : &quot;inclusive&quot;,
        &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:53:21.133300Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:53:21Z&quot; }
      }
</code></pre>
</li>
</ul>
<h3 id="删除一个partition的数据"><a class="header-anchor" href="#删除一个partition的数据"></a>删除一个partition的数据</h3>
<ul>
<li>
<p>命令如下：</p>
<pre><code>DELETE FROM tlp_lab.tombstones WHERE fruit='pickles';
</code></pre>
<p>会在<code>partition</code>的地方加入<code>deletion_info</code>，而通常情况下只有<code>key</code>和<code>position</code></p>
<pre><code>{
  &quot;partition&quot; : {
    &quot;key&quot; : [ &quot;pickles&quot; ],
    &quot;position&quot; : 0,
    &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-17T09:38:52.550841Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-17T09:38:52Z&quot; }
}
  
&quot;partition&quot; : {
   &quot;key&quot; : [ &quot;apple&quot; ],
   &quot;position&quot; : 0
},  
</code></pre>
</li>
</ul>
<h3 id="集合数据"><a class="header-anchor" href="#集合数据"></a>集合数据</h3>
<ul>
<li>需要额外注意的一点是，如果使用集合数据，比如<code>list</code>，那么在更新的时候，会有一个潜在的删除操作。会将旧的数据删除，这一点非常恼人，需要注意</li>
</ul>
<h3 id="gc-grace-seconds参数"><a class="header-anchor" href="#gc-grace-seconds参数"></a>gc_grace_seconds参数</h3>
<ul>
<li><code>gc_grace_seconds</code>参数的默认值为10天，这个参数的意思就是这个数据被删除之后，相应的<code>tombstone</code>也不会立刻在<code>compaction</code>中被移除</li>
<li>这个值的目的是为了保证删除的一致性。以防有的节点上面删除失败，出现幽灵数据。在维护操作章节中有进一步的解释。假设有删除失败，然后客户做了<code>repair</code>操作，那么这个数据会被复制到已经删除的节点上面。那么就错了。相反，如果是插墓碑，即使有节点没插上，<code>repair</code>的时候也只会复制个墓碑过去。这也就是为什么需要需要维持一阵墓碑</li>
</ul>
<h2 id="维护操作"><a class="header-anchor" href="#维护操作"></a>维护操作</h2>
<ul>
<li><code>minor compaction</code>: 这个就是<code>C#</code>自己做的压缩</li>
<li><code>major compaction</code>: 这个就是手动的用<code>nodetool</code>做的，会对所有的当前<code>node</code>上面的<code>SSTable</code>进行压缩</li>
<li><code>user defined compaction</code>： 客户自定义的，对部分<code>SSTable</code>进行压缩。用户可以只针对一张表来做压缩，Cassandra会对数据进行校验，使用<code>unchecked_tombstone_compaction</code> 参数可以跳过这个校验过程</li>
<li><code>Scrub</code>: 这个操作会尝试修复<code>SSTable</code>，所以这个动作有可能会删除有效但是已经坏掉的数据，如果这个发生，得用<code>repair</code>来修复</li>
<li>在以下的参考链接里面还有一些奇特的维护操作，暂时没学习</li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html" target="_blank" rel="noopener">维护操作和压缩</a></li>
</ul>
<h2 id="compacting-sstable-data"><a class="header-anchor" href="#compacting-sstable-data"></a>Compacting SSTable Data</h2>
<p><img src="https://docs.datastax.com/en/cassandra/3.0/cassandra/images/dml_compaction.png" alt="官网压缩数据图片"></p>
<h3 id="为什么需要compaction"><a class="header-anchor" href="#为什么需要compaction"></a>为什么需要Compaction</h3>
<ul>
<li><code>cassandra</code>并不会删除数据。当需要<code>update</code>一个数据的时候，也不是在<code>SSTable</code>里面进行覆盖，而是会插入一个新的数据，带上新的<code>version</code>。</li>
<li>这样做的话，<code>cassandra</code>写入数据会非常快，因为不需要查询，但是弊端就是会有越来越多的数据。</li>
<li>这个时候就需要进行<code>compaction</code>。</li>
</ul>
<h3 id="什么是compaction"><a class="header-anchor" href="#什么是compaction"></a>什么是Compaction</h3>
<ul>
<li>To keep the multiple versions of the SSTables from overwhelming it, the database merges SSTables on a regular basis to get rid of the older versions of the data。 <code>cassandra</code>会在一个基础之上对旧的版本的数据进行合并，这个就是<code>compaction</code></li>
<li><code>cassandra</code>默认会进行很多次小的<code>compaction</code>。在有新生成<code>SStable</code>的时候，或者默认5分钟会进行一次检查，需不需要进行<code>minor compaction</code></li>
<li>会合并同一行的，不同版本的数据。不同版本带着不同的<code>timestamp</code></li>
</ul>
<h3 id="什么情况下墓碑会在compaction中被移除"><a class="header-anchor" href="#什么情况下墓碑会在compaction中被移除"></a>什么情况下墓碑会在Compaction中被移除</h3>
<ul>
<li>这也是来自上篇参考文档的。这篇文档比较清楚</li>
<li>事实上有好几个要求：
<ul>
<li><code>gc_grace_seconds</code> 已经过了，这点已经在上面解释过了</li>
<li>_If partition X contains the tombstone, the sstable containing the partition plus all sstables containing data older than the tombstone containing X must be included in the same compaction. We don’t need to care if the partition is in an sstable if we can guarantee that all data in that sstable is newer than the tombstone. If the tombstone is older than the data it cannot shadow that data._这句话实在太拗口了，含义就是说墓碑得是最老的一个，否则删除不掉？</li>
<li><code>only_purge_repaired_tombstones</code> 这还有一个参数，如果不是repair过程中的墓碑就不删除。这个参数估计很少用吧</li>
<li>还有一个特殊情况，就是整个<code>SSTable</code>里面都是墓碑，这种情况在以时间序列的表并且使用了<code>TTL</code>之后很容易出现。如果没有被整表删除，那么就像上一个bullet里面讲的，说明其他表里面有更老的数据。有一个工具<code>sstableexpiredblockers</code>可以进行查询。还有一个参数可以使用<code>unsafe_aggressive_sstable_expiration</code>，在使用时间压缩策略时候，这个参数可以保证删除这种表</li>
</ul>
</li>
</ul>
<h3 id="compaction的参数和命令"><a class="header-anchor" href="#compaction的参数和命令"></a>compaction的参数和命令</h3>
<ul>
<li>在上篇链接中有，列一部分：
<ul>
<li><code>log_all</code>: 可以记录压缩的日志</li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html" target="_blank" rel="noopener">维护操作和压缩</a></li>
</ul>
</li>
<li>命令在上面的链接中也有，这边也列一部分：
<ul>
<li><code>compactionstats</code>: 状态</li>
<li><code>compactionhistory</code>: 历史</li>
</ul>
</li>
<li>如果是在一个正在运行的系统中改变表的参数，可以使用<code>ALTER TABLE</code>命令来进行</li>
</ul>
<h3 id="其他一些campaction细节"><a class="header-anchor" href="#其他一些campaction细节"></a>其他一些Campaction细节</h3>
<ul>
<li>在<code>compaction</code>期间，<code>cassandra</code>会合并<code>key</code>和<code>column</code>，同时会将过期的墓碑删除，还会生成一个新的<code>index</code>？ <strong><em>这个index是什么东西啊</em></strong></li>
<li>合并之后会生成一个新的<code>SSTable</code>。而不需要的数据版本和行就会留在旧的<code>SSTable</code>里面，当正在执行的读操作结束之后，就可以删除掉。</li>
<li><code>compaction</code>期间的资源耗用会上升，但是<code>compaction</code>结束之后应该会释放空间，因为它合并了<code>SSTable</code></li>
<li>旧的被合并的<code>table</code>会被加上<code>deletion</code>标签，并且在数据库重启或者在使用<code>reference counting mechanism</code>的时候。<strong><em>这个<code>reference counting mechanism</code>是什么啊</em></strong></li>
<li><code>compaction</code>的算法是可以配置的，默认的是<code>size-tiered compaction</code>。这个算法会合并大小相近的table，生成大table</li>
</ul>
<h3 id="compaction对读数据的影响"><a class="header-anchor" href="#compaction对读数据的影响"></a>Compaction对读数据的影响</h3>
<ul>
<li><code>compaction</code>是<code>per-node</code>的，所以某个数据在<code>node1</code>上面的旧版本可能删除了。但是在<code>node2</code>上面还有。</li>
<li>这样读的时候会进行一个合并，并且返回最后一个写的<code>version</code>。这个原则是<code>last-write-win</code></li>
<li>Cassandra can read data directly from the new SSTable even before it finishes writing, instead of waiting for the entire compaction process to finish.</li>
</ul>
<h3 id="compaction-策略"><a class="header-anchor" href="#compaction-策略"></a>Compaction 策略</h3>
<ul>
<li>不同的策略决定了如何来选择<code>SSTable</code>以及压缩后的行如何插入到新的表格中</li>
<li>我在压缩策略的道路上越走越远了啊。😂</li>
</ul>
<h4 id="sizetieredcompactionstrategy-stcs"><a class="header-anchor" href="#sizetieredcompactionstrategy-stcs"></a>SizeTieredCompactionStrategy (STCS)</h4>
<h5 id="工作流程"><a class="header-anchor" href="#工作流程"></a>工作流程</h5>
<ul>
<li>当有4个大小相近的<code>STable</code>的时候就开始合并，所以并不是完全相同大小的</li>
<li>将这些大小相近的<code>SSTable</code>合并成一个，当有4个更大的<code>table</code>的时候，再合并成更大的<code>SSTable</code></li>
<li>所以会有很多大小不同的<code>SSTable</code>同时存在</li>
</ul>
<h4 id="参数"><a class="header-anchor" href="#参数"></a>参数</h4>
<h5 id="优缺点"><a class="header-anchor" href="#优缺点"></a>优缺点</h5>
<ul>
<li>优势：写密集的工作良好。</li>
<li>逆势：
<ul>
<li>可能降低读的效率。因为策略不保证同一行的数据被限制在有限的数据文件里面，这样在读取的时候会需要读取更多的数据文件。</li>
<li>可能长期保持旧数据；不同版本的同一行会可能分布在不同的<code>SSTable</code>里面。并且不利于删除旧数据</li>
<li>需要的内存和磁盘都会随着时间增加。磁盘在下面的问题章节中可以看到；而内存也是显而易见的，当<code>SSTable</code>的大小达到一定级别，一次压缩需要的内存会很大。因为需要<code>load SSTable</code>到内存里面</li>
</ul>
</li>
</ul>
<h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5>
<ul>
<li>
<p>在实际的工作中碰到了缺点中的问题，系统在工作3个月的时候能够在一个节点上面占用靠13G的磁盘量。</p>
</li>
<li>
<p>观察下来，其实策略是在正常工作的。里面明显能够看到大小不同的data文件。</p>
</li>
<li>
<p>现在客户的需求是不手动操作来解决占用磁盘的问题。总的来说，貌似不现实，毕竟多数建议是关闭自动SSTable压缩，改用手动在空闲期间进行压缩</p>
<pre><code>total 13G
 115M Jan 24  2019 la-2421-big-Data.db
 101M Jan 24  2019 la-2443-big-Data.db
 453K Jan 24  2019 la-2447-big-Data.db
 124M Feb  3 14:47 lb-5276-big-Data.db
 216M Feb  3 14:54 lb-5280-big-Data.db
 235M Feb  3 14:54 lb-5281-big-Data.db
 680M Feb  4 11:24 lb-5294-big-Data.db
 781M Feb  4 11:36 lb-5295-big-Data.db
 2.8G Feb  4 11:54 lb-5296-big-Data.db
 3.3G Feb  4 12:52 lb-5298-big-Data.db
 3.5G Feb  4 12:54 lb-5297-big-Data.db
</code></pre>
</li>
</ul>
<h4 id="leveledcompactionstrategy-lcs"><a class="header-anchor" href="#leveledcompactionstrategy-lcs"></a>LeveledCompactionStrategy (LCS)</h4>
<h5 id="工作流程-v2"><a class="header-anchor" href="#工作流程-v2"></a>工作流程</h5>
<ul>
<li>
<p>LCS的工作流程是最不清晰的了。网上各类文章，有说L1的数据文件数量是L0的10倍的，有说整体大小的。我一口血都要喷显示器上面了,不带这么不严谨的好嘛 😦</p>
</li>
<li>
<p>看代码其实最清楚了。应该是大小，不是数量：</p>
</li>
<li>
<p>以下代码里面，maxSSTableSizeInBytes= 160M * 1024<em>1024，所以L0最大是160M</em>4</p>
</li>
<li>
<p>代码在<code>org.apache.cassandra.db.compaction.LeveledCompactionStrategy</code></p>
<pre><code>public static long maxBytesForLevel(int level, int levelFanoutSize, long maxSSTableSizeInBytes) {
  if (level == 0) {
      return 4L * maxSSTableSizeInBytes;
  } else {
      double bytes = Math.pow((double)levelFanoutSize, (double)level) * (double)maxSSTableSizeInBytes; 
  }
}
</code></pre>
</li>
<li>
<p><code>LCS</code>一大特点是会尽量保证在同一个层级里面，同一<code>partition key</code>的数据在同一张<code>SSTable</code>表里面。当然<code>L0</code>没法保证，因为这一层级是<code>flush</code>来的</p>
</li>
<li>
<p>为了做到这一点，<code>LCS</code>在进行一次压缩的时候会包括上一级中也有这个<code>partition key</code>的数据，所以这个策略要读表啊。比如在<code>L1</code>级数据大于上限需要压缩的时候，<code>L2</code>级中包含相同<code>key</code>的表也要被一起合并，但是欣慰的是，应该也只有一张表。毕竟每一级都是这么干的。-</p>
</li>
<li>
<p>我们在<code>Cassandra</code>中可以设定进行并行的压缩，那么在<code>LCS</code>策略中需要保证同一个<code>parititon key</code>的数据只在一个压缩线程中，不能有交叉重叠</p>
</li>
<li>
<p>所以，压缩<code>L0</code>层级的时候，会带上所有<code>L1</code>的表一起压缩。如果<code>L0</code>很多，那么没法一次压缩做完所有<code>L0</code>的表格</p>
</li>
<li>
<p>压缩时候优先考虑最高级别的。所有<code>L0</code>是最后考虑的一个层级</p>
</li>
<li>
<p><code>LCS</code>有可能触发<code>major compaction</code>，这点需要进一步考察。</p>
</li>
<li>
<p>如果<code>L0</code>级别的表超过32个，会进行<code>STCS</code></p>
</li>
</ul>
<h5 id="相关参数"><a class="header-anchor" href="#相关参数"></a>相关参数</h5>
<ul>
<li><code>sstable_size_in_mb</code>: 就是上面代码里面那个<code>maxSSTableSizeInBytes</code>，第一层级的大小</li>
<li><code>fanout_size</code>： 各个层级之间的差异，上面代码里面的<code>levelFanoutSize</code></li>
</ul>
<h5 id="优缺点-v2"><a class="header-anchor" href="#优缺点-v2"></a>优缺点</h5>
<ul>
<li>优点：
<ul>
<li>读比较频繁的更推荐这个算法。其实写的应该也可以。目前这应该是应用最广泛的压缩算法了。</li>
<li>容易预测内存需求大小</li>
<li>更容易删除旧数据</li>
<li>需要的磁盘空间更小</li>
</ul>
</li>
<li>缺点：
<ul>
<li>进行得更为频繁，所以需要的I/O比较多</li>
</ul>
</li>
</ul>
<h4 id="timewindowcompactionstrategy-twcs"><a class="header-anchor" href="#timewindowcompactionstrategy-twcs"></a>TimeWindowCompactionStrategy (TWCS)</h4>
<ul>
<li>接上文碰到的问题，刚刚好出问题的表的<code>partition key</code>是日期，所以研究得最多的就是这个策略了。而时间策略是唯一一个可以彻底删除过期的表的策略。当然，要结合下面的<code>TTL</code>一起用。</li>
<li>需要注意的一点是：<code>TCWS</code>是从<code>Cassandra 3.0.8</code>才被引入的。而我们产品仍旧停留在<code>2.2.8</code>上，这也是为什么最后没法采用这个解决方案</li>
</ul>
<h5 id="工作原理"><a class="header-anchor" href="#工作原理"></a>工作原理</h5>
<ul>
<li>这个算法挺有意思的，而且简单好懂。就是说在一段时间内，比如一个小时内，使用<code>STCS</code>算法，然后在时间点上，一个小时结束的时候，把这个小时内的都压成一个大的数据文件。</li>
<li>第二个小时开始的时候，重新算起，上一个小时压出来的大表就放那里不动了。</li>
</ul>
<h5 id="相关参数-v2"><a class="header-anchor" href="#相关参数-v2"></a>相关参数</h5>
<ul>
<li><code>compaction_window_unit</code>:MINUTES, HOURS, or DAYS</li>
<li><code>compaction_window_size</code>:默认为1</li>
<li><code>unsafe_aggressive_sstable_expiration</code>: 这个参数很有意思，就是说当一个表里面都是墓碑的时候，直接把表删除掉。这个参数是一个全局参数，是在启动<code>JVM</code>的时候设置的。因为是有风险的，有可能造成幽灵数据。同时，设置这个参数会覆盖掉<code>unchecked_tombstone_compaction</code>.</li>
</ul>
<h5 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h5>
<ul>
<li><a href="https://thelastpickle.com/blog/2016/12/08/TWCS-part1.html" target="_blank" rel="noopener">TWCS-part1</a></li>
<li><a href="https://thelastpickle.com/blog/2017/01/10/twcs-part2.html" target="_blank" rel="noopener">TWCS-part2</a></li>
</ul>
<h3 id="ttl"><a class="header-anchor" href="#ttl"></a>TTL</h3>
<h4 id="ttl被提出的背景"><a class="header-anchor" href="#ttl被提出的背景"></a>TTL被提出的背景</h4>
<ul>
<li>这是在处理产品的一个问题的时候被提出的，该问题就是，由于某个统计功能一直在写数据，然后每隔一个月左右会删除数据。</li>
<li>表格以<code>date</code>作为<code>partition key</code>，所有数据在一个表里面，所以即使数据被删除了也没法直接<code>truncate</code>表，只能依赖<code>Cassandra</code>的<code>compaction</code>。</li>
<li>最后越来越占磁盘。使用的策略是默认的<code>STCS</code>。然后就有大佬提了<code>TTL</code></li>
<li>我原本在考虑加<code>crontab job</code>，但是其实没有意义，因为<code>Cassandra</code>提供的其实就是类似功能。</li>
</ul>
<h4 id="什么是ttl-time-to-live"><a class="header-anchor" href="#什么是ttl-time-to-live"></a>什么是TTL(time-to-live)</h4>
<ul>
<li><em>TTL: allows to specify an optional Time To Live (in seconds) for the inserted values. If set, the inserted values are automatically removed from the database after the specified time. Note that the TTL concerns the inserted values, not the column themselves. This means that any subsequent update of the column will also reset the TTL (to whatever TTL is specified in that update). By default, values never expire. A TTL of 0 or a negative one is equivalent to no TTL.</em></li>
<li>其实<code>Cassandra</code>里面<code>TTL</code>的概念到处都是。但是通常说的<code>TTL</code>是指参数<code>default_time_to_live</code>，也就是说到了这个时间点，<code>Cassandra</code>会自动将数据删除掉。</li>
<li>默认值为0，也就是<code>Cassandra</code>会认为这个数据一直有效</li>
<li>这个参数在<code>desc tables</code>里面可以看到，但是我们产品的异步模块里面其实在代码里面进行了覆盖。<code>java</code>代码里面弄了个系统参数，在插入数据的时候代入了这个参数</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/06/17/%E8%BD%AF%E4%BB%B6%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/06/17/%E8%BD%AF%E4%BB%B6%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/" class="post-title-link" itemprop="url">软件衡量标准</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-17 17:20:49" itemprop="dateCreated datePublished" datetime="2019-06-17T17:20:49+08:00">2019-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-16 10:08:22" itemprop="dateModified" datetime="2019-08-16T10:08:22+08:00">2019-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/06/17/%E8%BD%AF%E4%BB%B6%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/" class="post-meta-item leancloud_visitors" data-flag-title="软件衡量标准" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/06/17/%E8%BD%AF%E4%BB%B6%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/06/17/%E8%BD%AF%E4%BB%B6%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作中接触到一些软件衡量标准的需求，必须对这些概念有所了解和理解。所以解释如下了。</p>
<h3 id="scalability"><a class="header-anchor" href="#scalability"></a>Scalability</h3>
<ul>
<li>
<blockquote>
<p>Scalability is the property of a system to handle a growing amount of work by adding resources to the system 维基百科里面的这个解释实在很到位啊。通过加资源来获得更大的能力</p>
</blockquote>
</li>
<li>以下内容基本是维基百科的翻译：
<ul>
<li>用户可扩展性： 能够同时支持多少用户</li>
<li>功能可扩展性： 能不能扩展功能，而不会影响现有功能</li>
<li>地理上的可扩展性： 就是直接的字面含义，类似部署时候的机器是不是必须local在一起。</li>
<li>负载可扩展性： 这就是我们通常意义上面知道的，加node或者加cpu，加内存，能不能够加可处理的能力</li>
<li>代扩展性： 这个有点难以理解，我理解成能不能支持不同版本。比如说，我同时安装java8和java7，那么我可以在maven里面指定生成的代码之类的</li>
<li>种类的可扩展性： 这个可以理解的，就是是不是支持multi-verdor。就像java，可以在windows上面，也可以在linux上面</li>
</ul>
</li>
<li>Scaling horizontally： 就是增减node</li>
<li>Scaling vertically： 增减resource，增减cpu或者内存</li>
<li>总的来说，还是挺复杂的。</li>
<li>参考链接：
<ul>
<li><a href="https://en.wikipedia.org/wiki/Scalability" target="_blank" rel="noopener">维基百科</a></li>
</ul>
</li>
</ul>
<h3 id="testability"><a class="header-anchor" href="#testability"></a>Testability</h3>
<p>testability跟我想象的稍有不同，就是说这个模块或者软件的可测试性。实在有点复杂啊</p>
<ul>
<li>总的来说，感觉实在是太抽象了。 <strong><em>没看懂</em></strong>
<ul>
<li>Class I: there exists a finite complete test suite.</li>
<li>Class II: any partial distinguishing rate (i.e. any incomplete capability to distinguish correct systems from incorrect systems) can be reached with a finite test suite.</li>
<li>Class III: there exists a countable complete test suite.</li>
<li>Class IV: there exists a complete test suite.</li>
<li>Class V: all cases.</li>
</ul>
</li>
<li>参考链接：<br>
+<a href="https://en.wikipedia.org/wiki/Software_testability" target="_blank" rel="noopener">维基百科</a></li>
</ul>
<h3 id="robustness-computer-science"><a class="header-anchor" href="#robustness-computer-science"></a>Robustness (computer science)</h3>
<ul>
<li>robustness is the ability of a computer system to cope with errors during execution and cope with erroneous input。跟想象的不一样啊，更多focus的是handle error的能力</li>
<li>参考链接：
<ul>
<li>[维基百科](<a href="https://en.wikipedia.org/wiki/Robustness_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robustness_(computer_science)</a></li>
</ul>
</li>
</ul>
<h3 id="computer-security"><a class="header-anchor" href="#computer-security"></a>Computer Security</h3>
<ul>
<li>the protection of computer systems from theft or damage to their hardware, software or electronic data, as well as from disruption or misdirection of the services they provide.</li>
<li>参考链接
<ul>
<li><a href="https://en.wikipedia.org/wiki/Computer_security" target="_blank" rel="noopener">维基百科</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/06/17/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/06/17/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Java数据类型 --- 常用数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-17 13:14:34" itemprop="dateCreated datePublished" datetime="2019-06-17T13:14:34+08:00">2019-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 14:58:08" itemprop="dateModified" datetime="2021-07-12T14:58:08+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/06/17/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Java数据类型 --- 常用数据类型" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/06/17/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/06/17/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一些特别的数据类型<br>
author: Lynn Shen<br>
categories: Java<br>
date: 2019-06-17 13:14:34<br>
tags:</p>
<hr>
<h3 id="java-util-function-supplier"><a class="header-anchor" href="#java-util-function-supplier"></a>java.Util.Function.Supplier</h3>
<ul>
<li>这个接口只有一个方法，Get方法。void，返回一个T</li>
<li>把它当工厂方法看就是了。</li>
<li>顾名思义，提供者。</li>
<li><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">JAVA8 Supplier接口</a></li>
<li>感觉就是一次性生成。同一个接口，在初始化时候给出get函数，可以有不同实现</li>
<li>supplier作为function interface，有@FunctionalInterface annotation。所以可以直接用lamda来作为实现。比如：<code>()-&gt;getString()</code>可以作为<code>Supplier&lt;String&gt;</code>的实现</li>
</ul>
<h3 id="java关键字native"><a class="header-anchor" href="#java关键字native"></a>java关键字native</h3>
<p>我要看native的函数。找不到，OMG。其实之前看到过native的用法，知道这个玩意，但是还是写在这里吧。<br>
感觉一片参考链接就能解释清楚啦。</p>
<ul>
<li>其实就是java吧，不像c和c++善于处理底层的东西。所以就会调用一些不是java写的函数。这些函数就用native关键字来修饰</li>
<li>native是通过JNI（Java Native Interface）接口来调用这些函数的</li>
<li>参考链接
<ul>
<li><a href="https://www.cnblogs.com/b3051/p/7484501.html" target="_blank" rel="noopener">java中native的用法</a></li>
</ul>
</li>
</ul>
<h3 id="生成random的方法"><a class="header-anchor" href="#生成random的方法"></a>生成Random的方法</h3>
<p>有好几个相关的类型，写在这里。是在工作中需要生成随机<code>port</code>碰到的</p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.jianshu.com/p/2f6acd169202#" target="_blank" rel="noopener">Java 随机数 Random VS SecureRandom</a></li>
<li><a href="https://www.bbsmax.com/A/kjdwxba6zN/" target="_blank" rel="noopener">Java中的随机数生成器：Random，ThreadLocalRandom，SecureRandom</a></li>
<li><a href="http://ju.outofmemory.cn/entry/286621" target="_blank" rel="noopener">Java中生成随机数Random、ThreadLocalRandom、SecureRandom</a></li>
<li><a href="https://blog.csdn.net/weixin_33738555/article/details/93434637" target="_blank" rel="noopener">SecureRandom的正确使用</a></li>
<li><a href="https://blog.csdn.net/weixin_35703883/article/details/81138425" target="_blank" rel="noopener">SecureRandom生成随机数</a></li>
<li><a href="https://www.cnblogs.com/deng-cc/p/8064481.html" target="_blank" rel="noopener">SecureRandom</a></li>
</ul>
</li>
</ul>
<h4 id="math-random"><a class="header-anchor" href="#math-random"></a>Math.random</h4>
<ul>
<li>产生的随机数是0 - 1 之间的一个 double，即0 &lt;= random &lt; 1。</li>
<li>第一次调用<code>Math.random()</code>方法时，自动创建了一个伪随机数生成器，实际上用的是 <code>new java.util.Random()</code>。</li>
<li><code>Math.random()</code>方法是线程安全的。</li>
</ul>
<h4 id="java-util-random"><a class="header-anchor" href="#java-util-random"></a>java.util.Random</h4>
<ul>
<li><code>Random</code>类中实现的随机算法是伪随机，也就是有规则的随机</li>
<li>种子一样的情况下，两个<code>Random</code>类产生的是一模一样的数列</li>
<li>所以在安全性要求比较高，或者使用比较频繁时，不适合使用<code>Random</code>，因为值是可预测的</li>
<li>然后生成的随机数是左边闭环，右边开的。</li>
</ul>
<h4 id="java-security-securerandom"><a class="header-anchor" href="#java-security-securerandom"></a>java.security.SecureRandom</h4>
<ul>
<li><code>SecureRandom</code> 其实和<code>Random</code>一样，种子一样的时候生成的数列是固定的</li>
<li>也是继承至 java.util.Random。</li>
<li>不一样的是，<code>SecureRandom</code>收集了一些随机事件，比如鼠标点击，键盘点击等等， 使用这些随机事件作为种子</li>
<li>通过new来初始化，在不适用任何源的情况下，就是说无参数构造函数的话，默认来说会使用<code>NativePRNG</code>算法生成随机数</li>
<li>不要使用人为指定的源，尽量使用系统的随机源。系统的随机源在java8中是可以配置的，配置在<code>$JAVA_HOME/jre/lib/security/java.security</code>中的<code>securerandom.source</code>属性。例如jdk1.8中该配置为:<code>securerandom.source=file:/dev/random</code></li>
<li>实际上SHA1PRNG的性能将近要比NativePRNG的性能好一倍，synchronized的代码少了一半，所以没有特别重的安全需要，尽量使用SHA1PRNG算法生成随机数。</li>
</ul>
<h4 id="java-util-concurrent-threadlocalrandom"><a class="header-anchor" href="#java-util-concurrent-threadlocalrandom"></a>java.util.concurrent.ThreadLocalRandom</h4>
<ul>
<li>java7之后引进的</li>
<li>继承自java.util.Random</li>
</ul>
<h3 id="queue"><a class="header-anchor" href="#queue"></a>Queue</h3>
<h4 id="linkedblockingqueue"><a class="header-anchor" href="#linkedblockingqueue"></a>LinkedBlockingQueue</h4>
<ul>
<li>
<p><code>take</code>函数会从<code>queue</code>的头部拿出一个<code>item</code>。所以首先是按照顺序取出<code>item</code>的，并且在取出后会从队列中删除</p>
</li>
<li>
<p>当队列中没有数据的时候，会在<code>take</code>函数中等待，直到有数据为止</p>
<p>while (count.get() == 0) {<br>
notEmpty.await();<br>
}</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/05/15/Cassandra%E7%9A%84repair%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/05/15/Cassandra%E7%9A%84repair%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Cassandra的repair机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-15 17:52:05" itemprop="dateCreated datePublished" datetime="2019-05-15T17:52:05+08:00">2019-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 17:04:27" itemprop="dateModified" datetime="2021-02-22T17:04:27+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/05/15/Cassandra%E7%9A%84repair%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra的repair机制" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/05/15/Cassandra%E7%9A%84repair%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/05/15/Cassandra%E7%9A%84repair%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cassandra的repair机制"><a class="header-anchor" href="#cassandra的repair机制"></a>Cassandra的repair机制</h2>
<p>这篇讨论一些<code>robustness</code>的东西。主要就是一个节点<code>down</code>了会怎么样。其实目前知道的就是<code>hint</code>，但是记录下来。<br>
从一些文档里面看，这个属于写流程的一部分。确实是，读的话，如果<code>node down</code>了应该不会从上面读取了。会写到<code>the coordinator node</code>上面。<code>version 1.0</code>有所不同，但是这个版本太旧了。</p>
<blockquote>
<p>By design, hinted handoff inherently allows Cassandra to continue performing the same number of writes even when the cluster is operating at reduced capacity.</p>
</blockquote>
<h3 id="hinted-handoff简述"><a class="header-anchor" href="#hinted-handoff简述"></a>Hinted Handoff简述</h3>
<ul>
<li><strong><code>hinted handoff</code> 和 一般说的<code>hint</code>应该是同一个东西。</strong> 前者是一个机制，后者就是这个机制产生的事件或者记录。</li>
<li><code>hinted handoff</code>跟<code>consistency level</code>相关，毕竟这个是写机制的一部分。</li>
<li><code>cassandra</code>的<code>config</code>文件里面需要配置几个参数：
<ul>
<li><code>hinted_handoff_enabled</code>：默认为<code>true</code>，打开这个机制</li>
<li><code>max_hint_window_in_ms</code>： 为已经<code>down</code>掉的<code>node</code>记录<code>hint log</code>的时间长度</li>
<li><code>gc_grace_seconds</code>: Configures the time-to-live (TTL) period for a hint so that the database won’t replay the hint after this duration. Setting this parameter to 0 disables hints。 这个参数没用过，后面可以试试看</li>
<li><code>hinted_handoff_throttle_in_kb</code> 和    <code>max_hints_delivery_threads</code> 这两个没咋研究过，先放着吧</li>
</ul>
</li>
<li>按照文档，当写入发生时候，并且<code>a replica node for the key is down</code>。就可能会触发<code>hinted handoff</code>的机制</li>
</ul>
<h4 id="hint-详述"><a class="header-anchor" href="#hint-详述"></a>Hint 详述</h4>
<ul>
<li>
<blockquote>
<p>The hint consists of a target ID for the downed node, a hint ID that is a time UUID for the data, a message ID that identifies the Cassandra version, and the data itself as a blob.</p>
</blockquote>
<ul>
<li><code>hint</code>里面有：down node的target ID， 标注这条数据的hint ID， 标注<code>cassandra version</code>的<code>message ID</code>以及数据本身</li>
<li>这是<code>cassandra 3.0</code>之后的。之前的可能不一样</li>
</ul>
</li>
<li>
<p>和想象地一样，当<code>Gossipy</code>发现<code>downed node</code>起来之后，<code>coordinator node</code>会将<code>hint</code>记录的数据写过去，并且删除掉<code>hint</code></p>
</li>
<li>
<blockquote>
<p>The coordinator also checks every ten minutes for hints corresponding to writes that timed out during an outage too brief for the failure detector to notice through gossip.</p>
</blockquote>
</li>
<li>
<p>这句有点难以理解，看了下一句有点明白。如果有的节点宕机时间很短，而<code>Gossdip</code>并没有发现，那么<code>coordinator</code>会返回一个<code>exception</code>，同时把<code>write fail</code>了，但是会记录一个<code>hint</code>。所以如果瞬间有很多短暂的<code>fail</code>，<code>coordinator node</code>会一下子压力过大，扔出<code>overloadexception</code></p>
</li>
</ul>
<blockquote>
<p>If a replica node is overloaded or unavailable, and the failure detector has not yet marked the node as down, then expect most or all writes to that node to fail after the timeout triggered by write_request_timeout_in_ms, (10 seconds by default). The coordinator returns a TimeOutException exception, and the write will fail but a hint will be stored.</p>
</blockquote>
<h4 id="hint-和-consistency-level"><a class="header-anchor" href="#hint-和-consistency-level"></a>Hint 和 consistency level</h4>
<ul>
<li>
<blockquote>
<p>当一致性等级设定为<code>ONE</code>，<code>QUORUM</code>，或者<code>ALL</code>的时候，提示的写并不参与到一致性级别的计数中。如果没有足够的节点满足写的一致性级别需要，会抛出<code>UnavailableException</code>而不是触发<code>Hinted Handoff</code>。（这是<code>Casssandra</code>和<code>Dynamo</code>复制模型不一样的地方之一）</p>
</blockquote>
</li>
<li>接上文，如果将<code>consistency level</code>设置成为<code>Any</code>，那么<code>hint</code>就算了。所以即使只是写了<code>hint</code>，写操作也会成功，但是这时候读数据是读不出来的。</li>
</ul>
<h3 id="repairing-data"><a class="header-anchor" href="#repairing-data"></a>Repairing Data</h3>
<ul>
<li>Read repair: The reconciliation or correction happens when a read finds an inconsistency.</li>
<li>When data is read, a read repair can resolve any data inconsistencies. When data isn’t read, you need to use either the hinted handoff or anti-entropy mechanism to resolve any data inconsistences.</li>
</ul>
<h4 id="read-repair"><a class="header-anchor" href="#read-repair"></a>Read Repair</h4>
<h4 id="anti-entropy"><a class="header-anchor" href="#anti-entropy"></a>anti-entropy</h4>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://wiki.apache.org/cassandra/HintedHandoff" target="_blank" rel="noopener">wiki上面的简介</a></li>
<li><a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsRepairNodesHintedHandoff.html" target="_blank" rel="noopener">官方</a></li>
<li><a href="http://www.cnblogs.com/sing1ee/archive/2012/07/09/2765056.html" target="_blank" rel="noopener">比较好的博客一篇</a>： 看起来很多就是官方文档的翻译</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/04/18/Cassandra%20Batch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/04/18/Cassandra%20Batch/" class="post-title-link" itemprop="url">Cassandra Batch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-18 10:17:44" itemprop="dateCreated datePublished" datetime="2019-04-18T10:17:44+08:00">2019-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 16:24:27" itemprop="dateModified" datetime="2021-02-22T16:24:27+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/04/18/Cassandra%20Batch/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra Batch" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/04/18/Cassandra%20Batch/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/04/18/Cassandra%20Batch/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cassandra-batch"><a class="header-anchor" href="#cassandra-batch"></a>Cassandra Batch</h2>
<p>最近工作比较忙活，一个月都没写blog喽。工作中碰到了一些与cassandra相关的同步异步，simpleStatement，batchStatement的东西。顺势多研究一下。<br>
研究发现，这玩意还挺复杂的啊。</p>
<h3 id="execute-与-executeasync"><a class="header-anchor" href="#execute-与-executeasync"></a>execute 与 executeAsync</h3>
<ul>
<li>
<p>cassandra driver在执行语句时候提供了<code>execute</code>和<code>executeAsync</code> 两个接口</p>
</li>
<li>
<p>对于<code>batch</code>来说，只能调用前者，这个好像不太对。</p>
</li>
<li>
<p>但是进入代码会看到，<code>execute</code>最后调用的也是<code>executeAsync</code></p>
<pre><code>  public ResultSet execute(Statement statement) {
         this.checkNotInEventLoop();
         return this.executeAsync(statement).getUninterruptibly();
  }
</code></pre>
</li>
<li>
<p>这个<code>executeAsync</code>接口是在<code>SessionManager</code>里面定义的</p>
</li>
<li>
<p>按照参考链接1里面所述的，从以上代码也可以看出来的<code>execute</code>在于是<code>block</code>的。就是不可打断的。必须得<code>cassandra</code>返回一些数据才能返回。所以它可以保证在<code>invalid request</code>的情况下报错，但是不能保证<code>request</code>就一定执行成功了。</p>
</li>
<li>
<p><code>executeAsync</code>就是非阻塞的，也不能保证这个<code>request</code>一定被执行或者在<code>invalid request</code>的情况下报错</p>
</li>
<li>
<p>参考链接1里面有这么一段话：看起来少量<code>batch</code>，并且是同样<code>partition key</code>的时候，会比较快。</p>
</li>
<li>
<p>我们在产品中的改进在有些场景下面确实性能变好了</p>
</li>
</ul>
<blockquote>
<p>To further improve throughput, you might want to consider using BatchStatement and submitting requests in batches. This is a good option if you keep your batches small (50-250 is a good number) and if your inserts in a batch all share the same partition key.</p>
</blockquote>
<ul>
<li>参考链接：
<ol>
<li><a href="https://stackoverflow.com/questions/34949292/how-cassandra-handle-blocking-execute-statement-in-datastax-java-driver" target="_blank" rel="noopener">How Cassandra handle blocking execute statement in datastax java driver<br>
</a></li>
</ol>
</li>
</ul>
<ol start="2">
<li><a href="http://zqhxuyuan.github.io/2015/11/10/2015-11-10-Cassandra-Client/" target="_blank" rel="noopener">Cassandra Client查询优化</a>: 这篇有点看不明白。但是瞅着还挺好的，先放在这里。</li>
</ol>
<h3 id="batchstatement"><a class="header-anchor" href="#batchstatement"></a>BatchStatement</h3>
<p>严格说来，<code>cassanda</code>里面的<code>batch</code>称为<code>LOGGED batch</code>，而不应该是<code>atomic batch</code>。<code>Cassanda</code>的策略始终是<code>Eventually Consistent</code>。而且由于<code>cassandra</code>里面加一个数据比删除一个数据要方便太多。所以<code>cassandra</code>会记一堆日志啥的，而不是回滚。</p>
<ul>
<li><code>cassandra</code>是基于<code>co-ordinator</code>来实现的。<code>batch</code>在<code>co-ordinator</code>开始处理之前就留会写到其他节点去</li>
<li>如果<code>batch</code>里面的某些失败了，那么是不会回滚的。而是会不断尝试。</li>
<li><code>LOGGER</code>的<code>batch</code>操作会比<code>unlogged</code>的多做很多事情</li>
</ul>
<h4 id="batchstatement-type"><a class="header-anchor" href="#batchstatement-type"></a>BatchStatement.Type</h4>
<p>这个是<code>BatchStatement class</code>的一个子类</p>
<ul>
<li><code>COUNTER</code>: A counter batch. Note that such batch is the only type that can contain counter operations and it can only contain these. 这个解释也太简单了。意思是说可以知道多少个成功了？</li>
<li><code>LOGGED</code>:
<ul>
<li>Cassandra will first write the batch to its distributed batch log to ensure the atomicity of the batch (atomicity meaning that if any statement in the batch succeeds, all will eventually succeed).这个解释也不太懂啊，到底怎么保证的。 ORZ</li>
<li>默认调用<code>new BatchStatement()</code>就会创一个LOGGED type的Batch-</li>
</ul>
</li>
<li><code>UNLOGGED</code>： A batch that doesn’t use Cassandra’s distributed batch log. Such batch are not guaranteed to be atomic.</li>
</ul>
<h4 id="logged-batch的过程"><a class="header-anchor" href="#logged-batch的过程"></a>LOGGED Batch的过程</h4>
<p><img src="http://3.bp.blogspot.com/-dv9zIC84QD4/VNoNE0YXn8I/AAAAAAAAAX0/b3wtV48fuB0/s1600/Screenshot%2B2015-02-10%2B13.51.56.png" alt=""></p>
<blockquote>
<p>图片来自参考链接2</p>
</blockquote>
<ul>
<li>所以从图片里面看出来，<code>cassandra</code>收到一个<code>batch</code>请求的时候：
<ul>
<li>由<code>co-ordinator</code>来处理，也就是种子节点</li>
<li>会先写<code>batch log</code>，通常写两个<code>node</code>？</li>
<li>然后再从种子节点写到各个分节点</li>
</ul>
</li>
<li>按照参考链接2里面的描述，<code>performance hit</code>，性能是有可能下降的。因为多做了很多事情，而且是从种子节点分发出去的。</li>
<li>结论就是：只有在为了保证一致性的情况下，才使用<code>batch</code>，而不是说改善性能</li>
</ul>
<h4 id="logged-batch-fail"><a class="header-anchor" href="#logged-batch-fail"></a>LOGGED Batch Fail</h4>
<ul>
<li>首先不会回滚</li>
<li><code>WriteTimeoutException with write type of BATCH_LOG.</code> 说明在写<code>batch log</code>时候挂了。需要手动再发一下。</li>
<li><code>WriteTimeoutException with the write type of BATCH</code>。 在真正写<code>request</code>的时候出错了。<code>cassandra</code>会不断重复，直至成功。</li>
<li>有时候会在<code>Cassandra</code>的日志里面看到以下内容。这是说<code>batch</code>的请求超限了。这个参数的默认值是5K，<code>batch_size_warn_threshold_in_kb</code></li>
</ul>
<pre><code>WARN  [SharedPool-Worker-2] 2018-05-16 08:33:48,585 BatchStatement.java:287 - Batch of prepared statements for [test, test1] is of size 6419, exceeding specified threshold of 5120 by 1299.
</code></pre>
<ul>
<li><a href="https://stackoverflow.com/questions/50385262/cassandra-batch-prepared-statement-size-warning" target="_blank" rel="noopener">batch size warning</a></li>
</ul>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ol>
<li><a href="https://stackoverflow.com/questions/22664129/atomic-batches-in-cassandra" target="_blank" rel="noopener">Atomic Batches in Cassandra</a></li>
<li><a href="http://christopher-batey.blogspot.com/2015/03/cassandra-anti-pattern-cassandra-logged.html" target="_blank" rel="noopener">Cassandra anti-pattern: Logged batches</a><br>
3.<a href="https://docs.datastax.com/en/archived/cql/3.3/cql/cql_using/useBatchBadExample.html" target="_blank" rel="noopener">batch的错误使用方式</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Java多线程数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-11 10:22:53" itemprop="dateCreated datePublished" datetime="2019-03-11T10:22:53+08:00">2019-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-18 11:12:59" itemprop="dateModified" datetime="2019-07-18T11:12:59+08:00">2019-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Java多线程数据类型" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇记录改成专门记录和多线程相关的数据类型</p>
<h3 id="executors"><a class="header-anchor" href="#executors"></a>Executors</h3>
<p>这个<code>Executors</code>没有继承或者实现任何其他类。就是说，他嘎嘣自己一个。实际上是一个工具类啊，更确切地说，像一个工厂类。主要功能是返回各种<code>ExecutorService</code>。<br>
其实就是<code>new</code>出各种<code>ThreadPoolExecutor</code>。如下：</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                      new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<h3 id="executorservice"><a class="header-anchor" href="#executorservice"></a>ExecutorService</h3>
<h4 id="概览"><a class="header-anchor" href="#概览"></a>概览</h4>
<pre><code>public interface ExecutorService extends Executor
</code></pre>
<ul>
<li>所以首先来说，这是一个接口</li>
<li>Executor接口很简单，只有一个execute方法。ExecutorService除了这一个方法，还增加了一些方法，增加的方法包括：<code>awaitTerminate</code>，<code>invokeAll</code>，<code>invokeAny</code>，<code>shutdown</code>，<code>shutdownNow</code>，<code>submit</code>等。</li>
<li><a href="https://www.cnblogs.com/Steven0805/p/6393443.html" target="_blank" rel="noopener">Java线程池ExecutorService</a></li>
</ul>
<h4 id="几种常用线程池的具体实现"><a class="header-anchor" href="#几种常用线程池的具体实现"></a>几种常用线程池的具体实现</h4>
<ul>
<li>然后有意思的来了：</li>
<li>Java通过Executors class提供了好几种线程池，这就是我们常用的几种了。</li>
<li><code>newFixedThreadPool</code>：就是说这个玩意，限定好了最大数目，核心数目，然后本质是一个<code>LinkedBlockingQueue</code>套了<code>runnable</code></li>
</ul>
<pre><code> public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
</code></pre>
<ul>
<li><code>newCachedThreadPool</code>：</li>
</ul>
<pre><code>   public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());    }
</code></pre>
<ul>
<li>还有<code>newScheduledThreadPool</code>和<code>newSingleThreadExecutor</code></li>
</ul>
<h4 id="一些要点"><a class="header-anchor" href="#一些要点"></a>一些要点</h4>
<ul>
<li><code>submit</code>与<code>execute</code>的区别：
<ul>
<li>submit接受runnable和callable  有返回值。</li>
<li>execute接受runnable 无返回值</li>
<li>submit方便Exception处理</li>
</ul>
</li>
<li>Runnable与Callable区别
<ul>
<li>runnable接口实现的没有返回值的并发编程。</li>
<li>callable实现的存在返回值的并发编程。使用Future获取返回值。</li>
</ul>
</li>
</ul>
<h3 id="threadpoolexecutor"><a class="header-anchor" href="#threadpoolexecutor"></a>ThreadPoolExecutor</h3>
<pre><code>public abstract class AbstractExecutorService implements ExecutorService
public class ThreadPoolExecutor extends AbstractExecutorService    
</code></pre>
<ul>
<li>从上面可以看出来，ThreadPoolExecutor也是一种Executor，继承自AbstractExecutorService，自然也实现了ExecutorService.</li>
<li><a href="https://www.cnblogs.com/zedosu/p/6665306.html" target="_blank" rel="noopener">ThreadPoolExecutor使用详解</a></li>
</ul>
<h4 id="threadpoolexecutor-shutdown"><a class="header-anchor" href="#threadpoolexecutor-shutdown"></a>ThreadPoolExecutor shutdown</h4>
<p>ThreadPoolExecutor 有三个shutdown方法： <code>shutdown</code>、<code>shutdownNow</code>、<code>awaitTermination</code></p>
<ul>
<li>
<p><code>shutdown</code>： 停止接收外部submit的任务；内部正在跑的任务和队列里等待的任务，会执行完。其实graceful shutdown的感觉啊</p>
</li>
<li>
<p><code>shutdownNow</code>： 停止接收外部提交的任务；忽略队列里等待的任务；尝试将正在跑的任务interrupt中断；返回未执行的任务列表。强制中断。线程会收到InterupptedException.</p>
<ul>
<li>需要注意的是这个方法仅仅是尝试中断线程，它通过的是调用interrupt方法，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。</li>
</ul>
</li>
<li>
<p><code>awaitTermination</code>：只是加了一个wait时间的限制</p>
<ul>
<li>很多博客的里面，这个函数会返回boolean的返回值。就是说<code>awaitTermination</code>一般和<code>shutdown</code>搭配使用，<code>awaitTermination</code>来监控线程有没有结束好。结束了返回<code>true</code>，没结束返回<code>false</code></li>
<li>这个函数还会抛出InterupptedException，但是看代码没太明白什么状况下会抛这个<code>exception</code>。但是是这个函数本身被interrupt了。</li>
<li>有一点不太明白，线程处于阻塞状态，处于阻塞状态时候，还会接收消息？只是不处理？</li>
<li>在实际工作中解决bug碰到了这组函数。事实上就是要三个一起用的。<code>awaitTermination</code>只会返回一个状态，并不会做任何的事情。所以在这个函数返回false的时候应该要调用<code>shutdownNow</code>方法来进一步中断线程</li>
</ul>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://blog.csdn.net/u012168222/article/details/52790400" target="_blank" rel="noopener">shutdown 方法</a></li>
<li><a href="https://blog.csdn.net/zaozi/article/details/38854561#commentBox" target="_blank" rel="noopener">ExecutorService的正确关闭方法</a>： 这篇文章比喻得很清楚，只是不知道正确与否</li>
</ul>
</li>
<li>
<ul>
<li><a href="https://blog.csdn.net/liwenxia626/article/details/80754886" target="_blank" rel="noopener">csdn的另一篇博客</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/03/04/TLS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/03/04/TLS/" class="post-title-link" itemprop="url">TLS - Algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-04 14:50:11" itemprop="dateCreated datePublished" datetime="2019-03-04T14:50:11+08:00">2019-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 15:53:15" itemprop="dateModified" datetime="2021-02-22T15:53:15+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index"><span itemprop="name">security</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/03/04/TLS/" class="post-meta-item leancloud_visitors" data-flag-title="TLS - Algorithm" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/03/04/TLS/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/03/04/TLS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://xz.aliyun.com/t/2526" target="_blank" rel="noopener">SSL/TLS协议详解(上)：密码套件，哈希，加密，密钥交换算法</a>
<ul>
<li>英文版: <a href="https://www.wst.space/ssl-part1-ciphersuite-hashing-encryption/" target="_blank" rel="noopener">SSL/TLS for dummies part 1 : Ciphersuite, Hashing,Encryption</a></li>
</ul>
</li>
<li><a href="https://xz.aliyun.com/t/2530" target="_blank" rel="noopener">SSL/TLS协议详解(中)——证书颁发机构</a></li>
<li><a href="https://xz.aliyun.com/t/2531" target="_blank" rel="noopener">SSL/TLS协议详解(下)——TLS握手协议</a></li>
<li>以上是一个系列，真的是详解，非常详尽。</li>
</ul>
<h2 id="算法"><a class="header-anchor" href="#算法"></a>算法</h2>
<ul>
<li>这边主要是参考了上面参考链接里面的第一篇，总的来说，应该了解一下这些</li>
</ul>
<h3 id="哈希算法"><a class="header-anchor" href="#哈希算法"></a>哈希算法</h3>
<ul>
<li>哈希算法生成的数据格式被称为散列，散列不是一个可逆的过程。<br>
而之前说过，<code>Base64</code>只是编码，顾名思义，编码只要知道规则，是可以解码的，没有安全性可言。所以编码算法和加密算法不是一回事来着。</li>
<li>所以讲密码哈希一下，是没法看出来原始密码是什么的。</li>
<li>这边可以扩展，进一步研究的是，如果进行攻击的话，称为字典攻击，就是猜密码，将常用的，可能出现的密码都哈希算法一下，去对比。</li>
<li>哈希算法有很多种，比如<code>MD5</code>是一种，虽然之前说就是提取摘要的。<code>SHA-512</code>是另一种。</li>
</ul>
<h3 id="加密算法"><a class="header-anchor" href="#加密算法"></a>加密算法</h3>
<ul>
<li><em>Encryption lies in between hashing and encoding</em> 加密可以任务是介于哈希和编码之间。它是可以被解密的，但是并不会像解码那么简单</li>
<li>加密算法可以分为对称加密和非对称加密两种</li>
</ul>
<h4 id="对称加密"><a class="header-anchor" href="#对称加密"></a>对称加密</h4>
<ul>
<li><code>DES</code>就是指对称加密</li>
<li>主要来自参考链接一， 对称加密的话，文章中用一个例子来讲解：“移位”。比如有数字&quot;123&quot;，对其进行加密，都增大3，成为“456”，就是对称加密了。</li>
<li>其中的数字3就是<code>Encryption key (symmetric key)</code>。对称加密的时候，知道<code>key</code>的话，就可以进行解密了。</li>
<li><em>Anyone who knows the encryption key and can apply the reverse of Caesar’s algorithm and retrieve the original Plaintext.</em> 凯撒算法就是上面这种意味式的加密算法。</li>
<li>有此可知，在<code>TLS</code>中使用简单的对称加密不是很安全的。毕竟知道<code>Encryption key</code>就可以进行解密了。<br>
对称加密一代代发展，现在也有比较复杂的算法，比如<code>Triple Data Encryption Algorithm</code>，后面可以再进一步研究。AES（高级加密标准）和3DES（三重数据加密算法）的复杂算法也是有的</li>
<li>从过程可以知道，<code>key</code>是非常关键的。但是由于是对称加密解密，双方必须都知道约定的值，那么第一步就是传递<code>key</code>，而这个时候是没法加密的。所以就出现了不对称加密。<em>So we need a secure mechanism to exchange the keys without an attacker actually seeing it. There comes the role of Asymmetric Key Encryption.</em></li>
<li>在<code>TLS</code>中，传输和接收数据的时候，可以使用对称加密算法。事实上，很可能大部分都是使用的对称加密。不对称加密涉及双密钥架构并且密钥长度通常很大，因此加密-解密开销非常高。与对称密钥加密相比，它需要更多的时间和<code>CPU</code>占有率。</li>
</ul>
<h4 id="不对称加密"><a class="header-anchor" href="#不对称加密"></a>不对称加密</h4>
<ul>
<li>1976年，Whitfield Diffie和Martin Hellman首次提出了非对称加密的概念，该算法被称为<code>Diffie-Hellman</code>密钥交换。然后在1978年，麻省理工学院的Ron Rivest，Adi Shamir和Leonard Adleman发表了<code>RSA</code>算法。</li>
<li>不对称加密的简单解释就是：用不同的<code>key</code>来进行加密和解密。</li>
<li>非对称加密也称为公钥基础结构，又称<code>PKI public key ixxx</code></li>
<li>不对称加密通常用于在刚开始传输对称加密的<code>key</code>的时候</li>
<li>公钥用来给对方使用，比如A想给B发消息，那么A需要使用B的公钥来加密自己的消息。<br>
所以公钥是可以与任何想与你通信的人共享的，一般来说，在公钥中会指定使用何种加密算法。 <em>如果密钥对是使用RSA算法生成的，那么它们应该在加密数据时使用相同的算法。</em></li>
<li>私钥用来解密收到的消息。比如A收到了一条消息，那么A应当使用自己的私钥来解密收到的消息</li>
<li>非对称加密算法除了<code>RSA</code>、<code>Diffie-Hellman密钥交换</code>、<code>ECDH（Elliptic Curve Diffie-Hellman）</code>、<code>SRP（安全远程密码）</code>以及由TLS 1.2支持密钥交换算法<code>PSK（Pre Shared Key）</code>。总之，也是有一大堆的</li>
</ul>
<h5 id="rsa算法细节"><a class="header-anchor" href="#rsa算法细节"></a>RSA算法细节</h5>
<ul>
<li>所以<code>RSA</code>算法有几个比较重要的组成，私钥，公钥，加密算法和解密算法</li>
<li>那么一个严肃的问题就是，不同的钥匙进行计算的消息，怎么能够解开呢？接下来就是数学课的时间了。
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/dbs1215/article/details/48953589" target="_blank" rel="noopener">带你彻底理解RSA算法原理</a></li>
<li><a href="https://www.zhihu.com/question/25038691" target="_blank" rel="noopener">RSA 算法的加密原理是什么,知乎问答</a></li>
</ul>
</li>
<li>互质数： 只有一个公因子为1的数。比如6和9，都有公因子为3，那么就不是互质数；而7和9只有公因子为1，就是互质数。</li>
<li>欧拉函数：<code>φ(n)</code>。 小于或等于n的正整数中与n互质的数的数目。</li>
<li>三个横线的奇怪等号是恒等于。</li>
<li>生成公钥：随机选取两个质数<code>p1、p2</code>，<code>n=p1*p2</code>，再随机选取一个整数<code>e</code>，<code>e</code>与<code>φ(n)</code>互质。公钥就是<code>(e, n)</code>。</li>
<li>根据欧拉函数定理，<code>φ(n) = (p1-1)*(p2-1)</code></li>
<li>费马定理：若p是素数，a与p互素，则<code>a^(p-1）≡1 （mod p）</code> 没看懂这个费马定理</li>
<li>加密算法：假设<code>m</code>为需要加密的信息，那么<code>(m^e) mod n</code>就加密好了，生成加密后的信息<code>c</code></li>
<li>解密算法： 解密算法其实和加密算法的公式是一模一样的，只是这里的<code>m</code>和<code>e</code>换成<code>c</code>和<code>d</code>，成为<code>(c^d) mod n</code>。相当于采用公式都是<code>(x^y) mod n</code>，所以其实使用的公式是一样的</li>
<li>那么这里的<code>(d, n)</code>就被成为私钥。那么如何得到<code>d</code>呢？烧脑的数学就来了。果然数学系才有前途啊 😂 实在是颇为烧脑啊。</li>
<li>各个参考链接中均有实际的例子，我这里就不再烧脑来看了</li>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/qq_38313548/article/details/85387466" target="_blank" rel="noopener">如何获得d</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>(c^d) mod n = ((m^e)mod n)^d mod n = (m^ed) mod n = m
(m^φ(n)) mod n≡1 又 1^k≡1, 所以(m^k*φ(n)) mod n≡1 ，所以(m^(k*φ(n)+1)) mod n≡m
结合以上两条，ed=k*φ(n)+1 , d=(k*φ(n)+1)/e
</code></pre>
<h5 id="dh和rsa的区别"><a class="header-anchor" href="#dh和rsa的区别"></a>DH和RSA的区别</h5>
<ul>
<li>有一本书，叫做“图解密码技术”，</li>
<li><code>RSA</code>利用最大公约数（互质）来求出公钥和私钥。<code>DH密钥协商</code>则是利用生成元来得到共享密钥。</li>
<li>在第一篇参考链接中有<code>DH</code>算法的详细数学过程，暂时略过，这些需要数学基础啊。</li>
</ul>
<h3 id="签名算法"><a class="header-anchor" href="#签名算法"></a>签名算法</h3>
<h4 id="eddsa"><a class="header-anchor" href="#eddsa"></a>EdDSA</h4>
<ul>
<li>工作中碰到的问题，<code>SSHD</code>一直在报<code>EdDSA</code>算法的<code>provider</code>没有: <code>EdDSA provider not supported</code></li>
<li><a href="https://stackoverflow.com/questions/65566138/apache-mina-sshd-ssh-client-always-prints-eddsa-provider-not-supported" target="_blank" rel="noopener">EdDSA provider not supported</a> 这个链接里面详尽描述了这个问题</li>
<li>几个解决方法，一个是像上述链接里面描述的，引入新的依赖包，另一个，是在客户端启动的时候，不要用<code>default</code>的算法库，而是自己配置可用的算法。</li>
<li><code>EdDSA</code>算法的细节没有深究，里面都是数学相关，什么使用了爱德华曲线。比<code>EcDSA</code>要先进</li>
<li><a href="https://www.cnblogs.com/chinareny2k/archive/2010/03/02/1676238.html" target="_blank" rel="noopener">JAVA 密码技术基础</a>里面提到了所谓的<code>provider</code>，其中的<code>BouncyCastle</code>是很常用的一个第三方库，而<code>EdDSA</code>算法就是其中实现的。</li>
<li>关于<code>BounctCastle</code>可看<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1305362418368545" target="_blank" rel="noopener">BounctCastle</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/27/K8s%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/27/K8s%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">K8s概念理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-27 14:44:21" itemprop="dateCreated datePublished" datetime="2019-02-27T14:44:21+08:00">2019-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-09 16:15:54" itemprop="dateModified" datetime="2020-11-09T16:15:54+08:00">2020-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/27/K8s%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="K8s概念理解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/27/K8s%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/27/K8s%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="k8s概念"><a class="header-anchor" href="#k8s概念"></a>K8s概念</h2>
<p>这篇是从K8s的常用命令分出来的，实在是概念比较多，跟常用命令杂在一起不合适了。</p>
<h3 id="namespace"><a class="header-anchor" href="#namespace"></a>namespace</h3>
<ul>
<li>
<p>当团队或项目中具有许多用户时，可以考虑使用Namespace来区分。</p>
</li>
<li>
<p>默认情况下，相同Namespace中的对象将具有相同的访问控制策略。</p>
</li>
<li>
<p>Kubernetes从两个初始的Namespace开始：</p>
<ul>
<li>
<p>default</p>
</li>
<li>
<p>kube-system 由Kubernetes系统创建的对象的Namespace</p>
</li>
<li>
<p>自己电脑上面装好的docker for desktop里面有以下的namespace</p>
<pre><code>$ kubectl get namespaces
NAME           STATUS    AGE
default        Active    15d
docker         Active    15d
kube-public    Active    15d
kube-system    Active    15d
</code></pre>
</li>
</ul>
</li>
<li>
<p>大多数<code>Kubernetes</code>资源（例如<code>pod</code>、<code>services</code>、<code>replication controllers</code>或其他）都在某些Namespace中，但Namespace资源本身并不在Namespace中。而低级别资源（如<code>Node</code>和<code>persistentVolumes</code>）不在任何Namespace中。</p>
</li>
<li>
<p><code>Events</code>是一个例外：它们可能有也可能没有Namespace，具体取决于<code>Events</code>的对象。</p>
</li>
<li>
<p>参考链接：<a href="http://docs.kubernetes.org.cn/242.html" target="_blank" rel="noopener">Kubernetes Namespaces</a></p>
</li>
</ul>
<h3 id="deployment"><a class="header-anchor" href="#deployment"></a>deployment</h3>
<ul>
<li>这几者的关系比较复杂。还需要进一步去看。目前先记录一下：<code>deployment</code>是实际的<code>deploy</code>，然后<code>pod</code>是根据<code>replica</code>里面的设定来起的。所以，如果将<code>deployment</code>删除掉，那么相应的<code>pod</code>和<code>replica set</code>都会没有</li>
</ul>
<h4 id="deployment-spec详解"><a class="header-anchor" href="#deployment-spec详解"></a>deployment spec详解</h4>
<p>网上基本搜索不到这方面的信息。应该是yaml文件里面的各个字段太过相似了。</p>
<ul>
<li><code>spec</code>详解：
<ul>
<li><code>metadata</code>：元数据，包含名字，标签和产品声明。元数据就是说基础信息，白描</li>
</ul>
</li>
</ul>
<h4 id="deployment参考链接"><a class="header-anchor" href="#deployment参考链接"></a>deployment参考链接</h4>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/03/metadata.html" target="_blank" rel="noopener">元数据参考链接</a></li>
</ul>
<h3 id="pod"><a class="header-anchor" href="#pod"></a>Pod</h3>
<p><code>pod</code>实在是<code>K8s</code>里面很重要的一个概念，也是很宽泛的一个概念。很多都可以是一个<code>pod</code>。</p>
<ul>
<li>All containers described as Pods.包括replication cotronller， service， deployment。<br>
<strong>不知道是不是所有的service类型都会被当做是pod，这一点有待确认</strong></li>
<li>A pod is a collection of containers that makes up a particular application, for example Redis.<br>
<strong>这句没有很明白啊，不是说pod是一个container嘛，又变成一堆container了</strong><br>
<strong>经过一段时间的学习，我想这里可能指的是initContainer之类的，所以一个pod里面可能是有很多container的</strong></li>
</ul>
<h3 id="services"><a class="header-anchor" href="#services"></a>Services</h3>
<p>service是K8s里面另一个非常重要的概念，而且实在是有点复杂。类型比较多。K8s中文文档里面的名词解释还是比较清楚的，并且给出了为什么需要service，service和pod有什么区别</p>
<p>挪到另一篇单独的博客里面了：<a href="https://sallyslove.github.io/hexo_blog/2019/10/11/K8s-Service/">K8s_Service</a></p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.kubernetes.org.cn/kubernetes-services" target="_blank" rel="noopener">名词解释 Services</a></li>
</ul>
</li>
</ul>
<h3 id="configmap"><a class="header-anchor" href="#configmap"></a>configmap</h3>
<h4 id="configmap的作用"><a class="header-anchor" href="#configmap的作用"></a>configmap的作用</h4>
<ul>
<li><em>In Kubernetes, a ConfigMap is simply a container for storing configuration data. Other things, like pods, can access the data in a ConfigMap.</em></li>
</ul>
<h4 id="创建configmap"><a class="header-anchor" href="#创建configmap"></a>创建configmap</h4>
<ul>
<li>
<p>可以通过命令行创建<code>kubectl create configmap</code>,当然也可以用<code>yaml</code>文件的方式创建。</p>
</li>
<li>
<p>以下的例子里面是直接给出了一个键值对，事实上，可以从文件<code>--from-file</code>或者目录来创建</p>
<pre><code>$ kubectl create configmap special-config --from-literal=special.how=very
configmap &quot;special-config&quot; created
$ kubectl get configmap special-config -o go-template='{{.data}}'
map[special.how:very]
</code></pre>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.jianshu.com/p/b1d516f02ecd" target="_blank" rel="noopener">k8s – ConfigMap</a></li>
</ul>
</li>
</ul>
<h4 id="pod调用configmap"><a class="header-anchor" href="#pod调用configmap"></a>POD调用configmap</h4>
<ul>
<li><code>configmap</code>里面是文件的话，可以进行加载目录，看下面卷的段落</li>
</ul>
<h3 id="volume"><a class="header-anchor" href="#volume"></a>Volume</h3>
<ul>
<li>这个单词的含义感觉真是奇怪，翻译成中文是卷，卷和磁盘有什么关系哦，我只想到了花卷。😆</li>
<li>总的来说，卷就是所有容器都可以访问的磁盘空间，并且在<code>pod</code>重启之后内容仍旧存在</li>
<li>参考<a href="https://blog.51cto.com/3842834/2320539" target="_blank" rel="noopener">两种常见类型的Volume深度实践</a></li>
</ul>
<h4 id="emptydir"><a class="header-anchor" href="#emptydir"></a>emptyDir</h4>
<ul>
<li>简单的在<code>pod</code>的里面进行定义，不刻意指定类型，就是这个类型</li>
<li>完全就是一个空目录</li>
<li>默认为空（如果该目录原来有文件也会被重置为空）</li>
</ul>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: ...
    name: ...
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir: {}
</code></pre>
<h4 id="configmap方式"><a class="header-anchor" href="#configmap方式"></a>configMap方式</h4>
<ul>
<li>
<p><code>configMap</code>也可以用来加载卷卷，加载的时候还可以指定权限。实例如下：</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: configmap-pod
spec:
  containers:
    - name: ...
      image: ...
      volumeMounts:
        - name: config-vol
          mountPath: /etc/config
  volumes:
    - name: config-vol
      configMap:
        name: log-config
        defaultMode: 420
</code></pre>
</li>
<li>
<p>默认的权限应该是<code>420</code>，应该是<code>read only</code>，在工作中是加载了一个<code>SHELL脚本</code>，所以将权限修改为<code>0755</code>，然后就可以在代码里面调用了。 可参考<a href="https://cloud.tencent.com/developer/ask/230096" target="_blank" rel="noopener">k8s configMap 挂载目录 权限 420</a></p>
</li>
</ul>
<h3 id="secrets"><a class="header-anchor" href="#secrets"></a>secrets</h3>
<h3 id="persistentvolumnclumns"><a class="header-anchor" href="#persistentvolumnclumns"></a>PersistentVolumnClumns</h3>
<ul>
<li><code>PVC</code>在定义的时候有个<code>storageclass</code>。这个<code>storageclass</code>是定义在<code>kube-system</code>的<code>namespace</code>里面的</li>
<li>在安装时候，<code>share C</code>盘遇到了问题，用<code>docker for desktop</code>的默认的<code>storageclass</code>：<code>hostpath</code>来创<code>PVC</code>，就起不来了。于是在大神的教导下另创了一个<code>StorageClass</code>，将其映射到<code>docker machine</code>的虚机里面。解决了这个问题。</li>
<li>在尝试解决这个C盘没法share的问题时候参考了很多资料。工作电脑由于系统关系，没有办法创建<code>administrator group</code>的<code>user</code>，所以绕不过去。</li>
<li>参考的链接有：
<ul>
<li><a href="https://dotblogs.com.tw/swater111/2017/01/26/101009" target="_blank" rel="noopener">share C盘总结</a>：这篇资料还是不错的，里面汇总了可能遇到的好几个问题。</li>
<li><a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank" rel="noopener">share C盘家里咋整</a></li>
<li><a href="https://tomssl.com/2018/01/11/sharing-your-c-drive-with-docker-for-windows-when-using-azure-active-directory-azuread-aad/" target="_blank" rel="noopener">local user方法</a></li>
</ul>
</li>
</ul>
<h3 id="replication-controller"><a class="header-anchor" href="#replication-controller"></a>replication controller</h3>
<ul>
<li>The replication controller defines how many instances should be running, the Docker Image to use, and a name to identify the service.<br>
<strong>决定多少个instance可以理解，不同的instance可以使用不同的image吗</strong></li>
</ul>
<h3 id="ingress"><a class="header-anchor" href="#ingress"></a>Ingress</h3>
<p><code>Ingress</code>的内容挪到新的一篇博客里面去了：<a href="https://sallyslove.github.io/hexo_blog/2020/02/11/K8s-Ingress/">K8s-Ingress</a></p>
<h3 id="daemonset"><a class="header-anchor" href="#daemonset"></a>DaemonSet</h3>
<ul>
<li>一个<code>DaemonSet</code>对象能确保其创建的<code>Pod</code>在集群中的每一台（或指定）<code>Node</code>上都运行一个副本。</li>
<li>在<code>Kubernetes 1.8</code>之后，必须指定<code>.spec.selector</code>来确定这个<code>DaemonSet</code>对象管理的<code>Pod</code>，通常与<code>.spec.template.metadata.labels</code>中定义的<code>Pod</code>的<code>label</code>一致。</li>
<li>也可以通过指定参数要求<code>DaemonSet</code>将<code>POD</code>建在指定的<code>Node</code>上面，细节看参考链接里面</li>
</ul>
<h4 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h4>
<ul>
<li><a href="https://www.jianshu.com/p/79981db6d4e6" target="_blank" rel="noopener">K8s – DaemonSet</a></li>
</ul>
<h3 id="custom-resource-definition"><a class="header-anchor" href="#custom-resource-definition"></a>Custom Resource Definition</h3>
<h4 id="custom-resource"><a class="header-anchor" href="#custom-resource"></a>Custom Resource</h4>
<ul>
<li>官方文档解释有点难以理解，<em>A resource is an endpoint in the Kubernetes API that stores a collection of API objects of a certain kind. For example, the built-in pods resource contains a collection of Pod objects.</em> 一个资源就是某种类型的物体的集合的统称。比如<code>pod resource</code>就是自带的资源。</li>
<li>所以就是说自己定义的类似<code>pod</code>，<code>service</code>之类的资源。</li>
</ul>
<h4 id="crd"><a class="header-anchor" href="#crd"></a>CRD</h4>
<ul>
<li>
<p>部署一个<code>CRD</code>到集群中，<code>kube-apiserver</code>会帮助你安装好路由和提供自定义资源的一般服务端实现。</p>
</li>
<li>
<p>例子：</p>
<pre><code>{
&quot;apiVersion&quot;: &quot;apiextensions.k8s.io/v1beta1&quot;,
&quot;kind&quot;: &quot;CustomResourceDefinition&quot;,
...
&quot;spec&quot;: {
  # group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;
  &quot;group&quot;: &quot;stable.netease&quot;,
    ...
      &quot;kind&quot;: &quot;Task&quot;,
      # shortNames allow shorter string to match your resource on the CLI
      &quot;shortNames&quot;: [
          &quot;task&quot;
      ]
  }
}
</code></pre>
</li>
</ul>
<h4 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h4>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-resources" target="_blank" rel="noopener">官方文档Custom Resource</a></li>
<li><a href="https://sq.163yun.com/blog/article/193062240727805952" target="_blank" rel="noopener">CRD 和 CR定义的例子</a></li>
<li><a href="https://k2r2bai.com/2019/10/04/ironman2020/day19/" target="_blank" rel="noopener">K8s的架构，CRD所在位置</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/26/Helm%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/26/Helm%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Helm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 15:50:36" itemprop="dateCreated datePublished" datetime="2019-02-26T15:50:36+08:00">2019-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-22 10:50:45" itemprop="dateModified" datetime="2020-01-22T10:50:45+08:00">2020-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/26/Helm%E5%85%A5%E9%97%A8/" class="post-meta-item leancloud_visitors" data-flag-title="Helm" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/26/Helm%E5%85%A5%E9%97%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/26/Helm%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="helm"><a class="header-anchor" href="#helm"></a>Helm</h2>
<p><code>Helm</code>入门篇。感觉有点类似<code>maven</code>，总归有这样一个管理工具。</p>
<p>写了一阵之后再看看，会发现有些看不明白的地方。果然，我写博客的风格和上学年代记笔记的风格一样，喜欢简略而不够详尽啊。这是说好多年没有变化和进步嘛 😂</p>
<h3 id="helm版本"><a class="header-anchor" href="#helm版本"></a>Helm版本</h3>
<ul>
<li>在工作中发现，<code>Helm</code>发展很快。但是也从侧面说明现在问题很多。</li>
<li>我们自己产品里面还是<code>1.x</code>的版本，实际已经发展到<code>3.x</code>了。</li>
<li>而从文档来看，<code>Helm</code>从<code>1.x</code>到<code>3.x</code>变化还是挺大的。甚至<code>Tiller</code>都被移除了!</li>
<li>目前的一个问题是，不同的版本支持的功能有一定差异，目前发现的有：<br>
1、有的<code>yaml</code>文件在比较高的<code>Helm</code>版本里面反而校验不过。应该是校验的规则加强了<br>
2、<code>--set-file</code>在<code>2.10.0</code>之前并不支持</li>
</ul>
<h3 id="helm是什么"><a class="header-anchor" href="#helm是什么"></a>Helm是什么</h3>
<ul>
<li><code>Helm</code>是在Kubernetes中安装部署容器的一个工具。</li>
<li><em>Helm is a tool for managing Kubernetes charts.</em></li>
<li><code>Helm</code>由<code>Helm</code>客户端、<code>Tiller</code>服务器端和<code>Chart</code>仓库所组成
<ul>
<li><code>Helm</code>客户端： 客户端交互</li>
<li><code>Tiller</code>服务器端： 装在k8s的cluster里面，管理<code>chart</code></li>
<li><code>Chart</code>仓库：创建<code>Kubernetes</code>应用实例的信息集合
<ul>
<li><code>Chart</code>由两个部分组成，第一个部分是A description of the package (Chart.yaml)</li>
<li>One or more templates, which contain Kubernetes manifest files。这个templates的话，应该也是yaml文件吧。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常用的helm命令"><a class="header-anchor" href="#常用的helm命令"></a>常用的helm命令</h3>
<ul>
<li><code>helm status &lt;namespace&gt;</code> 查看<code>Helm</code>的状态</li>
<li><code>helm install</code>: 实际将<code>helm</code>里面的内容安装到当前的<code>k8s</code>上面。比如我创了一个<code>configMap.yaml</code>的<code>templete</code>，那么就会安装上去。
<ul>
<li>如果只是想看看<code>template</code>的<code>rending</code>，那么使用命令<code>helm install ./mychart --debug --dry-run</code></li>
<li>如果想传值进去，可以使用<code>-f</code> 命令，比如<code>helm install -f myvals.yaml ./mychart</code>。这样传的值，可以用<code>.Value</code>来访问</li>
<li>单独传值是<code>--set foo=bar</code>，<code>--set</code>比文件的级别高，可以覆盖文件里面的值</li>
<li>以下命令里面将<code>livenessProbe.httpGet</code>删除掉了。但是参考上一章的<code>Helm</code>版本的描述，这个功能也是在较高的版本里面才实现。</li>
</ul>
</li>
</ul>
<pre><code>helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null

$ helm install ./mychart
  NAME:   guiding-ocelot
  LAST DEPLOYED: Mon Aug 19 17:23:00 2019
  NAMESPACE: gear-1
  STATUS: DEPLOYED

  RESOURCES:
      ==&gt; v1/ConfigMap
      NAME               DATA  AGE
      mychart-configmap  1     0s
</code></pre>
<ul>
<li>
<p><code>helm get manifest &lt;release name&gt;</code>: 比如上面的这个<code>guiding-ocelot</code></p>
<pre><code> $ helm get manifest guiding-ocelot

 ---
  # Source: myChart/templates/configmap.yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mychart-configmap
  data:
    myvalue: &quot;Hello World&quot;
</code></pre>
</li>
<li>
<p><code>helm init</code>:安装tiller服务器端</p>
<ul>
<li>在工作中碰到一个问题，在做<code>helm init</code>的时候没有带上<code>--client-only</code>选项，结果将服务器端的<code>Tiller</code>给更新了。</li>
<li>话说我在博客上面这样写了啊。其实客户端也是更新的</li>
</ul>
</li>
<li>
<p><code>helm delete --purge &lt;release name&gt;</code></p>
</li>
<li>
<p><code>helm repo add &lt;repo name&gt; &lt;repo address&gt;</code></p>
</li>
<li>
<p><code>helm create &lt;chart name&gt;</code>: 生成一个目录</p>
<pre><code>$ find myChart/
  myChart/
  myChart/.helmignore
  myChart/Chart.yaml
  myChart/charts
  myChart/templates
  myChart/templates/deployment.yaml
  myChart/templates/ingress.yaml
  myChart/templates/NOTES.txt
  myChart/templates/service.yaml
  myChart/templates/tests
  myChart/templates/tests/test-connection.yaml
  myChart/templates/_helpers.tpl
  myChart/values.yaml
</code></pre>
</li>
</ul>
<h3 id="helm-chart"><a class="header-anchor" href="#helm-chart"></a>Helm Chart</h3>
<h4 id="helm-chart-dependency-management"><a class="header-anchor" href="#helm-chart-dependency-management"></a>Helm Chart Dependency Management</h4>
<ul>
<li><code>3.x</code>的时候，<code>Chart</code>依赖关键由<code>requirements.yaml</code>和<code>requirements.lock</code>挪到了<code>chart.yaml</code>和<code>chart.lock</code>里面去了。但是还是会兼容<code>1.x</code>的<code>requirements.yaml</code>和<code>requirements.lock</code></li>
<li>不论<code>Helm2</code>还是<code>Helm3</code>都可以使用<code>tag</code>或者<code>condition</code>来劲依赖的控制管理</li>
</ul>
<pre><code>condition: somechart.enabled
tags:
  - webaccelerator
</code></pre>
<ul>
<li>不论是<code>tag</code>还是<code>condition</code>，都需要在<code>values.yaml</code>里面定义。<code>tag</code>必须是<code>global</code>下面的一层。自己为顶层的意思。</li>
<li>区别在于，<code>tag</code>可以用于很多<code>subchart</code>，如果设为<code>true</code>，那么被这个标签标示的<code>subchart</code>都会被装上。而<code>condition</code>应该是只有第一个会有效。但是这点需要验证一下。<em>Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.</em></li>
<li>在我们产品里面的<code>Helm1.x</code>里面，这个功能有一个致命的问题，就是当<code>Helm Upgrade</code>之后就会失效。
<ul>
<li>第一次<code>helm upgrade</code>时候将<code>somechart.enabled</code>改为了<code>true</code>，也顺利地将<code>subchart</code>加到了同一个release里面。</li>
<li>使用<code>helm upgrade</code>修改其他参数，在第一步中被安装上的<code>subchart</code>又丢了。即使这个时候<code>somechart.enabled</code>参数在<code>helm get values</code>里面仍旧维持着<code>true</code></li>
<li>在网上也看到一些类似的问题：
<ul>
<li><a href="https://github.com/helm/helm/issues/3796" target="_blank" rel="noopener">condition problem</a></li>
<li><a href="https://github.com/helm/helm/issues/6313" target="_blank" rel="noopener">helm upgrade issue</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="helm-template"><a class="header-anchor" href="#helm-template"></a>Helm Template</h3>
<ul>
<li>参考以上，默认生成一套chart的时候会生成template目录。
<ul>
<li><em>NOTES.txt: The “help text” for your chart. This will be displayed to your users when they run helm install.</em></li>
<li><em>deployment.yaml: A basic manifest for creating a Kubernetes deployment</em></li>
<li><em>service.yaml: A basic manifest for creating a service endpoint for your deployment</em></li>
<li>_ <em>helpers.tpl: A place to put template helpers that you can re-use throughout the chart</em></li>
</ul>
</li>
</ul>
<h4 id="template-values"><a class="header-anchor" href="#template-values"></a>Template Values</h4>
<ul>
<li>
<p>E.g. <code>name：</code>，下面这个例子里面用<code>release name</code> 来做前缀。话说这个<code>release name</code>在哪里定义的，我没找到。</p>
<ul>
<li>
<p><em>So we could read <code>.Release.Name</code> as “start at the top namespace, find the <code>Release</code> object, then look inside of it for an object called <code>Name</code>”.</em></p>
</li>
<li>
<p><code>.Release</code>表示<code>Release</code>是顶级的object</p>
<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p>顶级的自带的object包括： <code>Release</code>,<code>Value</code>,<code>Chart</code>,<code>Template</code>, <code>Capabilities</code>还有<code>File</code>。后两个还不是很理解</p>
<ul>
<li>
<p><code>Release</code>里面包含很多变量，有<code>Release.Time</code>,<code>Release.Namespace</code>, <code>Release.Revision</code>,详情可以看官方文档</p>
</li>
<li>
<p><code>Values</code>里面的其实是从<code>values.yaml</code>里面来的</p>
</li>
<li>
<p><code>Template</code>: 包含当前正在执行的<code>template</code>的信息</p>
</li>
<li>
<p><code>Chart</code> 里面的就是<code>chart.yaml</code>来的。比如</p>
<pre><code>{{.Chart.Name}}-{{.Chart.Version}} 
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="template-functions"><a class="header-anchor" href="#template-functions"></a>Template Functions</h4>
<ul>
<li>
<p><em>Helm has over 60 available functions.</em> 其中一些是调用<code>GO</code>语言里面<code>tamplate</code>定义的函数。在<a href="https://godoc.org/text/template" target="_blank" rel="noopener">Go Template Function</a>可以查询到</p>
</li>
<li>
<p>其实<code>Helm Template</code>并不是Helm自身做出来的，其实是从Go这些来的。就是个拿来再集成一下。并不是Helm自己的。</p>
</li>
<li>
<p><code>Helm functions</code>支持管道<code>pipeline</code>。这里的<code>pipeline</code>和<code>Unix</code>里面的同样含义。如下面的例子里面的：</p>
<pre><code>food: {{ .Values.favorite.food | upper | quote }}
drink: {{ .Values.favorite.drink | repeat 5 | quote }}
</code></pre>
</li>
</ul>
<h5 id="常用函数"><a class="header-anchor" href="#常用函数"></a>常用函数</h5>
<ul>
<li>
<p><code>default</code>：用来指定默认值</p>
<pre><code>  drink: {{ .Values.favorite.drink | default "tea" | quote }}
</code></pre>
</li>
<li>
<p><code>toyaml</code>: 转成yaml格式 <strong><em>其实不明白啥叫做Yaml格式</em></strong></p>
</li>
</ul>
<h5 id="函数控制和操作运算符"><a class="header-anchor" href="#函数控制和操作运算符"></a>函数控制和操作运算符</h5>
<ul>
<li><code>Helm Template</code>的函数是可以引入逻辑控制的</li>
<li>运算符有：
<ul>
<li><code>if/else</code> for creating conditional blocks： <code>if</code>判断有点不一样的是空的字符串或者空的集合也会被认为是<code>false</code>，还有数字0</li>
<li><code>with</code> to specify a scope</li>
<li><code>range</code> which provides a “for each”-style loop</li>
</ul>
</li>
</ul>
<h6 id="function-if-else"><a class="header-anchor" href="#function-if-else"></a>Function if/else</h6>
<ul>
<li>
<p>逻辑稍微有点难理解。就是<code>if</code>语句里面的内容是判断条件成立的时候包含的。然后关系运算符在前，这里是<code>or</code>运算符</p>
<pre><code>  {{/* include the body of this if statement when the variable .Values.anUnsetVariable is set or .values.aSetVariable is not set */}}
  {{ if or .Values.anUnsetVariable (not    .Values.aSetVariable) }}
   {{ ... }}
  {{ end }}
</code></pre>
</li>
</ul>
<h6 id="function-range"><a class="header-anchor" href="#function-range"></a>Function Range</h6>
<ul>
<li>
<p><code>range</code>相当于是<code>foreach</code>,比如以下是一个<code>slice</code>，其实就是列表。</p>
<pre><code>pizzaToppings:
 - mushrooms
 - cheese
 - peppers
 - onions
</code></pre>
<p>我们可以这样操作：</p>
<pre><code> toppings: |-
  {{- range .Values.pizzaToppings }}
  - {{ . | title | quote }}
  {{- end }}
</code></pre>
<ul>
<li>以上<code>range</code>函数遍历<code>pizzaToppings</code>里面的每个数值， <code>.</code>代表其中每个数值，传递给<code>title</code>和<code>quote</code>函数。</li>
<li><code>|-</code>代表以下内容是一个长字符串。因为<code>Configmap</code>只支持键值对。</li>
</ul>
</li>
<li>
<p><code>range</code>也可以和<code>list</code>合并起来用。如下：</p>
<pre><code> sizes: |-
 {{- range list "small" "medium" "large" }}
  - {{ . }}
 {{- end }}
</code></pre>
<ul>
<li>引号里面的组成一个字符串，然后再遍历字符串</li>
</ul>
</li>
<li>
<p><code>range</code>也可以和其他集合函数联合使用，比如<code>dict</code>和<code>map</code></p>
</li>
</ul>
<h6 id="function-with"><a class="header-anchor" href="#function-with"></a>Function with</h6>
<ul>
<li>
<p><code>.</code>指的是当前作用域，比如<code>.Values</code>，就是在当前作用域的<code>Value</code>里面</p>
</li>
<li>
<p>使用<code>with</code>函数可以改变作用域，用法和<code>if</code>类似。如下：</p>
<pre><code>{{ with PIPELINE }}
# restricted scope
{{ end }}
</code></pre>
</li>
</ul>
<h5 id="空格和空行"><a class="header-anchor" href="#空格和空行"></a>空格和空行</h5>
<ul>
<li>
<p>这就是为啥每行都两个大括号加小横线的缘故，瞅着一堆小横线实在无语啊。这个两个大括号加小横线markdown还打不出来，OMG 😕</p>
<ul>
<li>
<p>以下的语句会产生一个<code>Json</code>字段<code>mug：true</code>并且没有空行</p>
<pre><code>{{ if and .Values.favorite.drink (eq .Values.favorite.drink "coffee") }}mug: true{{ end }}
</code></pre>
</li>
<li>
<p>但是如果是以下语句就会产生在这个字段之前生成一个空行。估计<code>helm</code>就是简单的将<code>if</code>语句的一行给用空格替代了</p>
<pre><code>{{if eq .Values.favorite.drink "coffee"}}
 mug: true
{{end}}
</code></pre>
</li>
<li>
<p>所以上面的语句其实较为清晰，却必须用以下样式替代，这样<code>Helm</code>就知道将这边的空格都删除掉</p>
<pre><code>{{- if eq .Values.favorite.drink "coffee"}}
 mug: true
{{- end}}
</code></pre>
</li>
<li>
<p>For the details on whitespace control in templates,see the Official <a href="https://godoc.org/text/template" target="_blank" rel="noopener">Go template documentation</a></p>
</li>
</ul>
</li>
<li>
<p>也可以更为精确得控制空格，如下。这种用法在代码里也看到很多。</p>
<pre><code>{{indent 2 "mug:true"}}
</code></pre>
</li>
<li>
<p>还可以用<code>*</code>符号，<em>Just for the sake of making this point clear, let’s adjust the above, and substitute an <code>*</code> for each whitespace that will be deleted following this rule. an <code>*</code> at the end of the line indicates a newline character that would be removed</em> 没看的太明白。这个<code>*</code>是干嘛用的。</p>
<pre><code>**{{- if eq .Values.favorite.drink "coffee"}}
  mug: true*
**{{- end}}
</code></pre>
</li>
</ul>
<h4 id="变量"><a class="header-anchor" href="#变量"></a>变量</h4>
<ul>
<li>
<p>变量是用<code>:=</code>来定义的。</p>
</li>
<li>
<p>如下。原本在使用了<code>with</code>之后作用域已经改变了，找不到<code>Release</code>了，但是使用了变量，就又可以访问了。</p>
<pre><code>data:
myvalue: &quot;Hello World&quot;
{{- $relname := .Release.Name -}}
{{- with .Values.favorite }}
drink: {{ .drink | default "tea" | quote }}
food: {{ .food | upper | quote }}
release: {{ $relname }}
{{- end }}
</code></pre>
</li>
<li>
<p>可以和<code>range</code>结合起来用。</p>
<ul>
<li>
<p>遍历一个列表。<code>index</code>变量是下标，从<code>0</code>开始</p>
<pre><code>toppings: |-
  {{- range $index, $topping := .Values.pizzaToppings }}
    {{ $index }}: {{ $topping }}
  {{- end }}
</code></pre>
</li>
<li>
<p>键值对。注意<code>Values.favorite</code>是键值对的集合。所以第一次是一对，第二次是第二对</p>
<pre><code>{{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
{{- end}}
</code></pre>
</li>
</ul>
</li>
<li>
<p>变量是有作用域的。顶层声明的就是整个<code>template</code>可用，<code>range</code>里面声明的，就是<code>range</code>里面可用。比如上面这个例子，出了<code>end</code>就没用了。</p>
</li>
<li>
<p><strong>有一个特殊的变量 <code>$</code>，代表根作用域！</strong></p>
</li>
</ul>
<h4 id="已命名的template"><a class="header-anchor" href="#已命名的template"></a>已命名的Template</h4>
<p>就是介绍一下如何引用啊，命名之类。需要注意的是名字是全局的，不管这个<code>template</code>是不是包在其他的<code>template</code>里面。<br>
__需要的一点是，名字中有下划线的<code>template</code>是不会被部署到<code>kubernate</code>上面的。但是可以被其他<code>template</code>引用</p>
<h5 id="define"><a class="header-anchor" href="#define"></a>define</h5>
<ul>
<li>
<p>使用<code>define</code>可以在一个<code>template</code>内部创建一个新的<code>template</code>。语法如下：</p>
<pre><code>{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
</code></pre>
</li>
<li></li>
</ul>
<h5 id="template和include"><a class="header-anchor" href="#template和include"></a>template和include</h5>
<ul>
<li>
<p><code>template</code>感觉和<code>include</code>有点相似。是调用用<code>define</code>定义的<code>template</code>的。如下：</p>
<pre><code>metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
</code></pre>
</li>
<li>
<p>通常这类<code>template</code>会被放在<code>_helpers.tpl</code>文件里面。我的感觉是，这类<code>template</code>很像<code>util</code>函数，然后放在一个集中的文件里面。一般会在前面加一个注释，如下的格式：</p>
<pre><code>{{/* ... */}}
</code></pre>
</li>
<li>
<p>但是还有一个问题，如上面例子的调用，并没有给任何的作用域，而<code>template</code>的默认作用域为空。如下的<code>template</code>里面的<code>.Chart</code>是无法生效的。所以调用时候应该用以下形式。这样传入一个作用域就可以了。</p>
<pre><code>{{/* Generate basic labels */}}
  {{- define "mychart.labels" }}
    labels:
      generator: helm
      date: {{ now | htmlDate }}
      chart: {{ .Chart.Name }}
      version: {{ .Chart.Version }}
  {{- end }}
  

{{- template "mychart.labels" .}}
</code></pre>
</li>
<li>
<p>还有一个问题，<code>template</code>有点类似<code>inline</code>，就是简单的将内容展开，并不考虑缩进的问题。为此，引入了<code>include</code>， <code>include</code>可以用<code>pipeline</code>来指定缩进。推荐使用<code>include</code>来替代<code>template</code></p>
<pre><code>{{- include "mychart.app" . | nindent 2 }}
</code></pre>
</li>
</ul>
<h4 id="引用文件"><a class="header-anchor" href="#引用文件"></a>引用文件</h4>
<ul>
<li>
<p><code>.File</code>可以将文件包含进来。需要注意的有，<code>template</code>目录下面的文件没法被包含。如下例子。<code>.File.Get</code>就是读取文件的内容的函数</p>
<pre><code> {{- $files := .Files }}
 {{- range list "config1.toml" "config2.toml" "config3.toml" }}
  {{ . }}: |-
    {{ $files.Get . }}
 {{- end }}
</code></pre>
</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li><a href="https://www.cnblogs.com/Erik_Xu/p/8893725.html" target="_blank" rel="noopener">Helm介绍</a></li>
<li><a href="https://github.com/helm/helm" target="_blank" rel="noopener">Helm GitHub页面</a></li>
<li><a href="https://helm.sh/docs/using_helm/#quickstart-guide" target="_blank" rel="noopener">Helm使用文档</a></li>
<li><a href="https://helm.sh/docs/chart_template_guide/" target="_blank" rel="noopener">Helm官方文档</a></li>
<li><a href="https://v2.helm.sh/docs/charts/#managing-dependencies-with-requirements-yaml" target="_blank" rel="noopener">Helm2官方文档</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/26/Liveness-Readiness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/26/Liveness-Readiness/" class="post-title-link" itemprop="url">Liveness & Readiness</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 14:29:11" itemprop="dateCreated datePublished" datetime="2019-02-26T14:29:11+08:00">2019-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-16 10:09:17" itemprop="dateModified" datetime="2019-08-16T10:09:17+08:00">2019-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/26/Liveness-Readiness/" class="post-meta-item leancloud_visitors" data-flag-title="Liveness & Readiness" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/26/Liveness-Readiness/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/26/Liveness-Readiness/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="liveness-readiness"><a class="header-anchor" href="#liveness-readiness"></a>Liveness &amp; Readiness</h2>
<h3 id="readiness"><a class="header-anchor" href="#readiness"></a>Readiness</h3>
<ul>
<li>Readiness Probes checks if an application is ready to start processing traffic.</li>
<li>This probe solves the problem of the container having started, but the process still warming up and configuring itself meaning it’s not ready to receive traffic.</li>
<li>The configuration is as following:<br>
readinessProbe:<br>
httpGet:<br>
path: /<br>
port: 80<br>
initialDelaySeconds: 1<br>
timeoutSeconds: 1</li>
</ul>
<h3 id="liveness"><a class="header-anchor" href="#liveness"></a>Liveness</h3>
<ul>
<li>Liveness Probes ensure that the application is healthy and capable of processing requests.</li>
<li>The configuration is as following:<br>
livenessProbe:<br>
httpGet:<br>
path: /<br>
port: 80<br>
initialDelaySeconds: 1<br>
timeoutSeconds: 1</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo_blog/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/hexo_blog/">1</a><a class="page-number" href="/hexo_blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/hexo_blog/page/4/">4</a><a class="page-number" href="/hexo_blog/page/5/">5</a><a class="extend next" rel="next" href="/hexo_blog/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lynn Shen</p>
  <div class="site-description" itemprop="description">35岁开始的博客，有点晚哦</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo_blog/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo_blog/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ffyWzhHueqJEC5UEfPUhAWzF-MdYXbMMI","app_key":"vS7xTvT1vD1DxluERkmlkvme","server_url":"https://sallyslove.github.io/hexo_blog","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/hexo_blog/lib/anime.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo_blog/js/utils.js"></script>

<script src="/hexo_blog/js/motion.js"></script>


<script src="/hexo_blog/js/schemes/muse.js"></script>


<script src="/hexo_blog/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'ffyWzhHueqJEC5UEfPUhAWzF-MdYXbMMI',
      appKey     : 'vS7xTvT1vD1DxluERkmlkvme',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
