<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo_blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo_blog/css/main.css">


<link rel="stylesheet" href="/hexo_blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sallyslove.github.io","root":"/hexo_blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/page/2/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lynn Shen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sallyslove.github.io/hexo_blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>跬步</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo_blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">跬步</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不积跬步，无以至千里</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo_blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo_blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/11/08/TLS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/11/08/TLS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">TLS - Operation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-08 14:47:48" itemprop="dateCreated datePublished" datetime="2019-11-08T14:47:48+08:00">2019-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-08 16:52:07" itemprop="dateModified" datetime="2020-09-08T16:52:07+08:00">2020-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index"><span itemprop="name">security</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/11/08/TLS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="TLS - Operation" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="tls和oauth"><a class="header-anchor" href="#tls和oauth"></a>TLS和OAuth</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/8378664/does-an-oauth-2-client-really-need-tls" target="_blank" rel="noopener">does-an-oauth-2-client-really-need-tls</a>： 我自己有点搞不清楚这些的关系，这边有一个解释很是清晰，看了就明白了
<ul>
<li><em>3.1.2.1.  Endpoint Request Confidentiality If a redirection request will result in the transmission of an authorization code or access token over an open network (between the resource owner’s user-agent and the client), the client SHOULD require the use of a transport-layer security mechanism.</em> 这个是<code>Oauth</code>官方文档里面的一段话。</li>
<li>上面一段的意思应该是这样的：一个第三方认证的请求在传输<code>authorization code</code>或者<code>access token</code>的时候应当在传输层使用安全机制。这里的安全机制就是指<code>TLS</code>协议。</li>
</ul>
</li>
</ul>
<h2 id="tls版本"><a class="header-anchor" href="#tls版本"></a>TLS版本</h2>
<ul>
<li><code>SSL3.0</code> 和 <code>TLS1.0</code> 是一个东西。嗯，微软干的。微软虽然是一个伟大的公司，但是这个干得不好，相当不好，至少我本人觉得不好。实在是除了增加大家的混淆以外，没有任何意义。嘛，我们自己的产品也经常干这种事情。通常呢，是因为自己认为发生了跨时代的改变，希望让别人也明白。</li>
<li>目前最流行的版本是<code>TLS1.2</code>，最新的版本是<code>TLS1.3</code>。</li>
<li><code>java8</code>中默认的是<code>TLS1.2</code>版本。<code>java11</code>里面支持的是<code>TLS1.3</code></li>
<li>各种<code>web</code>应用服务器的配置文件里面都可以配置支持或者不支持的版本。比如<code>tomcat</code>提供了参数:<code>sslEnabledProtocols</code></li>
</ul>
<h3 id="如何发现我的浏览器使用的tls版本"><a class="header-anchor" href="#如何发现我的浏览器使用的tls版本"></a>如何发现我的浏览器使用的TLS版本</h3>
<ul>
<li>因为要测试<code>tomcat</code>里面配置的参数是否生效，所以第一反应就是我咋知道呢。后来经同事提点，其实用<code>openssl</code>就可以了</li>
<li>在浏览器的配置中能看到， 比如IE, <code>File</code>-&gt;<code>Properties</code>, 在<code>Connection</code>一栏就能看到。</li>
<li>参考链接：
<ul>
<li><a href="https://www.thesslstore.com/blog/google-chrome-72-deprecates-support-for-tls-1-0-tls-1-1/" target="_blank" rel="noopener">chrome如何配置和查看</a></li>
<li><a href="https://security.stackexchange.com/questions/19096/how-to-determine-if-a-browser-is-using-an-ssl-or-tls-connection/169418" target="_blank" rel="noopener">如何查看website的TLS版本</a></li>
</ul>
</li>
</ul>
<h3 id="如何测试tls连接"><a class="header-anchor" href="#如何测试tls连接"></a>如何测试TLS连接</h3>
<ul>
<li>这个是刚需啊刚需。使用<code>openssl</code>肯定也是可以的。这回使用的是<code>curl</code>命令。</li>
<li><code>curl help</code>一下可以看到，使用参数就可以指定<code>TLS</code>版本，还是很好用的。<br>
😦 我觉得自己有时候是很奇怪的人啊，下回要把实际使用的命令写在这里。╭(╯^╰)╮</li>
</ul>
<h2 id="tls双向握手"><a class="header-anchor" href="#tls双向握手"></a>TLS双向握手</h2>
<h3 id="keystore和truststore"><a class="header-anchor" href="#keystore和truststore"></a>KeyStore和TrustStore</h3>
<ul>
<li><code>keystore</code>和<code>truststore</code>从其文件格式来看其实是一个东西，都是<code>.jks</code>文件，只是为了方便管理将其分开</li>
<li><code>keystore</code>中一般保存的是服务器端的私钥，用来加解密或者为别人做签名。存储服务器端的公钥和私钥。</li>
<li><code>truststore</code>中保存的是一些可信任的证书，主要是<code>java</code>在代码中访问某个<code>https</code>的时候对被访问者进行认证的，以确保其实可信任的。一般为公钥<br>
<code>truststore</code>里面存储的是服务器的信任密钥存储库，存<code>CA</code>公钥，也会有人在里面存储客户端的证书集合。</li>
<li>应该在不同的协议中都有可能碰到，不仅仅是<code>HTTPS</code>，在网上搜索过程中有<code>LDAP</code>也用到的。</li>
</ul>
<h3 id="jetty-tls-configuration"><a class="header-anchor" href="#jetty-tls-configuration"></a>Jetty TLS Configuration</h3>
<ul>
<li><code>keystore</code> 里面存储的是<code>key-pair</code>和<code>certificate</code></li>
<li>对于<code>Jetty</code>来说，<code>jetty.xml</code>只支持<code>keystore</code>，而不支持<code>*.crt</code>的格式</li>
<li>项目中碰到了只提供<code>*.crt</code>文件的情况，那么需要自己产生<code>keystore</code>，再将证书导入</li>
</ul>
<h3 id="keytool"><a class="header-anchor" href="#keytool"></a>Keytool</h3>
<ul>
<li>
<p><code>keytool</code>是<code>java</code>默认带的工具。通常生成<code>.jks</code>格式的文件。称为<code>keystore</code></p>
</li>
<li>
<p><code>keystore</code>文件里面可以带<code>key-pair</code>，也可以是证书</p>
</li>
<li>
<p>以下命令是生成一个名为<code>keystore.jks</code>的<code>keystore</code>,并将证书<code>jetty.crt</code>导入到这个文件里面。同时指定了密码，并且在过程中不需要屏幕交互。<code>-trustcacerts</code>的含义是信任该证书</p>
<pre><code>/opt/jdk/jre/bin/keytool -import -trustcacerts -file jetty.crt -keystore keystore.jks -alias jetty  -storepass changeit -noprompt
</code></pre>
</li>
<li>
<p>这条命令可以将上一条命令中导入的证书打印输出进行检验</p>
<pre><code>/opt/jdk/jre/bin/keytool -list -v -keystore keystore.jks
</code></pre>
</li>
</ul>
<h3 id="openssl"><a class="header-anchor" href="#openssl"></a>openssl</h3>
<h3 id="交互流程"><a class="header-anchor" href="#交互流程"></a>交互流程</h3>
<ul>
<li>
<p>双向握手的时候客户端实际会发4次<code>client hello</code>消息，如下图<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/3-times%20handshake.PNG" alt="双向握手流程图"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/entire_handshake_senario.png" alt="wireshark里面对应的消息流"></p>
</li>
<li>
<p>主要是按照参考链接里面最后一篇来学习的</p>
</li>
<li>
<p>TLS握手分为以下几个步骤：</p>
<pre><code>客户端发送Hello报文
服务器接收Hello报文
共享证书和服务器密钥交换
更改密码规范
加密握手
</code></pre>
</li>
<li>
<p><code>admin</code>权限打开<code>wireshark</code>，选择对应网卡，然后抓包，就可以看到文章里面的图片上显示的命令了。</p>
</li>
<li>
<p><code>TLS</code>本身是一层协议并且它的底层叫做记录协议(<code>Record protocol</code>)。<code>TLS</code>到底在哪一层，大家理解不一样，但是在<code>TCP</code>和<code>HTTP</code>之间，或者<code>HTTP</code>上比较合适。从<code>dump</code>来看，<code>HTTP</code>链接在TLS握手之前已经是建立好了。</p>
</li>
<li>
<p>记录的格式：</p>
<pre><code>HH V1:V2 L1:L2 data
</code></pre>
<ul>
<li><code>HH</code>是信息分类 change_cipher_spec（20），alert（21），handshake（22）和application_data（23）。所以<code>client hello</code>和<code>server hello</code>都是22</li>
<li><code>V1:V2</code>是协议版本，这个有点不理解。我看<code>TLS1.2</code>就是<code>0x0303</code></li>
<li><code>L1:L2</code>是数据长度。<strong><em>我有点不明白，为啥都要带<code>：</code>，看版本信息，并没有：</em></strong></li>
</ul>
</li>
</ul>
<h4 id="客户端发送hello报文"><a class="header-anchor" href="#客户端发送hello报文"></a>客户端发送Hello报文</h4>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Client_Hello.png" alt="自己截的发往Github的消息"></p>
<ul>
<li>在上面的图片里面我没有<code>follow HTTP Stream</code>，看起来就有点奇怪，客户端Hello都在上面了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Detail_Info_in_Client_Hello.png" alt="详细的helo报文信息"></p>
<ul>
<li>
<p>在<code>secure socket layers</code>里面能看到具体信息，客户端会先说，我要用这个版本的TLS，我支持这些密码套件</p>
</li>
<li>
<p>关于<code>sessionId</code>，中文翻译的文档有点不太对。实际的意思是，如果是第一次访问一个网站，当然是个空， 但是如果不是第一次，并且在expireation的时间里面，就会是有值的。</p>
</li>
<li>
<p>这个在之前看<code>oauth</code>的时候看到过。服务器会存储<code>sessionId</code>以及其他信息。在<code>sessionId</code>存在的情况下，并不会进行一个完整的交互</p>
</li>
<li>
<p>密码套件里面包括使用的协议，交换秘钥时候的加密算法，证书用的加密算法，还有传输数据时候的加密算法。前两者一般是不对称的，最后一个一般是对称加密算法。还是解释一下：</p>
<pre><code>Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
协议_秘钥交换算法_签名验证算法_批量加密算法(AES_128_GCM)_消息验证代码
</code></pre>
</li>
<li>
<p>在<code>TLS1.2</code>里面还可以使用压缩算法。1.3的版本里面已经去除了。因为压缩是有漏洞可以被攻击</p>
</li>
<li>
<p>扩展的部分是附属信息，暂时不多了解</p>
</li>
</ul>
<h4 id="服务端发送hello报文"><a class="header-anchor" href="#服务端发送hello报文"></a>服务端发送Hello报文</h4>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Server_Hello.png" alt="服务端hello消息"></p>
<ul>
<li>这里可以看到<code>TLS</code>里面的记录协议层，还有握手协议层。但是从图片看起来，握手协议在记录协议里面。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Details_Info_Server_Hello.png" alt="服务端hello消息详解"></p>
<ul>
<li>上边的两张图片应该都是第二次时候的，明显比第一次连接时候要少交互。服务器端hello的时候就直接开始使用上几次的证书秘钥进行消息验证了。</li>
<li>服务器端也有随机数，类似的，一共32字节，前面4个字节也是时间，后面的是真正的随机数。</li>
<li><code>session ticket</code>客户端的章节里面已经阐述了<code>session Id</code>的用处。当大访问客户，互联网用户时候，那么在服务器端存储所有的<code>session</code>信息显然是不合理的。所有引入了这个<code>session ticket</code>，将所有的信息用服务器端的私钥加密之后存贮在客户端。客户端hello消息里面可以看到这个字段，在扩展消息里面</li>
</ul>
<h4 id="服务端发送证书和秘钥"><a class="header-anchor" href="#服务端发送证书和秘钥"></a>服务端发送证书和秘钥</h4>
<ul>
<li>接下来服务器会将服务器的证书等信息发给客户端：可以看到里面有两条<code>secure layer</code>的消息。第二条<code>secure layer</code>信息里面又有两条记录信息，一条是秘钥交换，一条是hello done的消息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/server_certificate_key_finished.png" alt="服务器端证书信息概览"></p>
<ul>
<li>在详细信息里面，能看到证书和秘钥的信息<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/server_certificate_key_finished_details.png" alt="服务器端证书信息详细"></li>
</ul>
<h4 id="客户端发送证书和秘钥"><a class="header-anchor" href="#客户端发送证书和秘钥"></a>客户端发送证书和秘钥</h4>
<ul>
<li>
<p><code>Github</code>使用的是D-H算法，客户端必须获取服务器端的公钥才能计算自己的公钥，算法细节后续在算法博客里面学习。</p>
</li>
<li>
<p>客户端计算出自己的公钥，用服务器端的公钥来加密，然后发给服务器端，服务器端会用自己的私钥来解密。</p>
</li>
<li>
<p>客户证书消息里面里面也有三条记录消息。最后一条是测试数据，在测试数据里面包含以下内容</p>
<pre><code>verify_data = PRF(master_secret, &quot;client finished&quot;, MD5(handshake_messages) + SHA-1(handshake_messages) )
</code></pre>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/client_certificate_key_tested_msg.png" alt="客户证书消息"></p>
<h4 id="服务器端发送finish消息"><a class="header-anchor" href="#服务器端发送finish消息"></a>服务器端发送finish消息</h4>
<ul>
<li>服务器端在收到客户端的公钥之后，会发送一条类似的消息，整个握手过程就结束了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/server_answer_verify_msg.png" alt="服务器端加密验证消息"></p>
<h4 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h4>
<ul>
<li>这边的参考链接好多还没有细看，是写这篇博客过程中找到的，后面需要再进一步学习啊</li>
<li><a href="https://www.jianshu.com/p/a3a25c6627ee" target="_blank" rel="noopener">Https详解+wireshark抓包演示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/86304211" target="_blank" rel="noopener">HTTPS抓包了解TLS握手流程</a></li>
<li><a href="https://crypto.stackexchange.com/questions/34754/what-does-the-tls-1-2-client-finished-message-contain/34792" target="_blank" rel="noopener">What does the TLS 1.2 client finished message contain?<br>
</a></li>
<li><a href="https://blog.csdn.net/mrpre/category_9270159.html" target="_blank" rel="noopener">SSL/TLS协议详解<br>
</a></li>
</ul>
<h2 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h2>
<ul>
<li><a href="https://www.cnblogs.com/gsls200808/p/4500246.html" target="_blank" rel="noopener">KeyStore和TrustStore</a></li>
<li><a href="https://xz.aliyun.com/t/2530" target="_blank" rel="noopener">TLS 协议详解</a></li>
<li><a href="https://stackoverflow.com/questions/19236628/jetty-9-setting-up-the-most-basic-ssl-https" target="_blank" rel="noopener">jetty-9-setting-up-the-most-basic-ssl-https</a></li>
<li><a href="https://wiki.eclipse.org/Jetty/Howto/Configure_SSL#Loading_Keys_and_Certificates_via_PKCS12" target="_blank" rel="noopener">Jetty/Howto/Configure SSL</a></li>
<li><a href="https://knowledge.digicert.com/solution/SO15252.html" target="_blank" rel="noopener">Import a certificate into a Jetty Java HTTP Servlet Web Server</a></li>
<li><a href="https://www.eclipse.org/jetty/documentation/current/configuring-ssl.html#loading-keys-and-certificates" target="_blank" rel="noopener">loading-keys-and-certificates</a></li>
<li><a href="https://www.wst.space/ssl-part-4-tls-handshake-protocol/" target="_blank" rel="noopener">tls-handshake-protocol</a></li>
<li><a href="https://xz.aliyun.com/t/2531" target="_blank" rel="noopener">TLS握手，上篇文档的翻译</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/10/11/K8s-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/10/11/K8s-Service/" class="post-title-link" itemprop="url">K8s Service</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 16:40:09" itemprop="dateCreated datePublished" datetime="2019-10-11T16:40:09+08:00">2019-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-23 13:22:01" itemprop="dateModified" datetime="2020-10-23T13:22:01+08:00">2020-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/10/11/K8s-Service/" class="post-meta-item leancloud_visitors" data-flag-title="K8s Service" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Service的概念有点多，内容，单独拎出来做一篇。</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://www.kubernetes.org.cn/kubernetes-services" target="_blank" rel="noopener">名词解释 Services</a></li>
<li><a href="https://segmentfault.com/a/1190000019376912" target="_blank" rel="noopener">Kubernetes Service详解</a></li>
<li><a href="https://segmentfault.com/a/1190000022118019?utm_source=sf-related" target="_blank" rel="noopener">一文了解 Kubernetes 中的服务发现</a></li>
</ul>
<h2 id="为什么需要service"><a class="header-anchor" href="#为什么需要service"></a>为什么需要service</h2>
<p>按照参考链接2里面的解释，倒是很容易理解。<code>POD</code>可以起很多个，是实体，还一会有一会没的。<br>
而<code>service</code>是暴露服务的，这么说，应该只有一个<code>service</code>才对吧。瞅着确实如此啊。</p>
<h2 id="services"><a class="header-anchor" href="#services"></a>Services</h2>
<p><code>service</code>是<code>K8s</code>里面一个非常重要的概念。类型比较多。K8s中文文档里面的名词解释还是比较清楚的，并且给出了为什么需要<code>service</code>，<code>service</code>和<code>pod</code>有什么区别</p>
<ul>
<li>
<p><code>Kubernete Service</code> 是一个定义了一组<code>Pod</code>的策略的抽象，我们也有时候叫做宏观服务。这些被服务标记的<code>Pod</code>都是（一般）通过<code>label Selector</code>决定的（下面我们会讲到我们为什么需要一个没有<code>label selector</code>的服务）</p>
</li>
<li>
<p>A Kubernetes service is a named load balancer that proxies traffic to one or more containers.</p>
</li>
<li>
<p>The proxy works even if the containers are on different nodes. Services proxy communicate within the cluster and rarely expose ports to an outside interface.When you launch a service it looks like you cannot connect using curl or netcat unless you start it as part of Kubernetes. The recommended approach is to have a LoadBalancer service to handle external communications.<br>
<strong>好吧，这段话基本没看懂，暂时就不管它了。service不仅仅是load balancer吧，难道每一种service都是load balancer的一种体现吗？</strong></p>
</li>
<li>
<p>Kubernetes Services are an abstract that defines a policy and approach on how to access a set of Pods. The set of Pods accessed via a Service is based on a Label Selector.</p>
</li>
<li>
<p>Service有很多种，包括<code>targetPort</code>，经常用到的，还有：<code>Cluster IP</code>， <code>NodePort</code> ，<code>External IPs</code>， <code>Load Balancer</code>之类</p>
<ul>
<li>Cluster IP的解释： Cluster IP is the default approach when creating a Kubernetes Service. The service is allocated an internal IP that other components can use to access the pods.</li>
</ul>
<p><strong>cluster IP是默认的service的类型。这种service会暴露一个internal IP，来供给系统中其他的service来访问这堆pod提供的服务，所以通常也会有port的隐射.</strong></p>
<ul>
<li>
<p>Target Port的解释：Target ports allows us to separate the port the service is available on from the port the application is listening on. TargetPort is the Port which the application is configured to listen on. Port is how the application will be accessed from the outside.<br>
<strong>这回比较清楚了，service其实是将POD提供的服务转出来，port是开在service上面，这样其他的service访问这个service的时候就是用这个port，而target port是对应到POD的应用上面的。比如我们自己产品的北向端口的POD，提供的服务开在8080上面，yaml文件里面起的service的port也是8080，其实也可以改成其他的</strong></p>
</li>
<li>
<p>NodePort的解释：the NodePort exposes the service on each Node’s IP via the defined static port. No matter which Node within the cluster is accessed, the service will be reachable based on the port number defined.<br>
<strong>就是<code>get Nodes</code>的命令出来的Node吧。<code>get Nodes</code>命令给出的是<code>hostname</code>，我们自己的环境里面，<code>hostname</code>一般定义格式是<code>node-10-2xx-1xx-xxx</code>,后面这个就是node的IP。这些node实际上是虚拟机。或者是实体机，现在应该都是虚拟的node。比如可以在openstack的node集群上面搭建k8s的服务</strong></p>
</li>
</ul>
<ul>
<li>External IPs的解释：给定master Node的一个IP。然后The service is now bound to the IP address and Port 80 of the master node</li>
<li>Load Balancer的解释：cloud Provider都是有自己的load Balancer的。如果没有的话，可以dynamically allocate IP addresses to LoadBalancer type services.When a service requests a Load Balancer, the provider will allocate one from the 10.10.0.0/26 range defined in the configuration.这个是确定的范围吗</li>
<li>结合上面的，我觉得都需要啊。</li>
</ul>
</li>
</ul>
<h2 id="暴露service的命令"><a class="header-anchor" href="#暴露service的命令"></a>暴露service的命令</h2>
<ul>
<li><code>kubectl expose deployment first-deployment --port=80 --type=NodePort</code>
<ul>
<li>
<p>将资源暴露为新的Kubernetes Service。</p>
</li>
<li>
<p>expose后面的资源有很多种，包括：pod（po），service（svc），replication controller（rc），deployment（deploy），replica set（rs）</p>
</li>
<li>
<p>A Kubernetes service deployment has, at least, two parts. A replication controller and a service. 稍微有点理解了。一个service部署的时候一般有两个yaml文件</p>
</li>
<li>
<p><code>first-deployment</code>是deployment的名字</p>
</li>
<li>
<p>port 是内部的端口</p>
</li>
<li>
<p>–target-port是外部访问的端口</p>
</li>
<li>
<p>完整语法为：</p>
</li>
</ul>
</li>
</ul>
<pre><code>expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type]
</code></pre>
<h3 id="yaml文件"><a class="header-anchor" href="#yaml文件"></a>yaml文件</h3>
<ul>
<li>参考链接二中的yaml文件的例子如下：</li>
</ul>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: gowebsvc
spec:
  selector:
    app: goweb
  ports:
  - name: default
    protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
</code></pre>
<ul>
<li><code>selector</code>指定了是哪个pod，因为pod可能有很多，所以这里用的是pod的tag <code>app: goweb</code>，就是说，这个service是暴露所有这个tag的pod的功能的</li>
</ul>
<h2 id="请求转发"><a class="header-anchor" href="#请求转发"></a>请求转发</h2>
<ul>
<li><code>K8S service</code>其实做到了一定的负载均衡，但是是一个简单的轮询。工作在连接层面，其实就是<code>Iptable</code>里面来实现的。</li>
<li>所以同一个连接里面的请求都会进到同一个<code>POD</code>里面去。因为对于高层的<code>HTTP</code>或者<code>Cookie</code>之类的是无法感知到的。</li>
</ul>
<h3 id="service在iptables"><a class="header-anchor" href="#service在iptables"></a>Service在Iptables</h3>
<p><code>cluster ip</code>类似VIP,从这个名字来说，应该是认为一组pod就是一个<code>cluster</code>，确实也可以如此认为。既然是类似<code>VIP</code>，那么就可以被认为是<code>load banlancer</code>，那么就有策略的问题了。<br>
使用以下命令，可以查看<code>clusterIP 10.106.202.0</code>的转发策略</p>
<pre><code>iptables-save | grep 10.106.202.0
</code></pre>
<p>当一条<code>request</code>发到某个<code>service</code>的<code>cluster ip + port</code>上面时，会经过两次数据链转发（这里的数据链，指的是<code>iptables</code>里面的数据转发规则），第一次数据链转发时候会进行load的分配。<br>
第一条转发链如下.<code>KUBE-SVC-SEG6BTF25PWEPDFT</code>转发链将request均分到4个pod上面。</p>
<pre><code> -A KUBE-SERVICES ! -s 10.100.0.0/16 -d 10.254.52.228/32 -p tcp -m comment --comment &quot;eda2-gear-enixjac02/gowebsvc: cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.25000000000 -j KUBE-SEP-5ZXTVLEM4DKNW7T2
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-EBFXI7VOCPDT2QU5
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-C3PKSXKMO2M43SPF
 -A KUBE-SVC-SEG6BTF25PWEPDFT -j KUBE-SEP-2GQCCNJGO65Z5MFS
</code></pre>
<p>第二次转发的时候，会对目的地做<code>DNAT</code>，反正做了这个<code>DNAT</code>，然后就<code>DNAT</code>到了<code>endpoint</code>上面。</p>
<p><code>KUBE-MARK-MASQ</code>规则如下，<code>MARK</code>会将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则</p>
<pre><code>-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000
</code></pre>
<p><em>比照上面的规则，可以看出<code>KUBE-SEP-5ZXTVLEM4DKNW7T2</code>这条规则对请求的目的地址作了<code>DNAT</code>到<code>10.244.1.15:8000</code>，这正是<code>goweb</code>POD组中<code>goweb-55c487ccd7-5t2l2</code>这个pod的ip地址</em></p>
<pre><code>[root@master-1 ~]# iptables-save | grep  &quot;A KUBE-SEP-5ZXTVLEM4DKNW7T2&quot; 
-A KUBE-SEP-5ZXTVLEM4DKNW7T2 -s 10.244.1.15/32 -j KUBE-MARK-MASQ
-A KUBE-SEP-5ZXTVLEM4DKNW7T2 -p tcp -m tcp -j DNAT --to-destination 10.244.1.15:8000
</code></pre>
<p><code>NodePort</code>类型的服务会比<code>clusterIp</code>多两条，如下：</p>
<pre><code>-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;eda2-gear-enixjac02/gowebsvc:&quot; -m tcp --dport 31827 -j KUBE-MARK-MASQ
-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;eda2-gear-enixjac02/gowebsvc:&quot; -m tcp --dport 31827 -j KUBE-SVC-7NDHFS7EDAQWBVTB
</code></pre>
<p>相对应的，<code>LoadBalancer</code>类型的服务会再多出两条来</p>
<h3 id="endpoint"><a class="header-anchor" href="#endpoint"></a>endpoint</h3>
<ul>
<li>
<p>在<code>service</code>创建的时候，<code>kube-proxy</code>组件（每个k8s服务器都会有的组件）会自动创建同名的<code>endpoint</code>对象。</p>
</li>
<li>
<p>动态地跟踪匹配<code>selector</code>的一组<code>pod</code>当前<code>ip</code>（<code>pod</code>的<code>ip</code>在<code>pod</code>的<code>yaml</code>文件里面可以知道，名字就是<code>podIP</code>）及端口，并生成相应的<code>iptables KUBE-SVC-xxx</code>规则</p>
</li>
<li>
<p><code>service</code>是用了<code>endpoint</code>来对pod进行动态的跟踪的。一个<code>pod</code>的IP发生变化的时候，<code>endpoint</code>和<code>KUBE-SVC-XXX</code>规则会相应变化</p>
</li>
<li>
<p><code>endpoint</code>是<code>k8s</code>的另一个对象，生成一个<code>service</code>的时候，会相对应生成一个<code>endpoint</code>.</p>
<pre><code>$ kubectl get ep -n sallyslove xxxxxxx-mml
NAME         ENDPOINTS                           AGE
xxxxxx-mml  192.168.15.102:8111,192.168.15.102:8010   1h
</code></pre>
</li>
</ul>
<h3 id="请求代理的三种方式"><a class="header-anchor" href="#请求代理的三种方式"></a>请求代理的三种方式</h3>
<p>全文参考链接二里面有三种方式。由于网络基础较差，先记录在这里：</p>
<ul>
<li><code>Userspace</code>模式：这种模式完全依靠<code>kube-proxy</code>来，<em><code>Userspace</code>模式的代理转发主要依靠<code>kube-proxy</code>实现，工作在用户态。所以，转发效率不高</em></li>
<li><code>iptables</code>模式: 也就是上面稍加解释的方法，是目前的默认模式。</li>
</ul>
<p><em>与userspace模式最大的不同点在于，kube-proxy只动态地维护iptables，而转发完全靠iptables实现。由于iptables工作在内核态，不用在用户态与内核态切换，所以相比userspace模式更高效也更可靠。但是每个服务都会生成若干条iptables规则，大型集群iptables规则数会非常多，造成性能下降也不易排查问题。</em></p>
<ul>
<li><code>ipvs</code>模式: 在<code>v1.9</code>版本以后，服务新增了<code>ipvs</code>转发方式.</li>
</ul>
<p><em><code>ipvs</code>同样工作在内核态，而且底层转发是依靠<code>hash表</code>实现，所以性能比<code>iptables</code>还要好的多，同步新规则也比<code>iptables</code>快。同时，负载均衡的方式除了简单rr还有多种选择，所以很适合在大型集群使用。而缺点就是带来了额外的配置维护操作。</em></p>
<h3 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/u011563903/article/details/86692694" target="_blank" rel="noopener">K8S kube-proxy iptables 原理分析</a></li>
</ul>
</li>
</ul>
<h2 id="服务发现"><a class="header-anchor" href="#服务发现"></a>服务发现</h2>
<p>先区分一下上面的请求转发和这里的服务发现。<br>
请求的话通常是端口号+地址就行啦。服务发现要能够发现这个service才行。就是如何让另一个service知道这个service的ip或者hostname，或者让k8s外的客户知道某个service的ip和端口</p>
<h3 id="内部服务发现"><a class="header-anchor" href="#内部服务发现"></a>内部服务发现</h3>
<p>内部服务发现有两种方式：环境变量和DNS</p>
<h4 id="dns方式"><a class="header-anchor" href="#dns方式"></a>DNS方式</h4>
<ul>
<li>
<p>在<code>k8s</code>系统有个<code>namespace</code>为<code>kube-system</code></p>
<pre><code>$ kubectl get svc --namespace=kube-system
NAME TYPE CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE
kube-dns                        ClusterIP   10.254.0.10      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   32d
</code></pre>
</li>
<li>
<p><code>Core DNS</code>是<code>K8S</code>的原生应用，<code>Core DNS</code>会监测服务的创建，每当有新的服务创建，这个服务就会给新的服务创建<code>hostname</code>和<code>IP</code>的对应关系</p>
</li>
<li>
<p><code>clusterIp</code>处于一个叫做<code>K8S</code>的<code>service network</code>的虚拟网络里面，但是这个虚拟网络非常奇怪，因为它没有路由，所以发到<code>clusterIP</code>的请求会被转发到默认的路由上面，然后再发到节点上面，节点的网关上面也没有这个<code>IP</code>的信息，只能将它转发到自己的默认网关上， 在这个过程中，经过了节点的内核</p>
</li>
<li>
<p>而正是经过内核的时候，触发了内核框架<code>netfilter</code>的<code>hook</code>，也就是触发了<code>Iptable</code>的规则，上述的规则开始生效，将请求转发到了目标的<code>POD IP</code>上面。</p>
</li>
<li>
<p>下图也是网络上面的，但是一时找不到出处了。非常清晰</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Docker/from_clusterIp_to_podIp.png" alt="from_clusterIp_to_podIp"></p>
<h3 id="外部服务发现"><a class="header-anchor" href="#外部服务发现"></a>外部服务发现</h3>
<p>外部服务发现，顾名思义，就是k8s服务器以外来发现某个service提供的服务</p>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/chris-cp/p/6724057.html" target="_blank" rel="noopener">k8s实战之Service</a></li>
</ul>
</li>
</ul>
<h4 id="nodeport"><a class="header-anchor" href="#nodeport"></a>NodePort</h4>
<ul>
<li><code>nodePort</code> 和 <code>node</code>是一对，首先要理解一下<code>node</code>的概念。这边的<code>node</code>相当于是<code>VM</code>。</li>
<li>就是这样的，我有一套硬件，然后我在上边搭虚拟环境，比如<code>openstack</code>，<code>openstack</code>会先搭出一堆<code>node</code>来，然后再在这堆<code>node</code>上边装<code>k8s</code>,建<code>namespace</code>，每个<code>namespace</code>里面再建<code>pod</code>啊之类的。</li>
<li>所以可以理解成<code>VM</code>，那么这个<code>IP</code>是可以访问到的。</li>
<li><em><code>NodePort</code>是类型为<code>NodePort</code>的<code>Service</code>，<code>k8s</code>除了会分配给<code>NodePort</code>一个内部的虚拟<code>IP</code>，另外会在每一个<code>Node</code>上暴露端口<code>NodePort</code>，外部网络可以通过[NodeIP]:[NodePort]访问到服务。</em></li>
<li>需要注意的是，<code>NodePort</code>会在每个<code>node</code>上面注册自己。所以这个<code>NodeIP</code>可以是<code>cluster</code>的每个<code>node</code>。<em>该方式把服务暴露在每个<code>Node</code>主机<code>IP</code>的特定端口上,同一个服务在所有<code>Node</code>上端口是相同的，并自动生成相应的路由转发到<code>ClusterIP</code></em>。所以<code>NodePort</code>的<code>service</code>也是有<code>cluster IP</code>的。</li>
</ul>
<h4 id="loadbalancer"><a class="header-anchor" href="#loadbalancer"></a>LoadBalancer</h4>
<ul>
<li><code>LoadBalancer</code>是类型为<code>LoadBalancer</code>的<code>Service</code>，它是建立在<code>NodePort Service</code>集群基础上的，<code>k8s</code>会分配给<code>LoadBalancer Service</code>一个内部的<code>虚拟IP</code>，并且暴露<code>NodePort</code>。除此之外，<code>k8s</code>请求底层云平台创建一个负载均衡器，将每个<code>Node</code>作为后端，负载均衡器将转发请求到<code>[NodeIP]:[NodePort]</code></li>
</ul>
<h3 id="debug"><a class="header-anchor" href="#debug"></a>Debug</h3>
<ul>
<li>
<p>参考链接：</p>
<ol>
<li><a href="https://www.dazhuanlan.com/2019/10/22/5daee17b80349/?__cf_chl_jschl_tk__=16d0ed9e8a1801a665c5cdb4282507c30bcd27ab-1600843391-0-ASKK6HvcorRj55xKYNub3llJlynYT3Ck6rsxc9p0BGVng5Z6DYb6gVnF8uOlab94C_NFIteNMJTp1hSirK9JU3ni1KKQ9vuAEyn0u1nF-pZfx9l00TNt5THYNhcHGra5DcBwL5A0zHqsgDP9_xTvXWYgbW-9WzAzEiORNZ0Celtm1eYp_bZQZb6fXC0IxcVVacuNjkyQFYb6-llsgW00Lc_z0uWBJN43uoxONoZjDX7A1Yysc49r2PvArVKdYkuuw6u_sv7_VFv64dhBYw6XEG0l66FKwmdaArkp67FHPae-6wXyCSYV0WJYrk1xJk_ttw" target="_blank" rel="noopener">k8s iptables 规则查看</a></li>
<li><a href="https://myf5.net/post/2343.htm" target="_blank" rel="noopener">nodeport下访问请求未被分发到所有node的排错</a></li>
<li><a href="https://www.opensourcerers.org/2016/05/27/how-to-trace-iptables-in-rhel7-centos7/" target="_blank" rel="noopener">How to trace IPTables in RHEL7 / CENTOS7</a></li>
</ol>
</li>
<li>
<p>持久化 <code>Iptable</code>的规则，需要在<code>/ete/system/</code>下面修改文件</p>
</li>
<li>
<p>命令：</p>
<pre><code>Load the (IPv4) netfilter log kernel module
modprobe nf_log_ipv4

Enable logging for the IPv4 (AF Family 2)
sysctl net.netfilter.nf_log.2=nf_log_ipv4

restart rsyslogd
systemctl restart rsyslog

follow 32741 port
iptables -t raw -j TRACE -p tcp --dport 32741 -I PREROUTING 1
iptables -t raw -j TRACE -p tcp --dport 32741 -I OUTPUT 1
</code></pre>
</li>
<li>
<p>查看 <code>/var/log/messages</code> 中的追踪记录</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/08/22/5G/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/08/22/5G/" class="post-title-link" itemprop="url">5G</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-22 14:04:36" itemprop="dateCreated datePublished" datetime="2019-08-22T14:04:36+08:00">2019-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-04 13:47:01" itemprop="dateModified" datetime="2020-09-04T13:47:01+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Telecom/" itemprop="url" rel="index"><span itemprop="name">Telecom</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/08/22/5G/" class="post-meta-item leancloud_visitors" data-flag-title="5G" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为通信行业的一名软件开发人员，我要开始学习5G啦。😃</p>
<p>里面有非常多的新网元引入。各种缩写漫天飞舞 😢</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://medium.com/5g-nr/5g-service-based-architecture-sba-47900b0ded0a" target="_blank" rel="noopener">5G Service-Based Architecture (SBA)</a></li>
<li><a href="https://www.grandmetric.com/2018/03/02/5g-core-network-functions/" target="_blank" rel="noopener">5G Core Network Functions</a></li>
</ul>
<h2 id="5gc-概述"><a class="header-anchor" href="#5gc-概述"></a>5GC 概述</h2>
<ul>
<li><code>5G</code>里面的新的<code>core network</code>一般叫做<code>NR</code>，但是也有的地方，比如霓虹国，称为<code>next generation</code></li>
<li><code>SA</code>和<code>NSA</code>：<code>SA</code>就是<code>standalone</code>,<code>NSA</code>就是<code>non standslone</code>。这边的<code>SA</code>其实就是说只有<code>5G</code>，后面就是<code>4G</code>和<code>5G</code>并存。不同的运营商会有不同的网络状况。
<ul>
<li>现在正处于一个过渡期间，也可能会长期存在，出现了一些在4G的网元上面开发5G的功能，然后作为5G的网元来用的情况。</li>
</ul>
</li>
<li>通常我们关心的<code>5GC</code>是<code>5G corenetwork</code>的缩写。然后<code>5G</code>的核心有三大类: <code>SBA - service based architecture</code>, <code>CUPS - Control and User Plane Separation</code> 和 网络切片<br>
<strong>所以5GC和NR是一个东西?</strong></li>
<li>配置还是和4G一样的。统一来配置的。<code>E&amp;M</code>统一来做，因为现在平台软件是一致，所以RAN和core都一样，都用一个来做配置</li>
<li><code>UDC</code>换了个名字叫<code>UDR</code></li>
</ul>
<h3 id="sba"><a class="header-anchor" href="#sba"></a>SBA</h3>
<ul>
<li>
<p><code>SBA</code> 感觉和软件架构上面的微服务有点异曲同工的感觉。<code>4G</code>时代是各种各样的协议，每两个网元之间就可能有一种协议，并且还各不相同。但是到了<code>5G</code>的时候就是大家统一都是用<code>HTTP</code>协议了。然后各个网元只是提供<code>service</code></p>
</li>
<li>
<p>所以SBA是一种架构</p>
<p><img src="https://www.grandmetric.com/wp-content/uploads/2018/03/5G_Core_Network.png" alt=""></p>
</li>
</ul>
<h2 id="5g-nr"><a class="header-anchor" href="#5g-nr"></a>5G NR</h2>
<p><code>NR</code>指的是<code>new Radio</code>。在<code>5G</code>里面分为了<code>NE - Network Element</code>和<code>NF - Network Function</code>两个概念。顾名思义，<code>NF</code>是往外提供服务的</p>
<ul>
<li><code>NF</code>是一个功能，3GPP里面定义的，NE是一个实际的网元。一个NE可能会实现多个NF。</li>
</ul>
<h3 id="amf"><a class="header-anchor" href="#amf"></a>AMF</h3>
<p>与接入网相关</p>
<h4 id="smf"><a class="header-anchor" href="#smf"></a>SMF</h4>
<p>可能有一些与provision相关的</p>
<h3 id="nef-network-exposure-function"><a class="header-anchor" href="#nef-network-exposure-function"></a>NEF - Network Exposure Function</h3>
<h4 id="scef-和-mtc-iwf"><a class="header-anchor" href="#scef-和-mtc-iwf"></a>SCEF 和 MTC - IWF</h4>
<ul>
<li><code>(MTC - IWF) Machine Type Communications - Interwording Function</code>,</li>
</ul>
<h4 id="nef是什么"><a class="header-anchor" href="#nef是什么"></a>NEF是什么</h4>
<ul>
<li>NEF provides a mechanism for securely exposing services and features of the 5G core.</li>
<li><code>NEF</code>是和<code>SMF</code>连接在一起的。将<code>core</code>里面的功能暴露给外界的应用</li>
</ul>
<h3 id="nrf"><a class="header-anchor" href="#nrf"></a>NRF</h3>
<h4 id="nrf是什么"><a class="header-anchor" href="#nrf是什么"></a>NRF是什么</h4>
<ul>
<li><code>NF Repository function (NRF)</code> supports: service discovery function, maintains NF profile and available NF instances. (not present in EPC world)。</li>
<li>替换了原来<code>4G</code>里面的<code>ENUM</code>和<code>AAA</code></li>
<li><code>NRF</code>的功能看起来比较简单，有以下：
<ul>
<li>Service registration and discovery function so that Network Functions can discover each other.</li>
<li>Maintains NF profile and available NF instances</li>
<li>嗯，就是以上说的，<code>NR</code>会将自己注册到<code>NRF</code>里面，注册时候会带上不少信息，比如能提供的服务，自己认可的能访问服务的<code>NR</code>之类，同时会将自己的名字告诉给<code>NRF</code>。还有订阅功能。就是在<code>NRF</code>订阅自己关注哪些<code>NF</code>的哪些service</li>
<li><code>NR</code>可以通过<code>NRF</code>来访问其他<code>NR</code>。过程如下图所示。</li>
<li><code>NRF</code>在告诉同时会颁发一个<code>token</code>，做一些初步的验证。</li>
</ul>
</li>
</ul>
<p><img src="https://miro.medium.com/max/1008/1*VfK1R5ie3DRElDFHjrI-kw.png" alt=""></p>
<p><em>Network Repository Function service registration and discovery</em> (Credit: <a href="http://www.3gpp.org/ftp/information/presentations/Presentations_2017/webinar-ct-status-11-2017.pdf" target="_blank" rel="noopener">3GPP</a>)</p>
<ul>
<li>实际的部署和功能可能会更加复杂，例如，
<ul>
<li>每个网络切片可以有自己的<code>NRF</code></li>
<li>我大中华地域广阔，还会有地域的概念，一个不够。</li>
<li>那么一个上海人漫游到北京，联上了北京的<code>NRF</code>,北京的<code>NRF</code>得和上海的进行通信。如果漫游到了境外， 就更加复杂了。</li>
<li><code>NRF</code>也可以监控各个网元的状态，或者提供更加复杂的功能</li>
</ul>
</li>
<li>在<code>R16</code>里面提出了一个proxy的概念，<code>SCP - service Communication proxy</code>，因为<code>NRF</code>的网络通信过于繁杂，造成了很大的负担，所以引入的。</li>
</ul>
<h4 id="scp"><a class="header-anchor" href="#scp"></a>SCP</h4>
<h3 id="nssf"><a class="header-anchor" href="#nssf"></a>NSSF</h3>
<ul>
<li><code>NSSF</code>的数据分为<code>static</code>和<code>synamic</code>的数据。前者存在<code>UDM</code>里面，后者在<code>NSSF</code>里面。</li>
<li><code>UE</code>连入的时候会申请使用某种<code>slice</code>，然后网络会返回许可，存储的时候可以存在<code>UDM</code>里面</li>
<li>切片分为接入网，<code>RAN</code>和核心网，接入网是频段等的切片，目前没有合适的solution，而核心网的切片实际上就是拉一套小型的核心网起来，虚拟的，里面可能<code>AMF</code>是独立的，而<code>PCF</code>就是共用的。</li>
</ul>
<h3 id="pcf-policy-control-function"><a class="header-anchor" href="#pcf-policy-control-function"></a>PCF -  Policy Control Function</h3>
<ul>
<li><code>PCF</code>其实就是<code>4G</code>里面的<code>PCRF</code>。都是做<code>policy control</code>的</li>
<li><code>PCF</code>可以支持<code>AMF</code>的<code>policy control</code>和网络切片的<code>policy control</code></li>
<li><code>PCF</code>理解<code>UE</code>级别的，就是这个<code>UE</code>可以使用哪些<code>AMF</code>和<code>NSSF</code>。</li>
</ul>
<h2 id="5g基站和接入网的演进"><a class="header-anchor" href="#5g基站和接入网的演进"></a>5G基站和接入网的演进</h2>
<p>由于工作缘故，接触到的基本是核心网，话说刚刚入行的时候，我是做接入网的来着。<br>
但是其实，5G虽然是核心网变化最大，接入网也是有改变的</p>
<h3 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h3>
<ul>
<li><a href="https://blog.csdn.net/ityouknow/article/details/81351317" target="_blank" rel="noopener">第一次有人把5G讲的这么简单明了</a></li>
<li><a href="https://blog.csdn.xn--ne5Gt-vq5hmb652jn0tuwkpp6bfuycjqfvo0b/cf2SudS8x8F0v/article/details/78778384" target="_blank" rel="noopener">详解5G的六大关键技术</a></li>
</ul>
<h3 id="5g的改变"><a class="header-anchor" href="#5g的改变"></a>5G的改变</h3>
<ul>
<li>高频段传输：频率越高，能使用的频率资源越丰富。频率资源越丰富，能实现的传输速率就越高。</li>
<li>微基站：这个老早就有了。嗯，基站越小越好，覆盖好，而且能搞一大堆。高频段传输，距离短，正好用一大堆小基站</li>
<li>Ｍassive MIMO（大规模多天线技术）</li>
<li>D2D： 这个技术还是不错的，就是说如果靠得近，手机之间直接进行连接，不需要走基站了。但是后面技术如何支持的，并没有提到</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/08/16/OAuth2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/08/16/OAuth2-0/" class="post-title-link" itemprop="url">OAuth2.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-16 10:22:26" itemprop="dateCreated datePublished" datetime="2019-08-16T10:22:26+08:00">2019-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-23 13:37:01" itemprop="dateModified" datetime="2019-08-23T13:37:01+08:00">2019-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index"><span itemprop="name">security</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/08/16/OAuth2-0/" class="post-meta-item leancloud_visitors" data-flag-title="OAuth2.0" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个Oauth吧，我感觉我几年前就听到了，可惜还是没弄明白。必须承认那些传来传去啊，容易搞混淆和忘。<br>
嗯，写完了也还是有半懂不懂的感觉，不过好歹是个半懂了 😂</p>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://coolshell.cn/articles/19395.html" target="_blank" rel="noopener">HTTP API 认证授权术</a>：来自酷壳，写得很清楚，一步一步。感觉看这篇就能了解前世今生了。挺好。<br>
所以这篇博客就是以酷壳这篇为基础来学习的</li>
</ul>
<h3 id="http-basic"><a class="header-anchor" href="#http-basic"></a>HTTP Basic</h3>
<ul>
<li>上述参考链接里面说得很清楚。其实就是<code>user:password</code>用<code>Base64</code>编码协议进行编码，然后传输</li>
<li>但是可以看到这里仅仅是加密协议，所以通常会和HTTPS配合起来，用<code>TLS/SSL</code>的安全加密方式来传输</li>
<li>就是将编码后的字符放在HTTP协议的<code>Authenticate: Basic</code>里面。</li>
<li>需要注意的点是：
<ul>
<li>编码协议和加密协议不一样, <code>Base64</code>就是个编码，<code>RSA/AES</code>才是加密，<code>MD5</code>就只是取摘要的</li>
<li><code>HTTP Basic</code>方式将密码和用户名放在公网上面传输，存在风险</li>
</ul>
</li>
</ul>
<h3 id="digital-access"><a class="header-anchor" href="#digital-access"></a>Digital Access</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/huey/p/5490759.html" target="_blank" rel="noopener">HTTP - 摘要认证</a></li>
<li><a href="https://www.cnblogs.com/xzwblog/p/6834663.html" target="_blank" rel="noopener">HTTP认证与https简介</a></li>
<li><a href="https://en.wikipedia.org/wiki/Digest_access_authentication" target="_blank" rel="noopener">维基百科HTTP摘要认证</a></li>
</ul>
</li>
<li>摘要认证与基础认证是兼容的，但是进行了如下修改：
<ul>
<li>永远不会以明文方式在网络上发送密码。</li>
<li>可以防止恶意用户捕获并重放认证的握手过程。</li>
<li>可以有选择地防止对报文内容的篡改。</li>
<li>防范其他几种常见的攻击方式。</li>
</ul>
</li>
<li>还是维基百科比较清楚。摘要认证会使用MD5的方式来加密用户名和密码。相对来说，基础认证仅仅是使用了编码方式，而不是加密方式。</li>
<li>同时，摘要认证使用了<code>nonce values</code>来阻止<code>replay attacks</code><strong><em>不知道翻译成什么，重演攻击？</em></strong></li>
<li>但是整个过程其实关键是用户的password，这个password如果不够复杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击。 <strong><em>这点我还没理解</em></strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/OAuth2.0/http_digital_access_nonce.png" alt=""><br>
<strong>nonce 说明图</strong></p>
<ul>
<li>以下是自己画的简明的流程图，还是比较清楚的。
<ul>
<li>[]代表里面的数值</li>
<li><code>nonce</code>是服务器端生成的随机数。 <code>cnonce</code>是客户端生成的</li>
<li>如果多了<code>auth</code>，那么还要发送<code>HA2</code>，里面的<code>method</code>就是指<code>GET</code>操作， <code>entity body</code>指的是<code>HTTP request</code>的数据</li>
<li><code>opaque</code>看起来也是一个随机数，不知道是啥。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/OAuth2.0/http_digital_access.png.png" alt=""></p>
<h3 id="jwt-json-web-tokens"><a class="header-anchor" href="#jwt-json-web-tokens"></a>JWT – JSON Web Tokens</h3>
<p>本来想跳过其中几个，直接学习2.0的，貌似不可行。学习时候还是一步步来，不然就看不明白了。<br>
查博客的时候，又看到阮大神的博客了。不知道有没有人能看到我的博客，😇<br>
话说看到评论里有人抨击阮大神说没质量的，嗯，我的还是留着自己看吧。😂</p>
<h4 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h4>
<ul>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">什么是 JWT – JSON WEB TOKEN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JWT – JSON Web Tokens</a>: 阮大神的文章，还比较新，去年的。嘛，这技术不新。话说酷壳的是今年的。</li>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">官方文档</a>： 第一篇博客只是翻译，总的来说，JWT不是很复杂的，看了感觉蛮简单。比摘要还简单一点。</li>
</ul>
<h4 id="session-认证方式"><a class="header-anchor" href="#session-认证方式"></a>session 认证方式</h4>
<ul>
<li>
<p>基于<code>session</code>的认证方式，其实很好理解的。跟我们产品里面的某种协议类似，第一次登陆时候，客户端通过用户名和密码访问，然后服务器端返回一个<code>sessionId</code>。</p>
</li>
<li>
<p>后续访问的时候，就用这个<code>sessionId</code>来访问，服务器端再通过这个<code>sessionId</code>来查询到这个用户的所有信息。包括用户名啊，密码啊，访问权限啊，登录时长啊，我猜的，应该有这些信息。</p>
</li>
<li>
<p>互联网时代，这个<code>sessionId</code>会被浏览器端写入到自己的<code>cookie</code>里面。<strong>现在还有吗，我咋没看到<code>sessionId</code>字样</strong></p>
</li>
<li>
<p>这种方式的问题看起来有两个比较不好(瞅着这么简单，肯定不行啊，我今天脑内小剧场比较多啊)：</p>
<ul>
<li>一个安全问题，基于<code>cookie</code>来做的，想也知道不安全，<code>cookie</code>被读取之后就不成了。</li>
<li>扩展性不好，这个就比较复杂，有各种扩展性，比如<code>sessionId</code>存在服务器端的内存里面，那么内存客户端数量涨了，服务器就撑不住了；再比如，同一个客户，各种用微信登录，这个<code>session</code>没法在不同服务器之间进行共享，除非再引入中转，但是中转一挂就完蛋。</li>
</ul>
</li>
<li>
<p>然后对于上述的问题，就想了一个办法来解决，就是服务器端不再存储客户信息，而是所有信息都放在客户端，服务器端只是加一个签名。客户端后面每次访问都带上自己所有信息。</p>
<ul>
<li>话说，这不是比带<code>sessionId</code>要带的东西多嘛。每次都带，多麻烦呐。好处是服务器就不需要存储信息，无状态了。</li>
<li>这个签名我理解就是嗯，这个客户我老人家认证过了这样的。问题是认证过了就不认证了？应该是不认证了。<strong><em>问题在于这个签名怎么做的，服务器端如何知道这个用户是认证过的，合法的呢？比如我微信登录了一个，我再登录另一个服务器，第二个服务器怎么信任我呢。我想这里理解有点问题，不同的服务器，应该是相同的应用和功能。所以软件上是一套。</em></strong></li>
</ul>
</li>
</ul>
<h4 id="jwt-header"><a class="header-anchor" href="#jwt-header"></a>JWT Header</h4>
<ul>
<li>JWT其实就三个部分，header，payload和签名，在同一行。如下：</li>
</ul>
<pre><code>Header.Payload.Signature
</code></pre>
<ul>
<li>Header是JSON格式，里面有算法和令牌(token)类型，<strong><em>第一次知道<code>token</code>原来中文翻译成令牌，这是个多么熟悉的词组啊，N年前学网络时候没少听到。令牌令牌令牌的，原来是token，瞬间感觉很多东西更明白了，果然看大神的博客有无限好处</em></strong></li>
<li>下面是阮大神博客里面的例子，默认是<code>HMAC SHA256</code>（写成 HS256）。令牌类型就是<code>JWT</code>。这样服务器可以知道这次客户端发来的信息是接受过<code>JWT</code>认证的。</li>
<li>话说认证方式其实也是一种协议啊。特殊的协议。只是之前的<code>HTTP Basic</code>和<code>Digital Access</code>时候不知道服务器端是否存储用户信息。前者我想应该是存储的，后者应该也是存储的，否则无法进行校验。</li>
</ul>
<pre><code>{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<ul>
<li><em>将上面的JSON对象使用Base64URL算法转成字符串</em> 阮大神的实在清楚，我感觉我在加读书笔记。</li>
<li><strong><em>之前说过Base64只是编码算法，算不得加密算法，所以其实JWT的这部分并不十分安全</em></strong></li>
</ul>
<h4 id="jwt-payload"><a class="header-anchor" href="#jwt-payload"></a>JWT payload</h4>
<ul>
<li>payload的话，官方定了几个字段。几篇博客里面貌似没有说到如何实现的。</li>
</ul>
<pre><code>iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre>
<ul>
<li>也可以定义自己的字段。同样是<code>Base64</code>编码，所以不是加密的。</li>
</ul>
<h4 id="jwt-signiture"><a class="header-anchor" href="#jwt-signiture"></a>JWT Signiture</h4>
<ul>
<li>
<p>签名格式如下：</p>
<pre><code>HMACSHA256(
   base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret)
</code></pre>
</li>
<li>
<p>感觉安全性完全就在这个服务器端的秘钥，<code>secret</code>啊。算法就是header里面指定的加密算法。</p>
</li>
</ul>
<h4 id="流程图"><a class="header-anchor" href="#流程图"></a>流程图</h4>
<p><img src="https://upload-images.jianshu.io/upload_images/1821058-2e28fe6c997a60c9.png?imageMogr2/auto-orient/" alt=""></p>
<p><em>来自上面的参考链接1里面</em></p>
<h4 id="扩展和小结"><a class="header-anchor" href="#扩展和小结"></a>扩展和小结</h4>
<h5 id="扩展"><a class="header-anchor" href="#扩展"></a>扩展</h5>
<ul>
<li>在酷壳文章里面提到了验证服务器。通常实现中，我想服务器应该也会将信息发送到验证服务器来进行<code>secret</code>的加密和签名的解密</li>
<li>同时还提到了使用<code>RSA</code>加密算法来替代<code>HMAC-SHA256</code>算法，可以看一下。</li>
</ul>
<h5 id="小结"><a class="header-anchor" href="#小结"></a>小结</h5>
<ul>
<li>看起来JWT还是比较流行的技术，讨论很多，以下：
<ul>
<li><em>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</em> 看评论解释，也就是说我手机登录了我的微信， ipad也登录了。那么这两个是彼此独立的，ipad登录没法把手机登录的踢出来。</li>
<li>JWT不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li>
</ul>
</li>
</ul>
<h3 id="oauth2-0"><a class="header-anchor" href="#oauth2-0"></a>OAuth2.0</h3>
<h4 id="参考链接-v3"><a class="header-anchor" href="#参考链接-v3"></a>参考链接</h4>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">OAuth 2.0 的一个简单解释</a>: 阮大神的博客，简单清晰明了，确实大有裨益，这个小区快递员啥的，感觉我妈都能明白</li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">OAuth 2.0 的四种方式</a>阮大神的博客，系列作品</li>
</ul>
<h4 id="简介"><a class="header-anchor" href="#简介"></a>简介</h4>
<ul>
<li>
<p><code>OAuth 2.0</code>依赖于<code>TLS/SSL</code>的链路加密技术<code>HTTPS</code>。</p>
</li>
<li>
<p>完全放弃了签名的方式，认证服务器再也不返回什么<code>token</code>,<code>secret</code>的密钥了。</p>
</li>
<li>
<p><code>Auth 2.0</code>是完全不同于1.0 的，也是不兼容的.</p>
</li>
<li>
<p><code>Facebook</code>的<code>Graph API</code>只支持<code>OAuth 2.0</code>协议，<code>Google</code>和 <code>Microsoft Azure</code>也支持<code>Auth 2.0</code>，国内的微信和支付宝也支持使用<code>OAuth 2.0</code>。</p>
</li>
<li>
<p><code>OAuth2.0</code>一共有4个flow。在酷壳上面阐述了其中主要的两个flow。</p>
<pre><code>授权码（authorization-code）
隐藏式（implicit）
密码式（password）：
客户端凭证（client credentials）
</code></pre>
</li>
<li>
<p><code>OAuth</code> 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌，用来代替密码，供第三方应用使用。</p>
<ul>
<li>我们有<code>client</code>,<code>Authorization server</code>,<code>Resource owner</code>和<code>Resource server</code>。那么，对照起来，<code>client</code>是第三方应用，<code>Authorization server</code>是验证服务器， <code>Resource server</code>是资源服务器，也就是被访问的资源保存的地方。<code>Resource Owner</code>是终端用户。</li>
<li>比如说，我访问微信，微信要求登录，会将我的请求转到验证服务器上面，我通过验证，那么微信这个应用会从资源服务器上面获取资源，我作为终端用户就可以使用微信了。这里我就是<code>Resource Owner</code>, 微信是<code>client</code>。</li>
</ul>
</li>
</ul>
<h4 id="oauth2-0-详解"><a class="header-anchor" href="#oauth2-0-详解"></a>OAuth2.0 详解</h4>
<h5 id="authorization-code"><a class="header-anchor" href="#authorization-code"></a>Authorization Code</h5>
<ul>
<li>流程如下。感觉没啥好说的，整个流程挺清楚的。
<ul>
<li><em>不管哪种流程， 第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。应用自阮大神的博客</em></li>
<li><code>code</code>就是代表<code>authorization code</code>。</li>
<li><code>redirect_uri</code>意思是我跳转回第三方应用的地址</li>
<li><code>scope</code>是相关的权限</li>
<li><code>state</code> 是一个随机的字符串，主要用于防<code>CSRF</code>攻击。<code>CSRF - Cross-site request forgery</code>攻击，中文翻译是跨站请求伪造。</li>
<li><code>authorization server</code>返回<code>authorization code</code>时候，其实是带在<code>url</code>里面的。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/OAuth2.0/oauth2.0_authorization_code.png" alt="自己画的流程图"></p>
<ul>
<li>
<p><code>authorization code</code>的格式如下。里面的<code>state</code>和第一步里面的一样。</p>
<pre><code>  https://example-client.com/callback?
  code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
  &amp;state=xcoiv98CoolShell3kch
</code></pre>
</li>
<li>
<p><code>token</code>令牌的样式如下：</p>
</li>
</ul>
<ul>
<li>
<p><code>access_token</code>就是访问请求令牌了</p>
</li>
<li>
<p><code>refresh_token</code>用于刷新<code>access_token</code></p>
</li>
<li>
<p><code>id_token</code>是<code>JWT</code>的<code>token</code>，其中一般会包含用户的<code>OpenID</code></p>
<pre><code>{
    &quot;access_token&quot;: &quot;iJKV1QiLCJhbGciOiJSUzI1NiI&quot;,
    &quot;refresh_token&quot;: &quot;1KaPlrEqdFSBzjqfTGAMxZGU&quot;,
    &quot;token_type&quot;: &quot;bearer&quot;,
    &quot;expires&quot;: 3600,
    &quot;id_token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM...&quot;
}
</code></pre>
</li>
</ul>
<h5 id="client-credential-flow"><a class="header-anchor" href="#client-credential-flow"></a>Client Credential Flow</h5>
<ul>
<li>感觉这个不需要多写了。其实就是上面的流程中没有用户，就是没有<code>Resource Owner</code>。<code>client</code>直接拿自己的<code>clientId</code>和<code>client-secret</code>去做校验和授权了。</li>
</ul>
<h5 id="一些疑问"><a class="header-anchor" href="#一些疑问"></a>一些疑问</h5>
<p>OAuth2.0我还是有些疑问啊：</p>
<ul>
<li>为啥要在<code>token</code>里面带上<code>id_token</code>呢， 这不是暴露了嘛</li>
<li>如何使用<code>refresh_token</code>来刷新<code>access_token</code>呢。虽然很明显这个是一个可选项</li>
</ul>
<h4 id="实现"><a class="header-anchor" href="#实现"></a>实现</h4>
<ul>
<li>阮大神的博客里面还有一部分实现。我很惊讶的发现，哎哟喂，原来我在加博客的评论时候用了呀，<code>Oauth2.0</code> 😊 ,但是我当时URL乱填一气了。</li>
<li><em>所谓第三方登录，实质就是 OAuth 授权</em></li>
<li>参考链接：
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/github-oauth.html" target="_blank" rel="noopener">GitHub OAuth 第三方登录示例教程</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/08/13/Micro-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/08/13/Micro-Service/" class="post-title-link" itemprop="url">Micro Service</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-13 13:41:09" itemprop="dateCreated datePublished" datetime="2019-08-13T13:41:09+08:00">2019-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-28 16:37:31" itemprop="dateModified" datetime="2019-10-28T16:37:31+08:00">2019-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/08/13/Micro-Service/" class="post-meta-item leancloud_visitors" data-flag-title="Micro Service" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在学习一些<code>micro service</code>相关，记录在这里。<br>
现在都是说<code>micro service</code>，但是什么是<code>micro service</code>，可能不同的人有不同的定义，但是单纯地只是将软件部署到<code>docker</code>或者<code>k8s</code>上面去，可能并不完全符合<code>micro service</code>，所以学习一下。<br>
将一些学习到的tips和理念记录下来，最后形成自己的理解。<br>
学习了一阵，感觉还是不一样的，有一套架构体系的，记录在这里。</p>
<h3 id="什么是micro-service"><a class="header-anchor" href="#什么是micro-service"></a>什么是micro service</h3>
<ul>
<li>只占用需要的内存和处理器处理能力</li>
<li>如果是处理数据的，假设我们有一个处理inventory data的<code>micro service</code>，那么这个<code>micro service</code>仅仅需要在意inventory data。而不需要考虑其他数据的影响。</li>
<li><code>micro service</code>不受语言限制，不同语言的<code>micro service</code>仍旧可以联合起来的完成一个solution的</li>
</ul>
<h4 id="aws的理解"><a class="header-anchor" href="#aws的理解"></a>AWS的理解</h4>
<ul>
<li>
<p>参考链接：<a href="https://aws.amazon.com/microservices/" target="_blank" rel="noopener">AWS微服务理解</a></p>
</li>
<li>
<p>每个服务都是独立提供服务的模块，可以独立的开发、升级、部署和扩展</p>
</li>
<li>
<p>每个服务不应该和任何其他服务共享代码</p>
</li>
<li>
<p>服务间的任何交互都应该通过<code>API</code>来进行</p>
</li>
<li>
<p>每个服务都是</p>
</li>
</ul>
<h4 id="微软的理解"><a class="header-anchor" href="#微软的理解"></a>微软的理解</h4>
<ul>
<li>参考链接：<a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices" target="_blank" rel="noopener">微软文章</a></li>
</ul>
<h3 id="micro-service-combination"><a class="header-anchor" href="#micro-service-combination"></a>micro service combination</h3>
<ul>
<li><code>micro service</code>本身是一个<code>complete application</code>，它独立完成某个功能，可以有interface或者没有，可以访问数据库，也可以不访问。</li>
<li>很多<code>micro service</code>联合起来，成为一个solution。</li>
<li>默认只需要知道对方的<code>endpoint</code>就可以进行通信。其实不一定是<code>http</code>协议的，也有一些其他的很流行的总线方式。</li>
<li><strong><em>each micro service has to offer an API endpoint! 通常都是REST的endpoint，但是也可以是<code>wisdom endpoint</code></em></strong></li>
</ul>
<h3 id="micro-service特点"><a class="header-anchor" href="#micro-service特点"></a>micro service特点</h3>
<ul>
<li>增加了scalability。话说这个吧，其实很复杂。看我另外一篇博客。而且未必多加pod，能力就一定上升啊</li>
<li>从下面杂谈里面的几篇文章里面看起来，大家都认为<code>micro service</code>之后，模块之间基本是完全解耦的，大家都开开心心的全栈式就关心自己的模块，从需求到后期客户维护，完全自主，不用管其他模块。<em>A benefit of microservices is that each team can be responsible for releasing their services independently and without coordination with other teams.</em>
<ul>
<li>但是，这怎么可能啊。就我们自己的产品来说，尤其是那些<code>lib</code>库一样的模块，一升级，所有的都得动。没明白。没有明白呀。</li>
<li>除非所有的小模块都像个产品一样运营。比如提供安全管理功能的模块，剩下调用它的模块按照自己的需求进行升级。</li>
<li><strong><em>嗯，确实也是有产品这么做的，但是这样就会有很多资源消耗吧。这点在大牛的分享中也提及过，O&amp;M的功能是公用的，但是会占用资源。</em></strong></li>
<li><strong><em>但是如果大家都用同一份，谈什么微服务哦。那么<code>lib</code>库就不应该占用资源。或者占用资源的就不应该做成<code>lib</code>库？</em></strong></li>
<li><code>google</code>怎么做的？应该也是有不同的产品吧。</li>
</ul>
</li>
</ul>
<h4 id="优势"><a class="header-anchor" href="#优势"></a>优势</h4>
<ul>
<li>
<p>改动：一个微小的改动需要很多工作去做，一个微小的改动会影响很多部分，增加一个需要资源的模块，需要增加整个系统的资源，而不是只增加需要增加的部分</p>
</li>
<li>
<p>扩展：基本上就是指<code>load scalability</code>,在monolithich时代，扩展是扩展所有的模块，就是复制出新的一份系统来。而微服务时候，是扩展需要扩展的部分，这点很有优势</p>
<ul>
<li>所以从以上两点来说，一个微服务在部署和扩展上面，从业务角度来说，就是service角度来说，应该是独立的。<strong><em>那么反过来成立吗？就是说一个pod或者service，可以独立部署，独立扩展，但是并不能提供独立的服务，那么是不是边界定义得不对呢</em></strong></li>
<li><em>We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call.</em></li>
</ul>
</li>
<li>
<p>方便CI和CD</p>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices Architecture</a>:</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjEwNTEzOQ==&amp;mid=401500724&amp;idx=1&amp;sn=4e42fa2ffcd5732ae044fe6a387a1cc3#rd" target="_blank" rel="noopener">上一篇的中文翻译</a></li>
</ul>
</li>
</ul>
<h4 id="逆势"><a class="header-anchor" href="#逆势"></a>逆势</h4>
<p>微服务也是会有一些问题和难点的，比如：</p>
<ul>
<li>进程间通信会比进程内通信代价大很多，所以应该谨慎设计边界。<em>remote APIs need to be coarser-grained, which is often more awkward to use.</em> 不是很理解这句话</li>
<li>Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management. 所以嘛，我就说对技术人员的要求越发高了。虽说是team，但是这种team也很不好搭配的好不好。</li>
<li>并且这种方式，将团队和自己开发的产品绑在了一起。感觉回到了以模块来组织team的年代。实在是有利有弊。还有一个问题，按照现在推荐的，将一部分support的事务归到了技术团队里面，那么有向前延伸吗？话说薪水呢，得涨薪啊</li>
</ul>
<h3 id="微服务架构"><a class="header-anchor" href="#微服务架构"></a>微服务架构</h3>
<p>关于微服务架构的文章真是多如牛毛。一搜一大把。看了陈晧推荐的一篇据说入门级英文文章，确实清晰明了。话说很多中文翻译简直是惨不忍睹啊。真心惨不忍睹！</p>
<p>看了总觉得有有点心惊啊，从<code>warterful</code>到<code>agile</code>，从<code>monolithic</code>到<code>micro service</code>，对开发人员的要求是越来越高了啊。😦</p>
<p>还能不能愉快地做开发了啊？<br>
<em>The microservice approach to division is different, splitting up into services organized around business capability</em></p>
<p>还得有<code>business capability</code>，话说技术人员理解的<code>business capability</code>正确吗</p>
<h3 id="杂谈"><a class="header-anchor" href="#杂谈"></a>杂谈</h3>
<ul>
<li>
<p>早上无心工作，摸鱼酱油，看了几篇文章，觉得还不错。 😅 话说<code>InfoQ</code>就是做翻译工作的嘛，咋云计算那边全是翻译啊。</p>
</li>
<li>
<p><a href="https://medium.com/better-programming/how-microservices-architecture-impacted-the-culture-of-software-development-6bba363ecdf1" target="_blank" rel="noopener">How Microservices Architecture Impacted the Culture of Software Development</a>:</p>
<ul>
<li>这篇文章的观点很是不错，含义就是说写代码很有趣啊，想干嘛就干嘛，把自己脑子里面的想法实现出来。可是工作以后就郁闷了，全是些模糊的责任，规定好了的框架，规定好了的数据库，规定好了的语言。确实如此，一天天消磨了意志和能力</li>
<li>现在有了<code>micro service</code>，瞅着大家都挺开心的，有了这个鼓动，似乎乐趣又回来了一点，可以分为很小的<code>repo</code>，可以自行选择各种不同的语言和技术，然后一起做成为一个产品。甚至可以有产品和售后的职责。</li>
<li>嘛，文章最后还说，这个并不关<code>micro service</code>的关系，所谓的<code>monolithic</code>也应该可以做到。</li>
</ul>
</li>
<li>
<p><a href="https://medium.com/@steven.lemon182/why-our-team-cancelled-our-move-to-microservices-8fd87898d952" target="_blank" rel="noopener">Why our team cancelled our move to microservices</a></p>
<ul>
<li>原文很长，下面的评论也十分之多，实在不算一把头能看完的</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/08/02/TCP&UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/08/02/TCP&UDP/" class="post-title-link" itemprop="url">TCP UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-02 15:42:25" itemprop="dateCreated datePublished" datetime="2019-08-02T15:42:25+08:00">2019-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-20 11:15:59" itemprop="dateModified" datetime="2021-01-20T11:15:59+08:00">2021-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/08/02/TCP&UDP/" class="post-meta-item leancloud_visitors" data-flag-title="TCP UDP" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作中碰到<code>DNS</code>的本地端口的问题，就是<code>client</code>端的<code>port</code>，不是<code>DNS server</code>的端口。这个是默认开在<code>53</code>上面的。<br>
然后就研究了一下，写在这里。</p>
<h3 id="port-0"><a class="header-anchor" href="#port-0"></a>port 0</h3>
<ul>
<li>
<p>可用端口是<code>0 ~ 65535</code>。</p>
</li>
<li>
<p><code>0</code>的含义就是：分配一个随机的未被占用的端口。</p>
</li>
<li>
<p><code>65535</code> 事实上是会报错的，也是用不了的。</p>
</li>
<li>
<p>如果需要一个在一段范围内的端口，通常使用的方法，就是遍历，但是多线程情况下会出现线程竞争。并且很难避免。仔细看了一遍，好像并没有很好的提议。</p>
<pre><code>    private Integer findRandomOpenPortOnAllLocalInterfaces() throws IOException {
try (
    ServerSocket socket = new ServerSocket(0);
) {
  return socket.getLocalPort();
}
}
</code></pre>
</li>
<li>
<p><code>Spring</code>里面的<code>SocketUtil</code>的源码可以参考</p>
</li>
<li>
<p><code>ServerSocket</code>里面初始化时候其实是有两部的，第二部是<code>bind</code>，如果传<code>0</code>给构造函数，第二步时候才真正是分配的时候。</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36592572/article/details/82323100" target="_blank" rel="noopener">关于端口最大值65535的问题</a></li>
<li><a href="https://stackoverflow.com/questions/12889702/allowed-port-range-for-tcp" target="_blank" rel="noopener">Allowed Port Range for TCP</a></li>
<li><a href="https://stackoverflow.com/questions/115500/how-do-you-specify-a-port-range-for-java-sockets" target="_blank" rel="noopener">how-do-you-specify-a-port-range-for-java-sockets</a></li>
<li><a href="https://stackoverflow.com/questions/2675362/how-to-find-an-available-port" target="_blank" rel="noopener">how-to-find-an-available-port</a>: 这篇链接里面有大量讨论和实现。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/SocketUtils.html" target="_blank" rel="noopener">Class SocketUtils</a></li>
<li><a href="https://stackoverflow.com/questions/51099027/find-free-port-in-java" target="_blank" rel="noopener">find-free-port-in-java</a></li>
</ul>
</li>
</ul>
<h3 id="tcp-udp"><a class="header-anchor" href="#tcp-udp"></a>TCP &amp; UDP</h3>
<ul>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://stackoverflow.com/questions/12737293/how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind?rq=1" target="_blank" rel="noopener">how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind</a>: 里面有很多如何查找是哪个应用在占用端口的方法</li>
<li><a href="https://stackoverflow.com/questions/27730330/java-what-is-the-difference-between-serversocket-and-datagramsocket" target="_blank" rel="noopener">java-what-is-the-difference-between-serversocket-and-datagramsocket</a></li>
<li><a href="https://www.javaworld.com/article/2077322/core-java-sockets-programming-in-java-a-tutorial.html" target="_blank" rel="noopener">Sockets programming in Java</a></li>
</ul>
</li>
<li>
<p>这回犯一个低级错误。但是也是必然的，毕竟底层网络不够了解。</p>
</li>
<li>
<p>这次犯的错误是这样的，需要发现一个<code>free</code>的端口来建立<code>UDP</code>连接，于是就使用了<code>serverSocket</code> 来<code>check</code>端口，参考以上链接。</p>
</li>
<li>
<p>实际是，<code>TCP</code>和 <code>UDP</code> 需要使用不同的结构。ORZ。可见我的<code>java</code>基础和网络基础都很有点薄弱啊。对<code>socket</code>的理解也着实不灵啊。</p>
</li>
<li>
<p><code>UDP</code> 应当使用<code>DatagramSocket</code>结构来建。</p>
</li>
</ul>
<h4 id="udp"><a class="header-anchor" href="#udp"></a>UDP</h4>
<ul>
<li><code>UDP</code>的全称：<code>user datagram protocol</code>。</li>
<li>each time you send datagrams, you also need to send the local socket descriptor and the receiving socket’s address. As you can tell, additional data must be sent each time a communication is made.</li>
</ul>
<h4 id="tcp"><a class="header-anchor" href="#tcp"></a>TCP</h4>
<ul>
<li><code>TCP</code>的全称： <code>transfer control protocol</code></li>
<li>Once two sockets have been connected, they can be used to transmit data in both (or either one of the) directions.</li>
</ul>
<h4 id="when-is-udp-when-is-tcp"><a class="header-anchor" href="#when-is-udp-when-is-tcp"></a>When is UDP &amp; when is TCP</h4>
<ul>
<li><code>UDP</code>有数据大小限制，每次发的时候都要带上信息，不可靠，但是速度高。</li>
<li><code>TCP</code>是面向连接的，所以有建立连接时间。<strong><em>UDP也要建连接呀</em></strong> TCP的数据更像流，而不是一个个数据包，没有大小限制，可靠，但是速度慢很多。</li>
<li>TCP is useful for implementing network services – such as remote login (rlogin, telnet) and file transfer (FTP)</li>
<li>UDP is often used in implementing client/server applications in distributed systems built over local area networks.</li>
<li>一出杯具： 杯具的是，作为一个<code>bug</code>处理，在学习了一堆，并且记录了一堆之后，自我感觉良好的本人还是犯错了。因为，我们的产品里面不仅仅使用了<code>UDP</code>，还使用了<code>TCP</code>。嘿，我给漏掉了。</li>
<li>所以，就算协议学会了，明白了，也得清楚，实现不一定按规矩来的。毕竟都是人来做的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/07/26/Java-Remote-Debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/07/26/Java-Remote-Debug/" class="post-title-link" itemprop="url">Java Remote Debug</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-26 10:51:48" itemprop="dateCreated datePublished" datetime="2019-07-26T10:51:48+08:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-09 17:14:21" itemprop="dateModified" datetime="2019-08-09T17:14:21+08:00">2019-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/07/26/Java-Remote-Debug/" class="post-meta-item leancloud_visitors" data-flag-title="Java Remote Debug" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为Java程序员，不会remote debug，是不现实的。实际上，几年前也用过。但是悲催的是，再次要用的时候就搞不清了。<br>
现在还是k8s平台，端口映射就更复杂一点。三两下一绕就更不清楚了。所以还是先把remote debug搞清楚。<br>
再去绕端口号。</p>
<h3 id="什么是remote-debug"><a class="header-anchor" href="#什么是remote-debug"></a>什么是remote debug</h3>
<p>服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。</p>
<h3 id="怎么做remote-debug"><a class="header-anchor" href="#怎么做remote-debug"></a>怎么做remote debug</h3>
<h4 id="使用特定jvm参数运行服务端代码"><a class="header-anchor" href="#使用特定jvm参数运行服务端代码"></a>使用特定JVM参数运行服务端代码</h4>
<ul>
<li>不是说打包的时候，而是运行jar包的时候，java -jar带上需要的参数
<ul>
<li><code>address</code>是进行通信需要的端口。那么服务器端运行的程序会在这个端口上面开一个<code>socket</code></li>
<li><code>socket</code>比较好理解的，通信方式</li>
<li>所以之前进行debug mode的时候，肯定要改一下产品端module运行时候的JVM参数的</li>
</ul>
</li>
</ul>
<pre><code>-Xdebug -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=${debug_port}
</code></pre>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/wy2325/p/5600232.html" target="_blank" rel="noopener">IntelliJ远程调试教程</a></li>
</ul>
</li>
</ul>
<h4 id="在ide里面进行设置-本地连接远程服务器debug端口"><a class="header-anchor" href="#在ide里面进行设置-本地连接远程服务器debug端口"></a>在IDE里面进行设置，本地连接远程服务器debug端口</h4>
<ul>
<li>
<p>参考链接里面的设置方法，其实就配远程服务器的地址和debug 端口</p>
</li>
<li>
<p>还需要点击一下debug，让本地attach上去。</p>
</li>
</ul>
<h4 id="调试代码"><a class="header-anchor" href="#调试代码"></a>调试代码</h4>
<ul>
<li>这时候就可以进行remote debug了。打好断点，然后往服务器发送请求就可以了</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/07/19/ifconfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/07/19/ifconfig/" class="post-title-link" itemprop="url">network basic concept</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-19 10:21:25" itemprop="dateCreated datePublished" datetime="2019-07-19T10:21:25+08:00">2019-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-20 15:28:51" itemprop="dateModified" datetime="2021-01-20T15:28:51+08:00">2021-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/07/19/ifconfig/" class="post-meta-item leancloud_visitors" data-flag-title="network basic concept" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基础网络概念放在这里，在另一篇博客里面记录网络之间如何转发，从<code>IP</code>地址如何找到对应的主机进行通信。<br>
前后一年时间，这回大致是明白了。想当年大学时代，我网络学得不错的啊 😇</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://www.zhihu.com/question/49335649" target="_blank" rel="noopener">IP地址和MAC地址的区别和联系-这篇的第一个回答非常清晰</a></li>
<li><a href="https://www.zhihu.com/question/22007235" target="_blank" rel="noopener">如何跟小白解释路由器和交换机的区别</a></li>
<li><a href="https://www.zhihu.com/question/20465477" target="_blank" rel="noopener">路由器和交换机的不同之处有哪些？</a></li>
</ul>
<h2 id="网络常用语"><a class="header-anchor" href="#网络常用语"></a>网络常用语</h2>
<ul>
<li><code>LAN</code>：LAN，全称<code>Local Area Network</code>，中文名叫做局域网，一般是方圆几千米范围内。就是几公里内都可以。</li>
<li><code>WAN</code>：WAN，全称<code>Wide Area Network</code>，中文名叫做广域网，所覆盖的范围从几十公里到几千公里，因特网就是最大的广域网。</li>
<li><code>WLAN</code>：WLAN，全称<code>Wireless LAN</code>, 无线局域网。</li>
<li>从网上截了一张图片，可以看到路由器上面的各个接口。现在可能没有很单纯的交换机了，或者说一个设备上面既有交换机，又有路由器</li>
<li>参考链接
<ol>
<li><a href="https://blog.csdn.net/github_27263697/article/details/79482078" target="_blank" rel="noopener">LAN、WAN、WLAN的区别</a></li>
</ol>
</li>
</ul>
<h2 id="网络基础概念"><a class="header-anchor" href="#网络基础概念"></a>网络基础概念</h2>
<h3 id="网卡"><a class="header-anchor" href="#网卡"></a>网卡</h3>
<ul>
<li>真正解释网卡的文章几乎没有啊。看到有说网卡就是网络适配器的。然后一台电脑的<code>MAC地址</code>是在网卡上面的</li>
<li>网卡是一台电脑想要连接上互联网的必须设备，而网卡在出厂时候就有<code>MAC地址</code>，出厂时候烧制上去的</li>
<li>当接入网络的时候，网卡会按照<code>DHCP</code>工作，获得分配的<code>IP</code>地址</li>
</ul>
<h3 id="集线器"><a class="header-anchor" href="#集线器"></a>集线器</h3>
<ul>
<li>集线器也就是<code>HUB</code>，工作在物理层。</li>
<li>集线器顾名思义，有多个网口，那么就可以有多根网线，连接多个网络设备</li>
<li>形成一个以集线器为中心，向外发散的网络，最初的网络就诞生啦</li>
<li>集线器只能对信息进行广播，而不能指定发送方，这是集线器的弊端。这跟微信群一样，还不能@，喊一嗓子，大家都收到了。也就是小王妈喊小王吃饭，大家都知道哟，小王妈喊丫吃饭了。</li>
</ul>
<h3 id="数据链路层"><a class="header-anchor" href="#数据链路层"></a>数据链路层</h3>
<h4 id="物理地址-mac地址"><a class="header-anchor" href="#物理地址-mac地址"></a>物理地址(MAC地址)</h4>
<ul>
<li>什么是<code>MAC地址</code>？ MAC地址（<code>Media Access Control Address</code>，介质访问控制），直译为媒体访问控制地址，也称为局域网地址（<code>LAN Address</code>），以太网地址（<code>Ethernet Address</code>）或物理地址（<code>Physical Address</code>），它是一个用来确认网上设备位置的地址。</li>
<li>形象地说，<code>MAC地址</code>就如同身份证上的身份证号码，具有全球唯一性。</li>
<li><code>MAC地址</code>采用十六进制数表示，共六个字节（48位）。其中，前三个字节是由<code>IEEE</code>的注册管理机构<code>RA</code>负责给不同厂家分配的代码(高位24位），也称为“编制上唯一的标识符”，后三个字节(低位24位)由各厂家自行指派给生产的适配器接口（暂时理解成网卡应该是可以的），称为扩展标识符（唯一性）。</li>
<li><code>MAC地址</code>用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</li>
<li>参考链接
<ul>
<li><a href="https://zhidao.baidu.com/question/6331169.html" target="_blank" rel="noopener">百度知道的迅速概念</a></li>
<li><a href="https://www.zhihu.com/question/49335649" target="_blank" rel="noopener">IP地址和MAC地址的区别和联系-这篇的第一个回答非常清晰</a></li>
<li><a href="https://www.zhihu.com/question/21546408" target="_blank" rel="noopener">有了 IP 地址，为什么还要用 MAC 地址？</a></li>
</ul>
</li>
</ul>
<h4 id="交换机-switch"><a class="header-anchor" href="#交换机-switch"></a>交换机（Switch）</h4>
<ul>
<li>对比上面集线器，交换机工作是第二层，就是数据链路层</li>
<li>在集线器上面加上网口和设备的地址（形成了<code>MAC地址表</code>），集线器就进化成为了交换机</li>
<li>这样，集线器的缺点就被克服了。交换机可以按照地址发到相应的设备，而不是广播</li>
<li>这里涉及到__冲突域__这个专业名词，所谓的__冲突域__，就是在一个范围内，同时只能1个主机收发数据包，而集线器整机在1个冲突域，所以整机只能1个人发包。因为是广播消息，大家一起发就乱了</li>
</ul>
<h4 id="mac地址表"><a class="header-anchor" href="#mac地址表"></a>MAC地址表</h4>
<ul>
<li><code>MAC地址表</code>是二层设备中存储<code>MAC地址</code>和<code>转发端口</code>映射关系的表</li>
<li><code>MAC</code>地址其实就是网卡的地址，一个设备想要连接进网络，必须要有网卡，而网卡必须有地址，这样才能被网络上面的其他设备找寻到，这个地址就是<code>MAC</code>地址</li>
<li>那么一个局域网的交换机收到了一个<code>IP</code>地址，等转换为<code>MAC</code>地址，再转发出去。</li>
<li>交换机工作在数据链路层，隔离了冲突域，能够学习数据帧当中携带的<code>源MAC地址</code>来构建<code>MAC地址表</code>，同时负责查找目的<code>MAC地址</code>智能的转发数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/MAC_address_table.png" alt="MAC地址表"></p>
<p>图片来自<a href="https://zhuanlan.zhihu.com/p/139355604" target="_blank" rel="noopener">路由表、ARP表、MAC地址表</a></p>
<h3 id="网络层和应用层"><a class="header-anchor" href="#网络层和应用层"></a>网络层和应用层</h3>
<h4 id="ip地址"><a class="header-anchor" href="#ip地址"></a>IP地址</h4>
<ul>
<li>主要的参考链接仍旧是上面知乎上的一篇。里面的回答非常清晰</li>
<li>网络上面关于<code>IP</code>地址，<code>MAC</code>地址的解释很多，有说<code>IP</code>是门牌地址，<code>MAC</code>是身份证号，乍一看似乎明白了，但是仍旧不清晰，很多事物的来源是有历史原因的。</li>
<li>在最早的时候是没有因特网的，只有以太网。当然，最早的是电话网络，物理网线的那个网络。</li>
<li>以太网是目前常用的局域网的技术，对应于数据链路层。同层的有令牌环(这个我印象深刻啊)，还有<code>ATM</code>技术。在以太网里面，使用的是<code>MAC</code>地址。</li>
<li>而后来出现了互联网，将各个局域网给连接起来，这时候，<code>MAC</code>地址的局限性就出现了，毕竟设计最初就是局域网用的，不可能让每个交换机记录世界上所有的<code>MAC</code>地址。</li>
<li>于是互联网中引入了<code>IP</code>地址。<code>IP</code>地址是因特网（因特网协议就是<code>TCP/IP</code>）的概念，而因特网本身设计时候就是以连接多个以太网为目的的，所以因特网并不考虑数据链路层和物理层的内容。</li>
<li><code>IP</code>地址就是帮着客户在多个以太网中间转发，在以太网内部，就是<code>MAC</code>地址的事情了。</li>
<li>当然，因特网也可以架构在其他类型的局域网之上，例如令牌环网。</li>
<li><code>IP地址</code>可以分为私有和公有。私有一般用于局域网，公有用于广域网，真正在上网过程中，需要通过<code>NAT</code>从<code>私有IP</code>转为<code>公有IP</code>。</li>
<li>这也是为啥要引入<code>IPV6</code>吧，毕竟设备越来越多，<code>IP</code>不够用了</li>
</ul>
<h4 id="路由器-router"><a class="header-anchor" href="#路由器-router"></a>路由器（Router）</h4>
<ul>
<li>路由器的主要功能就是实现局域网之间的互联，这个已经很明确了。还有其他功能：
<ul>
<li>路由器可以给你的局域网自动分配<code>IP</code></li>
<li>路由器可以把一个<code>IP</code>分配给很多个主机使用，这些主机对外只表现出一个<code>IP</code>。</li>
<li>路由器提供防火墙的服务，交换机不能提供该功能，看有些说交换机也可以有这个功能，但是需要更好的硬件</li>
<li>路由要最短路径送报文，交换要快速转发提高吞吐量。</li>
</ul>
</li>
<li>路由器完全可以用软件来实现，看有的文章是这样，当然，也可能是文章没弄清楚。</li>
<li>路由器有一个<code>MAC地址</code>，还有<code>IP地址</code></li>
<li>通常说网关网关，也就是路由器。<code>TCP/IP</code>协议会根据子网掩码来判定两个网络中的主机是不是处在不同的网络里</li>
<li><strong>网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</strong><br>
<a href="https://blog.csdn.net/yuanbinquan/article/details/52963845" target="_blank" rel="noopener"> IP + Netmask + Gateway + DNS</a></li>
</ul>
<h4 id="arp缓存表"><a class="header-anchor" href="#arp缓存表"></a>ARP缓存表</h4>
<ul>
<li>
<p><code>ARP缓存表</code>是本地用来存储<code>IP地址</code>和<code>MAC地址</code>的对应关系的表</p>
</li>
<li>
<p>是有时效性的，当一台主机A尝试与主机B通信，在获得主机B的MAC地址之后，就会将这个寸在本地的<code>ARP缓存表</code>里面。</p>
</li>
<li>
<p>如果电脑或者通信设备重启的话，这张表就会清空</p>
</li>
<li>
<p>使用<code>arp -a</code>可以查询本地的<code>ARP缓存表</code>，如下：</p>
<pre><code>$ arp -a
Interface: 10.0.75.1 --- 0x7
Internet Address      Physical Address      Type
xxxxx                 xxxxx                 static
</code></pre>
</li>
</ul>
<h3 id="子网掩码"><a class="header-anchor" href="#子网掩码"></a>子网掩码</h3>
<ul>
<li>
<p>发现还是不懂，重新回来补课。<code>IPv6</code>中没有子网掩码的概念，也没有网络号与主机号的概念</p>
</li>
<li>
<p>子网掩码(<code>subnet mask</code>)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个<code>IP地址</code>的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
</li>
<li>
<p>子网掩码不能单独存在，它必须结合<code>IP地址</code>一起使用。</p>
</li>
<li>
<p>子网掩码只有一个作用，就是将某个<code>IP地址</code>划分成网络地址和主机地址两部分。只有网络标识相同的两台主机在无路由的情况下才能相互通信</p>
</li>
<li>
<p>子网掩码是一个<code>32</code>位地址，用于屏蔽<code>IP地址</code>的一部分以区别网络标识和主机标识，并说明该<code>IP地址</code>是在局域网上，还是在远程网上。</p>
</li>
<li>
<p>网络地址对应的位都是1，对应主机位置的都是0。比如有个地址<code>192.168.10.10 AND 255.255.255.0</code>，那么该<code>IP地址</code>属于 <code>192.168.10.0</code>这个网络，其主机号为<code>10</code></p>
</li>
<li>
<p>几类网络地址如下：</p>
<pre><code>类别	子网掩码的二进制数值	子网掩码的十进制数值
 A	11111111 00000000 00000000 00000000	255.0.0.0
 B	11111111 11111111 00000000 00000000	255.255.0.0
 C	11111111 11111111 11111111 00000000	255.255.255.0
</code></pre>
</li>
<li>
<p>子网掩码给局域网提供了一种方式去进一步划分网络。具体实际中如何应用，还需进一步学习。看下面的例子就比较清楚了。</p>
</li>
<li>
<p>计算稍微有点绕，看知乎上面的比喻比较清楚，举例：</p>
<ul>
<li>
<p>比如我们申请到的网络号为 <code>210.73.a.b</code>，该网络地址为c类IP地址，网络标识为<code>210.73.a</code>，主机标识是<code>b</code>。也就是说前三位是固定的，不可改变的，但是最后一个数字是可以改变，作为局域网里面的主机标示。</p>
</li>
<li>
<p>假设需要16个子网。那么就需要四位来变化，<code>2</code>的四次方嘛，就是<code>0000</code>到<code>1111</code>，每个子网里面的主机数目其实是固定的。第一个子网就是从<code>00000000</code>到<code>00001111</code></p>
</li>
<li>
<p>然后c类地址的最后一位是主机标识。那么就是<code>11110000</code>.前四位代表子网，后四位代表主机名。最后掩码是<code>255.255.255.240</code>。也可以写成<code>210.73.a.0/28</code></p>
</li>
<li>
<p>28代表28个1</p>
</li>
<li>
<p>再看知乎的例子，<code>192.168.1.x</code>分成4个子网。那么就是<code>11111111,11111111,11111111,11000000</code>， 所以第一个子网就是<code>192.168.1.0/26</code></p>
</li>
<li>
<p>看<code>IP地址</code>的话就是，这四个网段的开头就是：</p>
<pre><code>192.168.1. 00 000000 --&gt; 00 111111 
192.168.1. 01 000000 --&gt; 01 111111
192.168.1. 10 000000 --&gt; 10 111111
192.168.1. 11 000000 --&gt; 11 111111
</code></pre>
</li>
</ul>
</li>
<li>
<p>参考链接</p>
</li>
</ul>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener">百度百科的解释</a></li>
<li><a href="https://www.zhihu.com/question/56895036" target="_blank" rel="noopener">知乎问答</a></li>
</ul>
<h3 id="广播地址"><a class="header-anchor" href="#广播地址"></a>广播地址</h3>
<ul>
<li><code>Broadcast Address</code>(广播地址)是专门用于同时向网络中所有工作站进行发送的一个地址。</li>
<li>在使用<code>TCP/IP</code>协议的网络中，主机标识段<code>host ID</code>为全<code>1</code>的IP 地址为广播地址，广播的分组传送给<code>host ID</code>段所涉及的所有计算机。例如，对于<code>10.1.1.0</code> （<code>255.255.255.0</code> ）网段，其广播地址为<code>10.1.1.255</code> （<code>255</code> 即为二进制的<code>11111111</code>），当发出一个目的地址为<code>10.1.1.255</code>的分组（封包）时，它将被分发给该网段上的所有计算机。</li>
</ul>
<h2 id="ifconfig"><a class="header-anchor" href="#ifconfig"></a>ifconfig</h2>
<p>这个命令是<code>linux</code>的</p>
<h3 id="ifconfig命令输出详解"><a class="header-anchor" href="#ifconfig命令输出详解"></a>ifconfig命令输出详解</h3>
<ul>
<li><code>eth0</code> --&gt; 网卡</li>
<li><code>HWaddr</code> --&gt; MAC</li>
<li><code>inet addr</code> --&gt; internal address, IP</li>
<li><code>Bcast</code> --&gt; 广播地址</li>
<li><code>Mask</code> --&gt; 子网掩码</li>
<li><code>Link encap</code> --&gt; 网络类型为以太网，这里也可能出现其他类型。比如 <code>Local Loopback</code></li>
</ul>
<pre><code>[root@linuxchao ~]# ifconfig
eth0 Link encap:Ethernet HWaddr 00:03:0D:27:86:41
inet addr:192.168.1.86 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::203:dff:fe27:8641/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:618 errors:0 dropped:0 overruns:0 frame:0
TX packets:676 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:491238 (479.7 KiB) TX bytes:86286 (84.2 KiB)
Interrupt:5 Base address:0x8c00
</code></pre>
<ul>
<li>参加链接
<ul>
<li><a href="http://c.biancheng.net/view/797.html" target="_blank" rel="noopener">Linux ifconfig命令：配置网络接口</a></li>
</ul>
</li>
</ul>
<h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2>
<h4 id="socket和connnection"><a class="header-anchor" href="#socket和connnection"></a><code>Socket</code>和<code>Connnection</code></h4>
<ul>
<li>一个<code>IP</code>地址加一个传输层端口号定义一个<code>socket</code>。</li>
<li><code>socket</code>是唯一的，一个客户端<code>socket</code>和一个服务端<code>socket</code>定义一个连接<code>connection</code>，一端发送的数据，另一端就会接收到 。来自 <a href="http://arthurchiao.art/blog/nat-zh/" target="_blank" rel="noopener">[译]NAT - 网络地址转换</a></li>
<li><code>raw socket</code>和<code>direct socket</code>，在工作中碰到这两个词，简直是一脸懵，后来发现是同一个含义，就是指直接打开<code>TCP</code>连接。目前看起来，只能用代码来开一个<code>raw socket</code>。</li>
<li><em>If you are interested in writing your own implementations of one of these protocols, or need to use a different transport-layer protocol, you’ll need to use raw sockets.</em> <code>raw socket</code>可以自己做个<code>protocal</code>，不用<code>TCP</code>或者<code>UDP</code></li>
<li>过程中看到几篇有趣文章，看得不够细致。链接先贴着 ❤️
<ul>
<li><a href="https://squidarth.com/networking/systems/rc/2018/05/28/using-raw-sockets.html" target="_blank" rel="noopener">using-raw-sockets</a></li>
<li><a href="https://stackoverflow.com/questions/5476112/raw-socket-question-are-tcp-packets-passed-to-a-raw-socket" target="_blank" rel="noopener">Are TCP packets passed to a raw socket?</a></li>
<li><a href="https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/" target="_blank" rel="noopener">a-guide-to-using-raw-sockets</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/07/09/DNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/07/09/DNS/" class="post-title-link" itemprop="url">DNS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-09 15:35:36" itemprop="dateCreated datePublished" datetime="2019-07-09T15:35:36+08:00">2019-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-19 17:30:29" itemprop="dateModified" datetime="2021-01-19T17:30:29+08:00">2021-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/07/09/DNS/" class="post-meta-item leancloud_visitors" data-flag-title="DNS" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2>
<p>工作中要用到<code>DNS</code>协议，需要学习一下，省得碰到的时候每次都要再看一遍。 <code>DNS</code>也是<code>TCP/IP</code>里面的一个基础协议。所以也会涉及到一些<code>TCP/IP</code>协议的部分。<br>
话说一个简单的<code>DNS</code>协议也有一堆可以写啊。不容易啊。</p>
<h3 id="dns在tcp-ip协议里的位置"><a class="header-anchor" href="#dns在tcp-ip协议里的位置"></a>DNS在TCP/IP协议里的位置</h3>
<ul>
<li>从参考链接名就能看出来，<code>DNS</code>是应用层的协议</li>
<li><code>TCP/IP</code>是四层。<code>OSI</code>是7层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/network_layer.png" alt=""></p>
<blockquote>
<p>图片来自参考链接1</p>
</blockquote>
<ul>
<li>参考链接：
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1023700" target="_blank" rel="noopener">TCP/IP（六）应用层（DNS和HTTP协议）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1358564" target="_blank" rel="noopener">DNS协议入门</a></li>
<li><a href="https://cloud.tencent.com/developer/information/dns%E7%9A%84%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">DNS协议栈</a></li>
</ul>
</li>
</ul>
<h3 id="概述"><a class="header-anchor" href="#概述"></a>概述</h3>
<ul>
<li><code>Domain Name System</code> 域名系统。也可以叫做域名解析协议。</li>
<li>简单的解释就是DNS协议会把网址，比如将<code>sallyslove.github.io/hexo_blog</code>的域名转换成为计算机能够理解的32位的IP，发到网络层去。</li>
<li>域名和IP的对应关系保存在一个叫<code>hosts</code>文件中。最初，通过互联网信息中心来管理这个文件，如果有一个新的计算机想接入网络，或者某个计算<code>IP</code>变更都需要到信息中心申请变更<code>hosts</code>文件。其他计算机也需要定期更新，才能上网。但是这样太麻烦了，就出现了<code>DNS</code>系统。</li>
<li>其实我们现在的电脑上面也是有这个文件的，就是<code>/window/systems/drivers/etc</code>下面也有<code>hosts</code>文件。注释里面很清楚写着，这个文件“used by Microsoft TCP/IP for Windows.”</li>
<li>目前的<code>DNS</code>系统中，如果有<code>hosts</code>文件，仍旧会优先查询这个文件的</li>
</ul>
<h3 id="流程"><a class="header-anchor" href="#流程"></a>流程</h3>
<ul>
<li>过程相当的简单明了啊。客户端发消息给域名解析服务器，服务器在自己里面一顿找，有就直接返回</li>
<li>没有就去根服务器找，根服务器找了之后会存到低一次没找到的域名解析服务器进行缓存。</li>
<li>再去找的时候就从缓存里面直接拿。不需要再去根服务器跑一趟了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DNS_procedure.png" alt=""></p>
<blockquote>
<p>图片来自参考链接1</p>
</blockquote>
<h3 id="详解"><a class="header-anchor" href="#详解"></a>详解</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825" target="_blank" rel="noopener">DNS（域名解析协议）详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1358564" target="_blank" rel="noopener">DNS 协议入门</a></li>
</ul>
</li>
</ul>
<h4 id="域名"><a class="header-anchor" href="#域名"></a>域名</h4>
<p>好吧，要了解<code>DNS</code>协议，首先要了解域名。各种域名都隶属于域名系统根域的下级。</p>
<ul>
<li>域名是分层次的。第一级域名，比如<code>com</code>，代表公司，这是<code>company</code>的缩写吧。再比如<code>org</code>,嗯，我看出来了，<code>organization</code>的开头。net网络提供商。大家有严格遵守吗?</li>
<li>第二级域名其实是公司名，比如<code>baidu，bing</code>。微软为啥叫<code>bing</code>啊。</li>
<li>对应不同层级的域名，有相应的服务器。根域名服务器之类。每一级域名服务器都知道下级域名服务器的<code>IP</code>地址。这个按照上面的流程也能知道。应该下层也知道上一层的地址，不然没法求助啊。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/DNS_domain_name.png" alt=""></p>
<blockquote>
<p>图片来自上面的参考链接1</p>
</blockquote>
<h4 id="协议"><a class="header-anchor" href="#协议"></a>协议</h4>
<ul>
<li><code>DNS</code>占用<code>53</code>号端口，同时使用<code>TCP</code>和<code>UDP</code>协议。那么<code>DNS</code>在什么情况下使用这两种协议？<code>DNS</code>在区域传输的时候使用<code>TCP</code>协议，其他时候使用<code>UDP</code>协议。</li>
<li>上面提到不同层级的域名会有不同层级的域名服务器来对应，每一层级也有主副服务器，辅助服务器与主服务器会进行同步，这个时候会用<code>TCP</code>协议，大批量数据传输，<code>TCP</code>是相对稳定的链接</li>
<li>而客户端向域名服务器查询时候用的是<code>UDP</code>协议， 效率更高，不需要经过三次握手</li>
</ul>
<h4 id="实现"><a class="header-anchor" href="#实现"></a>实现</h4>
<ul>
<li><code>dnsjava</code>是DNS的一个Java实现。这是一个3pp。还有其他一些实现，比如<code>dns4j</code>，<code>dnsjnio</code>，<code>jdnss</code>,<code>eagledns</code>。</li>
<li>要打开dnsjava的log，需要将设置<code>System.setProperty(&quot;dnsjava.options&quot;,&quot;verbose&quot;);</code> 这种操作也真是比较老了。</li>
<li>maven dependency是以下这样。</li>
</ul>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;dnsjava&lt;/groupId&gt;
   &lt;artifactId&gt;dnsjava&lt;/artifactId&gt;
   &lt;version&gt;2.1.7&lt;/version&gt;
</code></pre>
<ul>
<li><code>dnsjava</code>类图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/dnsjava_class_diagram.png" alt=""></p>
<ul>
<li>
<p><code>dnsjava</code> 流程图<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/dnsjava_sequence_diagram.png" alt=""></p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/zhu_tianwei/article/details/45128537" target="_blank" rel="noopener">DNS BIND之dnsjava java客户端操作</a></li>
</ul>
</li>
</ul>
<h4 id="使用"><a class="header-anchor" href="#使用"></a>使用</h4>
<ul>
<li><code>lookup</code>遇到错误<code>network error</code>，这个是因为在以下原因。 其实我碰到的就是<code>BindException</code>，<code>address already in use</code></li>
<li>参考链接：
<ul>
<li><a href="https://coderanch.com/t/585844/java/org-xbill-DNS-Lookup-error" target="_blank" rel="noopener">org.xbill.DNS.Lookup() error.</a></li>
<li><a href="https://github.com/dnsjava/dnsjava/issues/71" target="_blank" rel="noopener">我自己报的issue</a></li>
<li><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.xbill.DNS.ExtendedResolver" target="_blank" rel="noopener">Java Code Examples for org.xbill.DNS.ExtendedResolver</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/06/25/Cassandra_Maintain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/06/25/Cassandra_Maintain/" class="post-title-link" itemprop="url">Cassandra Maintain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-25 17:01:57" itemprop="dateCreated datePublished" datetime="2019-06-25T17:01:57+08:00">2019-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 16:24:25" itemprop="dateModified" datetime="2021-02-22T16:24:25+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/06/25/Cassandra_Maintain/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra Maintain" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://thelastpickle.com/blog/2016/07/27/about-deletes-and-tombstones.html" target="_blank" rel="noopener">关于Cassandra的删除和墓碑</a></li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html#defragmentation" target="_blank" rel="noopener">最新官方文档，非常清楚</a></li>
<li><a href="https://zhaoyanblog.com/archives/966.html" target="_blank" rel="noopener">有上篇文章的翻译</a></li>
<li><a href="https://www.cnblogs.com/didda/p/4728588.html" target="_blank" rel="noopener">Cassandra 的压缩策略STCS，LCS 和 DTCS</a></li>
</ul>
<h2 id="delete-data"><a class="header-anchor" href="#delete-data"></a>Delete Data</h2>
<ul>
<li>找了一下博客，发现居然都没有一个章节是关于删除数据的</li>
<li>事实上，<code>Cassandra</code>里面的删除是一种写操作，会插入墓碑。在上面的参加链接里面详尽描述了这个过程</li>
<li>可以使用<code>SSTabledump</code>命令来进行查询。<strong><em>但是并没有在我们的环境中找到这个命令</em></strong></li>
<li>需要注意的是这里讨论的都是删除之后再<code>flush</code>到<code>SSTable</code>里的情况，<code>Memtable</code>里面的数据删除会有所不痛</li>
<li><code>gc_grace_seconds</code>：在删除数据之后会保存一段时间的墓碑，以此来保证数据同步。</li>
</ul>
<h3 id="删除某一行的某个数据"><a class="header-anchor" href="#删除某一行的某个数据"></a>删除某一行的某个数据</h3>
<ul>
<li>
<p>可以只删除某一行的某一个数据，如下</p>
</li>
<li>
<p>当删除掉某一行的某个数据的时候，使用上面的<code>SSTabledump</code>命令，这一行数据将没有<code>liveness_info</code></p>
<pre><code>DELETE crates FROM tlp_lab.tombstones WHERE fruit='apple' AND date ='20160617';
</code></pre>
</li>
</ul>
<p>那么这个数据会显示<code>null</code></p>
<pre><code>  alain$ echo &quot;SELECT * FROM tlp_lab.tombstones LIMIT 100;&quot; | cqlsh
  fruit   | date     | crates
  ---------+----------+-----------------
  apple | 20160617 |            null
</code></pre>
<h3 id="删除一行的数据"><a class="header-anchor" href="#删除一行的数据"></a>删除一行的数据</h3>
<ul>
<li>
<p>删除掉一行之后，这一行的数据的<code>cell</code>也将没有任何数据</p>
<pre><code>&quot;rows&quot; : [
{
  &quot;type&quot; : &quot;row&quot;,
  &quot;position&quot; : 19,
  &quot;clustering&quot; : [ &quot;20160617&quot; ],
  &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:31:41.142454Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:31:41Z&quot; },
  &quot;cells&quot; : [ ]
}

&quot;rows&quot; : [
{
  &quot;type&quot; : &quot;row&quot;,
  &quot;position&quot; : 125,
  &quot;clustering&quot; : [ &quot;20160616&quot; ],
  &quot;liveness_info&quot; : { &quot;tstamp&quot; : &quot;2016-06-16T18:52:41.903751Z&quot;, &quot;ttl&quot; : 2592000, &quot;expires_at&quot; : &quot;2016-07-16T18:52:41Z&quot;, &quot;expired&quot; : false },
  &quot;cells&quot; : [
    { &quot;name&quot; : &quot;crates&quot;, &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T18:52:41.903750Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T18:52:41Z&quot; } },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;6&quot; ], &quot;value&quot; : &quot;&quot; },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;7&quot; ], &quot;value&quot; : &quot;&quot; },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;8&quot; ], &quot;value&quot; : &quot;&quot; }
  ]
}
</code></pre>
</li>
</ul>
<h3 id="删除一个范围内的数据"><a class="header-anchor" href="#删除一个范围内的数据"></a>删除一个范围内的数据</h3>
<ul>
<li>
<p>这个含义就是，比如下面的命令，这样可以一次性删除好几行数据</p>
<pre><code>DELETE FROM tlp_lab.tombstones WHERE fruit='apple' AND date &gt; '20160615';
</code></pre>
</li>
<li>
<p>那么存下来的数据会变为，<code>type</code>变化了</p>
<pre><code>&quot;rows&quot; : [
    {
      &quot;type&quot; : &quot;range_tombstone_bound&quot;,
      &quot;start&quot; : {
        &quot;type&quot; : &quot;exclusive&quot;,
        &quot;clustering&quot; : [ &quot;20160615&quot; ],
        &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:53:21.133300Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:53:21Z&quot; }
      }
    },
    {
      &quot;type&quot; : &quot;range_tombstone_bound&quot;,
      &quot;end&quot; : {
        &quot;type&quot; : &quot;inclusive&quot;,
        &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:53:21.133300Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:53:21Z&quot; }
      }
</code></pre>
</li>
</ul>
<h3 id="删除一个partition的数据"><a class="header-anchor" href="#删除一个partition的数据"></a>删除一个partition的数据</h3>
<ul>
<li>
<p>命令如下：</p>
<pre><code>DELETE FROM tlp_lab.tombstones WHERE fruit='pickles';
</code></pre>
<p>会在<code>partition</code>的地方加入<code>deletion_info</code>，而通常情况下只有<code>key</code>和<code>position</code></p>
<pre><code>{
  &quot;partition&quot; : {
    &quot;key&quot; : [ &quot;pickles&quot; ],
    &quot;position&quot; : 0,
    &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-17T09:38:52.550841Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-17T09:38:52Z&quot; }
}
  
&quot;partition&quot; : {
   &quot;key&quot; : [ &quot;apple&quot; ],
   &quot;position&quot; : 0
},  
</code></pre>
</li>
</ul>
<h3 id="集合数据"><a class="header-anchor" href="#集合数据"></a>集合数据</h3>
<ul>
<li>需要额外注意的一点是，如果使用集合数据，比如<code>list</code>，那么在更新的时候，会有一个潜在的删除操作。会将旧的数据删除，这一点非常恼人，需要注意</li>
</ul>
<h3 id="gc-grace-seconds参数"><a class="header-anchor" href="#gc-grace-seconds参数"></a>gc_grace_seconds参数</h3>
<ul>
<li><code>gc_grace_seconds</code>参数的默认值为10天，这个参数的意思就是这个数据被删除之后，相应的<code>tombstone</code>也不会立刻在<code>compaction</code>中被移除</li>
<li>这个值的目的是为了保证删除的一致性。以防有的节点上面删除失败，出现幽灵数据。在维护操作章节中有进一步的解释。假设有删除失败，然后客户做了<code>repair</code>操作，那么这个数据会被复制到已经删除的节点上面。那么就错了。相反，如果是插墓碑，即使有节点没插上，<code>repair</code>的时候也只会复制个墓碑过去。这也就是为什么需要需要维持一阵墓碑</li>
</ul>
<h2 id="维护操作"><a class="header-anchor" href="#维护操作"></a>维护操作</h2>
<ul>
<li><code>minor compaction</code>: 这个就是<code>C#</code>自己做的压缩</li>
<li><code>major compaction</code>: 这个就是手动的用<code>nodetool</code>做的，会对所有的当前<code>node</code>上面的<code>SSTable</code>进行压缩</li>
<li><code>user defined compaction</code>： 客户自定义的，对部分<code>SSTable</code>进行压缩。用户可以只针对一张表来做压缩，Cassandra会对数据进行校验，使用<code>unchecked_tombstone_compaction</code> 参数可以跳过这个校验过程</li>
<li><code>Scrub</code>: 这个操作会尝试修复<code>SSTable</code>，所以这个动作有可能会删除有效但是已经坏掉的数据，如果这个发生，得用<code>repair</code>来修复</li>
<li>在以下的参考链接里面还有一些奇特的维护操作，暂时没学习</li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html" target="_blank" rel="noopener">维护操作和压缩</a></li>
</ul>
<h2 id="compacting-sstable-data"><a class="header-anchor" href="#compacting-sstable-data"></a>Compacting SSTable Data</h2>
<p><img src="https://docs.datastax.com/en/cassandra/3.0/cassandra/images/dml_compaction.png" alt="官网压缩数据图片"></p>
<h3 id="为什么需要compaction"><a class="header-anchor" href="#为什么需要compaction"></a>为什么需要Compaction</h3>
<ul>
<li><code>cassandra</code>并不会删除数据。当需要<code>update</code>一个数据的时候，也不是在<code>SSTable</code>里面进行覆盖，而是会插入一个新的数据，带上新的<code>version</code>。</li>
<li>这样做的话，<code>cassandra</code>写入数据会非常快，因为不需要查询，但是弊端就是会有越来越多的数据。</li>
<li>这个时候就需要进行<code>compaction</code>。</li>
</ul>
<h3 id="什么是compaction"><a class="header-anchor" href="#什么是compaction"></a>什么是Compaction</h3>
<ul>
<li>To keep the multiple versions of the SSTables from overwhelming it, the database merges SSTables on a regular basis to get rid of the older versions of the data。 <code>cassandra</code>会在一个基础之上对旧的版本的数据进行合并，这个就是<code>compaction</code></li>
<li><code>cassandra</code>默认会进行很多次小的<code>compaction</code>。在有新生成<code>SStable</code>的时候，或者默认5分钟会进行一次检查，需不需要进行<code>minor compaction</code></li>
<li>会合并同一行的，不同版本的数据。不同版本带着不同的<code>timestamp</code></li>
</ul>
<h3 id="什么情况下墓碑会在compaction中被移除"><a class="header-anchor" href="#什么情况下墓碑会在compaction中被移除"></a>什么情况下墓碑会在Compaction中被移除</h3>
<ul>
<li>这也是来自上篇参考文档的。这篇文档比较清楚</li>
<li>事实上有好几个要求：
<ul>
<li><code>gc_grace_seconds</code> 已经过了，这点已经在上面解释过了</li>
<li>_If partition X contains the tombstone, the sstable containing the partition plus all sstables containing data older than the tombstone containing X must be included in the same compaction. We don’t need to care if the partition is in an sstable if we can guarantee that all data in that sstable is newer than the tombstone. If the tombstone is older than the data it cannot shadow that data._这句话实在太拗口了，含义就是说墓碑得是最老的一个，否则删除不掉？</li>
<li><code>only_purge_repaired_tombstones</code> 这还有一个参数，如果不是repair过程中的墓碑就不删除。这个参数估计很少用吧</li>
<li>还有一个特殊情况，就是整个<code>SSTable</code>里面都是墓碑，这种情况在以时间序列的表并且使用了<code>TTL</code>之后很容易出现。如果没有被整表删除，那么就像上一个bullet里面讲的，说明其他表里面有更老的数据。有一个工具<code>sstableexpiredblockers</code>可以进行查询。还有一个参数可以使用<code>unsafe_aggressive_sstable_expiration</code>，在使用时间压缩策略时候，这个参数可以保证删除这种表</li>
</ul>
</li>
</ul>
<h3 id="compaction的参数和命令"><a class="header-anchor" href="#compaction的参数和命令"></a>compaction的参数和命令</h3>
<ul>
<li>在上篇链接中有，列一部分：
<ul>
<li><code>log_all</code>: 可以记录压缩的日志</li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html" target="_blank" rel="noopener">维护操作和压缩</a></li>
</ul>
</li>
<li>命令在上面的链接中也有，这边也列一部分：
<ul>
<li><code>compactionstats</code>: 状态</li>
<li><code>compactionhistory</code>: 历史</li>
</ul>
</li>
<li>如果是在一个正在运行的系统中改变表的参数，可以使用<code>ALTER TABLE</code>命令来进行</li>
</ul>
<h3 id="其他一些campaction细节"><a class="header-anchor" href="#其他一些campaction细节"></a>其他一些Campaction细节</h3>
<ul>
<li>在<code>compaction</code>期间，<code>cassandra</code>会合并<code>key</code>和<code>column</code>，同时会将过期的墓碑删除，还会生成一个新的<code>index</code>？ <strong><em>这个index是什么东西啊</em></strong></li>
<li>合并之后会生成一个新的<code>SSTable</code>。而不需要的数据版本和行就会留在旧的<code>SSTable</code>里面，当正在执行的读操作结束之后，就可以删除掉。</li>
<li><code>compaction</code>期间的资源耗用会上升，但是<code>compaction</code>结束之后应该会释放空间，因为它合并了<code>SSTable</code></li>
<li>旧的被合并的<code>table</code>会被加上<code>deletion</code>标签，并且在数据库重启或者在使用<code>reference counting mechanism</code>的时候。<strong><em>这个<code>reference counting mechanism</code>是什么啊</em></strong></li>
<li><code>compaction</code>的算法是可以配置的，默认的是<code>size-tiered compaction</code>。这个算法会合并大小相近的table，生成大table</li>
</ul>
<h3 id="compaction对读数据的影响"><a class="header-anchor" href="#compaction对读数据的影响"></a>Compaction对读数据的影响</h3>
<ul>
<li><code>compaction</code>是<code>per-node</code>的，所以某个数据在<code>node1</code>上面的旧版本可能删除了。但是在<code>node2</code>上面还有。</li>
<li>这样读的时候会进行一个合并，并且返回最后一个写的<code>version</code>。这个原则是<code>last-write-win</code></li>
<li>Cassandra can read data directly from the new SSTable even before it finishes writing, instead of waiting for the entire compaction process to finish.</li>
</ul>
<h3 id="compaction-策略"><a class="header-anchor" href="#compaction-策略"></a>Compaction 策略</h3>
<ul>
<li>不同的策略决定了如何来选择<code>SSTable</code>以及压缩后的行如何插入到新的表格中</li>
<li>我在压缩策略的道路上越走越远了啊。😂</li>
</ul>
<h4 id="sizetieredcompactionstrategy-stcs"><a class="header-anchor" href="#sizetieredcompactionstrategy-stcs"></a>SizeTieredCompactionStrategy (STCS)</h4>
<h5 id="工作流程"><a class="header-anchor" href="#工作流程"></a>工作流程</h5>
<ul>
<li>当有4个大小相近的<code>STable</code>的时候就开始合并，所以并不是完全相同大小的</li>
<li>将这些大小相近的<code>SSTable</code>合并成一个，当有4个更大的<code>table</code>的时候，再合并成更大的<code>SSTable</code></li>
<li>所以会有很多大小不同的<code>SSTable</code>同时存在</li>
</ul>
<h4 id="参数"><a class="header-anchor" href="#参数"></a>参数</h4>
<h5 id="优缺点"><a class="header-anchor" href="#优缺点"></a>优缺点</h5>
<ul>
<li>优势：写密集的工作良好。</li>
<li>逆势：
<ul>
<li>可能降低读的效率。因为策略不保证同一行的数据被限制在有限的数据文件里面，这样在读取的时候会需要读取更多的数据文件。</li>
<li>可能长期保持旧数据；不同版本的同一行会可能分布在不同的<code>SSTable</code>里面。并且不利于删除旧数据</li>
<li>需要的内存和磁盘都会随着时间增加。磁盘在下面的问题章节中可以看到；而内存也是显而易见的，当<code>SSTable</code>的大小达到一定级别，一次压缩需要的内存会很大。因为需要<code>load SSTable</code>到内存里面</li>
</ul>
</li>
</ul>
<h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5>
<ul>
<li>
<p>在实际的工作中碰到了缺点中的问题，系统在工作3个月的时候能够在一个节点上面占用靠13G的磁盘量。</p>
</li>
<li>
<p>观察下来，其实策略是在正常工作的。里面明显能够看到大小不同的data文件。</p>
</li>
<li>
<p>现在客户的需求是不手动操作来解决占用磁盘的问题。总的来说，貌似不现实，毕竟多数建议是关闭自动SSTable压缩，改用手动在空闲期间进行压缩</p>
<pre><code>total 13G
 115M Jan 24  2019 la-2421-big-Data.db
 101M Jan 24  2019 la-2443-big-Data.db
 453K Jan 24  2019 la-2447-big-Data.db
 124M Feb  3 14:47 lb-5276-big-Data.db
 216M Feb  3 14:54 lb-5280-big-Data.db
 235M Feb  3 14:54 lb-5281-big-Data.db
 680M Feb  4 11:24 lb-5294-big-Data.db
 781M Feb  4 11:36 lb-5295-big-Data.db
 2.8G Feb  4 11:54 lb-5296-big-Data.db
 3.3G Feb  4 12:52 lb-5298-big-Data.db
 3.5G Feb  4 12:54 lb-5297-big-Data.db
</code></pre>
</li>
</ul>
<h4 id="leveledcompactionstrategy-lcs"><a class="header-anchor" href="#leveledcompactionstrategy-lcs"></a>LeveledCompactionStrategy (LCS)</h4>
<h5 id="工作流程-v2"><a class="header-anchor" href="#工作流程-v2"></a>工作流程</h5>
<ul>
<li>
<p>LCS的工作流程是最不清晰的了。网上各类文章，有说L1的数据文件数量是L0的10倍的，有说整体大小的。我一口血都要喷显示器上面了,不带这么不严谨的好嘛 😦</p>
</li>
<li>
<p>看代码其实最清楚了。应该是大小，不是数量：</p>
</li>
<li>
<p>以下代码里面，maxSSTableSizeInBytes= 160M * 1024<em>1024，所以L0最大是160M</em>4</p>
</li>
<li>
<p>代码在<code>org.apache.cassandra.db.compaction.LeveledCompactionStrategy</code></p>
<pre><code>public static long maxBytesForLevel(int level, int levelFanoutSize, long maxSSTableSizeInBytes) {
  if (level == 0) {
      return 4L * maxSSTableSizeInBytes;
  } else {
      double bytes = Math.pow((double)levelFanoutSize, (double)level) * (double)maxSSTableSizeInBytes; 
  }
}
</code></pre>
</li>
<li>
<p><code>LCS</code>一大特点是会尽量保证在同一个层级里面，同一<code>partition key</code>的数据在同一张<code>SSTable</code>表里面。当然<code>L0</code>没法保证，因为这一层级是<code>flush</code>来的</p>
</li>
<li>
<p>为了做到这一点，<code>LCS</code>在进行一次压缩的时候会包括上一级中也有这个<code>partition key</code>的数据，所以这个策略要读表啊。比如在<code>L1</code>级数据大于上限需要压缩的时候，<code>L2</code>级中包含相同<code>key</code>的表也要被一起合并，但是欣慰的是，应该也只有一张表。毕竟每一级都是这么干的。-</p>
</li>
<li>
<p>我们在<code>Cassandra</code>中可以设定进行并行的压缩，那么在<code>LCS</code>策略中需要保证同一个<code>parititon key</code>的数据只在一个压缩线程中，不能有交叉重叠</p>
</li>
<li>
<p>所以，压缩<code>L0</code>层级的时候，会带上所有<code>L1</code>的表一起压缩。如果<code>L0</code>很多，那么没法一次压缩做完所有<code>L0</code>的表格</p>
</li>
<li>
<p>压缩时候优先考虑最高级别的。所有<code>L0</code>是最后考虑的一个层级</p>
</li>
<li>
<p><code>LCS</code>有可能触发<code>major compaction</code>，这点需要进一步考察。</p>
</li>
<li>
<p>如果<code>L0</code>级别的表超过32个，会进行<code>STCS</code></p>
</li>
</ul>
<h5 id="相关参数"><a class="header-anchor" href="#相关参数"></a>相关参数</h5>
<ul>
<li><code>sstable_size_in_mb</code>: 就是上面代码里面那个<code>maxSSTableSizeInBytes</code>，第一层级的大小</li>
<li><code>fanout_size</code>： 各个层级之间的差异，上面代码里面的<code>levelFanoutSize</code></li>
</ul>
<h5 id="优缺点-v2"><a class="header-anchor" href="#优缺点-v2"></a>优缺点</h5>
<ul>
<li>优点：
<ul>
<li>读比较频繁的更推荐这个算法。其实写的应该也可以。目前这应该是应用最广泛的压缩算法了。</li>
<li>容易预测内存需求大小</li>
<li>更容易删除旧数据</li>
<li>需要的磁盘空间更小</li>
</ul>
</li>
<li>缺点：
<ul>
<li>进行得更为频繁，所以需要的I/O比较多</li>
</ul>
</li>
</ul>
<h4 id="timewindowcompactionstrategy-twcs"><a class="header-anchor" href="#timewindowcompactionstrategy-twcs"></a>TimeWindowCompactionStrategy (TWCS)</h4>
<ul>
<li>接上文碰到的问题，刚刚好出问题的表的<code>partition key</code>是日期，所以研究得最多的就是这个策略了。而时间策略是唯一一个可以彻底删除过期的表的策略。当然，要结合下面的<code>TTL</code>一起用。</li>
<li>需要注意的一点是：<code>TCWS</code>是从<code>Cassandra 3.0.8</code>才被引入的。而我们产品仍旧停留在<code>2.2.8</code>上，这也是为什么最后没法采用这个解决方案</li>
</ul>
<h5 id="工作原理"><a class="header-anchor" href="#工作原理"></a>工作原理</h5>
<ul>
<li>这个算法挺有意思的，而且简单好懂。就是说在一段时间内，比如一个小时内，使用<code>STCS</code>算法，然后在时间点上，一个小时结束的时候，把这个小时内的都压成一个大的数据文件。</li>
<li>第二个小时开始的时候，重新算起，上一个小时压出来的大表就放那里不动了。</li>
</ul>
<h5 id="相关参数-v2"><a class="header-anchor" href="#相关参数-v2"></a>相关参数</h5>
<ul>
<li><code>compaction_window_unit</code>:MINUTES, HOURS, or DAYS</li>
<li><code>compaction_window_size</code>:默认为1</li>
<li><code>unsafe_aggressive_sstable_expiration</code>: 这个参数很有意思，就是说当一个表里面都是墓碑的时候，直接把表删除掉。这个参数是一个全局参数，是在启动<code>JVM</code>的时候设置的。因为是有风险的，有可能造成幽灵数据。同时，设置这个参数会覆盖掉<code>unchecked_tombstone_compaction</code>.</li>
</ul>
<h5 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h5>
<ul>
<li><a href="https://thelastpickle.com/blog/2016/12/08/TWCS-part1.html" target="_blank" rel="noopener">TWCS-part1</a></li>
<li><a href="https://thelastpickle.com/blog/2017/01/10/twcs-part2.html" target="_blank" rel="noopener">TWCS-part2</a></li>
</ul>
<h3 id="ttl"><a class="header-anchor" href="#ttl"></a>TTL</h3>
<h4 id="ttl被提出的背景"><a class="header-anchor" href="#ttl被提出的背景"></a>TTL被提出的背景</h4>
<ul>
<li>这是在处理产品的一个问题的时候被提出的，该问题就是，由于某个统计功能一直在写数据，然后每隔一个月左右会删除数据。</li>
<li>表格以<code>date</code>作为<code>partition key</code>，所有数据在一个表里面，所以即使数据被删除了也没法直接<code>truncate</code>表，只能依赖<code>Cassandra</code>的<code>compaction</code>。</li>
<li>最后越来越占磁盘。使用的策略是默认的<code>STCS</code>。然后就有大佬提了<code>TTL</code></li>
<li>我原本在考虑加<code>crontab job</code>，但是其实没有意义，因为<code>Cassandra</code>提供的其实就是类似功能。</li>
</ul>
<h4 id="什么是ttl-time-to-live"><a class="header-anchor" href="#什么是ttl-time-to-live"></a>什么是TTL(time-to-live)</h4>
<ul>
<li><em>TTL: allows to specify an optional Time To Live (in seconds) for the inserted values. If set, the inserted values are automatically removed from the database after the specified time. Note that the TTL concerns the inserted values, not the column themselves. This means that any subsequent update of the column will also reset the TTL (to whatever TTL is specified in that update). By default, values never expire. A TTL of 0 or a negative one is equivalent to no TTL.</em></li>
<li>其实<code>Cassandra</code>里面<code>TTL</code>的概念到处都是。但是通常说的<code>TTL</code>是指参数<code>default_time_to_live</code>，也就是说到了这个时间点，<code>Cassandra</code>会自动将数据删除掉。</li>
<li>默认值为0，也就是<code>Cassandra</code>会认为这个数据一直有效</li>
<li>这个参数在<code>desc tables</code>里面可以看到，但是我们产品的异步模块里面其实在代码里面进行了覆盖。<code>java</code>代码里面弄了个系统参数，在插入数据的时候代入了这个参数</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo_blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/hexo_blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/hexo_blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/hexo_blog/page/5/">5</a><a class="extend next" rel="next" href="/hexo_blog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lynn Shen</p>
  <div class="site-description" itemprop="description">35岁开始的博客，有点晚哦</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo_blog/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo_blog/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ffyWzhHueqJEC5UEfPUhAWzF-MdYXbMMI","app_key":"vS7xTvT1vD1DxluERkmlkvme","server_url":"https://sallyslove.github.io/hexo_blog","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/hexo_blog/lib/anime.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo_blog/js/utils.js"></script>

<script src="/hexo_blog/js/motion.js"></script>


<script src="/hexo_blog/js/schemes/muse.js"></script>


<script src="/hexo_blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
