<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/hexo_blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/hexo_blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/hexo_blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/hexo_blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/page/2/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="35岁开始的博客，有点晚哦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo_blog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sallyslove.github.io/hexo_blog/page/2/">





  <title>跬步</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo_blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo_blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/hexo_blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo_blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/08/13/Micro-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/08/13/Micro-Service/" itemprop="url">Micro Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T13:41:09+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习一些<code>micro service</code>相关，记录在这里。<br>
现在都是说<code>micro service</code>，但是什么是<code>micro service</code>，可能不同的人有不同的定义，但是单纯地只是将软件部署到<code>docker</code>或者<code>k8s</code>上面去，可能并不完全符合<code>micro service</code>，所以学习一下。<br>
将一些学习到的tips和理念记录下来，最后形成自己的理解。<br>
学习了一阵，感觉还是不一样的，有一套架构体系的，记录在这里。</p>
<h3 id="什么是micro-service"><a class="header-anchor" href="#什么是micro-service"></a>什么是micro service</h3>
<ul>
<li>只占用需要的内存和处理器处理能力</li>
<li>如果是处理数据的，假设我们有一个处理inventory data的<code>micro service</code>，那么这个<code>micro service</code>仅仅需要在意inventory data。而不需要考虑其他数据的影响。</li>
<li><code>micro service</code>不受语言限制，不同语言的<code>micro service</code>仍旧可以联合起来的完成一个solution的</li>
</ul>
<h4 id="aws的理解"><a class="header-anchor" href="#aws的理解"></a>AWS的理解</h4>
<ul>
<li>
<p>参考链接：<a href="https://aws.amazon.com/microservices/" target="_blank" rel="noopener">AWS微服务理解</a></p>
</li>
<li>
<p>每个服务都是独立提供服务的模块，可以独立的开发、升级、部署和扩展</p>
</li>
<li>
<p>每个服务不应该和任何其他服务共享代码</p>
</li>
<li>
<p>服务间的任何交互都应该通过<code>API</code>来进行</p>
</li>
<li>
<p>每个服务都是</p>
</li>
</ul>
<h4 id="微软的理解"><a class="header-anchor" href="#微软的理解"></a>微软的理解</h4>
<ul>
<li>参考链接：<a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices" target="_blank" rel="noopener">微软文章</a></li>
</ul>
<h3 id="micro-service-combination"><a class="header-anchor" href="#micro-service-combination"></a>micro service combination</h3>
<ul>
<li><code>micro service</code>本身是一个<code>complete application</code>，它独立完成某个功能，可以有interface或者没有，可以访问数据库，也可以不访问。</li>
<li>很多<code>micro service</code>联合起来，成为一个solution。</li>
<li>默认只需要知道对方的<code>endpoint</code>就可以进行通信。其实不一定是<code>http</code>协议的，也有一些其他的很流行的总线方式。</li>
<li><strong><em>each micro service has to offer an API endpoint! 通常都是REST的endpoint，但是也可以是<code>wisdom endpoint</code></em></strong></li>
</ul>
<h3 id="micro-service特点"><a class="header-anchor" href="#micro-service特点"></a>micro service特点</h3>
<ul>
<li>增加了scalability。话说这个吧，其实很复杂。看我另外一篇博客。而且未必多加pod，能力就一定上升啊</li>
<li>从下面杂谈里面的几篇文章里面看起来，大家都认为<code>micro service</code>之后，模块之间基本是完全解耦的，大家都开开心心的全栈式就关心自己的模块，从需求到后期客户维护，完全自主，不用管其他模块。<em>A benefit of microservices is that each team can be responsible for releasing their services independently and without coordination with other teams.</em>
<ul>
<li>但是，这怎么可能啊。就我们自己的产品来说，尤其是那些<code>lib</code>库一样的模块，一升级，所有的都得动。没明白。没有明白呀。</li>
<li>除非所有的小模块都像个产品一样运营。比如提供安全管理功能的模块，剩下调用它的模块按照自己的需求进行升级。</li>
<li><strong><em>嗯，确实也是有产品这么做的，但是这样就会有很多资源消耗吧。这点在大牛的分享中也提及过，O&amp;M的功能是公用的，但是会占用资源。</em></strong></li>
<li><strong><em>但是如果大家都用同一份，谈什么微服务哦。那么<code>lib</code>库就不应该占用资源。或者占用资源的就不应该做成<code>lib</code>库？</em></strong></li>
<li><code>google</code>怎么做的？应该也是有不同的产品吧。</li>
</ul>
</li>
</ul>
<h4 id="优势"><a class="header-anchor" href="#优势"></a>优势</h4>
<ul>
<li>
<p>改动：一个微小的改动需要很多工作去做，一个微小的改动会影响很多部分，增加一个需要资源的模块，需要增加整个系统的资源，而不是只增加需要增加的部分</p>
</li>
<li>
<p>扩展：基本上就是指<code>load scalability</code>,在monolithich时代，扩展是扩展所有的模块，就是复制出新的一份系统来。而微服务时候，是扩展需要扩展的部分，这点很有优势</p>
<ul>
<li>所以从以上两点来说，一个微服务在部署和扩展上面，从业务角度来说，就是service角度来说，应该是独立的。<strong><em>那么反过来成立吗？就是说一个pod或者service，可以独立部署，独立扩展，但是并不能提供独立的服务，那么是不是边界定义得不对呢</em></strong></li>
<li><em>We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call.</em></li>
</ul>
</li>
<li>
<p>方便CI和CD</p>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices Architecture</a>:</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjEwNTEzOQ==&amp;mid=401500724&amp;idx=1&amp;sn=4e42fa2ffcd5732ae044fe6a387a1cc3#rd" target="_blank" rel="noopener">上一篇的中文翻译</a></li>
</ul>
</li>
</ul>
<h4 id="逆势"><a class="header-anchor" href="#逆势"></a>逆势</h4>
<p>微服务也是会有一些问题和难点的，比如：</p>
<ul>
<li>进程间通信会比进程内通信代价大很多，所以应该谨慎设计边界。<em>remote APIs need to be coarser-grained, which is often more awkward to use.</em> 不是很理解这句话</li>
<li>Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management. 所以嘛，我就说对技术人员的要求越发高了。虽说是team，但是这种team也很不好搭配的好不好。</li>
<li>并且这种方式，将团队和自己开发的产品绑在了一起。感觉回到了以模块来组织team的年代。实在是有利有弊。还有一个问题，按照现在推荐的，将一部分support的事务归到了技术团队里面，那么有向前延伸吗？话说薪水呢，得涨薪啊</li>
</ul>
<h3 id="微服务架构"><a class="header-anchor" href="#微服务架构"></a>微服务架构</h3>
<p>关于微服务架构的文章真是多如牛毛。一搜一大把。看了陈晧推荐的一篇据说入门级英文文章，确实清晰明了。话说很多中文翻译简直是惨不忍睹啊。真心惨不忍睹！</p>
<p>看了总觉得有有点心惊啊，从<code>warterful</code>到<code>agile</code>，从<code>monolithic</code>到<code>micro service</code>，对开发人员的要求是越来越高了啊。😦</p>
<p>还能不能愉快地做开发了啊？<br>
<em>The microservice approach to division is different, splitting up into services organized around business capability</em></p>
<p>还得有<code>business capability</code>，话说技术人员理解的<code>business capability</code>正确吗</p>
<h3 id="杂谈"><a class="header-anchor" href="#杂谈"></a>杂谈</h3>
<ul>
<li>
<p>早上无心工作，摸鱼酱油，看了几篇文章，觉得还不错。 😅 话说<code>InfoQ</code>就是做翻译工作的嘛，咋云计算那边全是翻译啊。</p>
</li>
<li>
<p><a href="https://medium.com/better-programming/how-microservices-architecture-impacted-the-culture-of-software-development-6bba363ecdf1" target="_blank" rel="noopener">How Microservices Architecture Impacted the Culture of Software Development</a>:</p>
<ul>
<li>这篇文章的观点很是不错，含义就是说写代码很有趣啊，想干嘛就干嘛，把自己脑子里面的想法实现出来。可是工作以后就郁闷了，全是些模糊的责任，规定好了的框架，规定好了的数据库，规定好了的语言。确实如此，一天天消磨了意志和能力</li>
<li>现在有了<code>micro service</code>，瞅着大家都挺开心的，有了这个鼓动，似乎乐趣又回来了一点，可以分为很小的<code>repo</code>，可以自行选择各种不同的语言和技术，然后一起做成为一个产品。甚至可以有产品和售后的职责。</li>
<li>嘛，文章最后还说，这个并不关<code>micro service</code>的关系，所谓的<code>monolithic</code>也应该可以做到。</li>
</ul>
</li>
<li>
<p><a href="https://medium.com/@steven.lemon182/why-our-team-cancelled-our-move-to-microservices-8fd87898d952" target="_blank" rel="noopener">Why our team cancelled our move to microservices</a></p>
<ul>
<li>原文很长，下面的评论也十分之多，实在不算一把头能看完的</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/08/02/Java-Socket中的port/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/08/02/Java-Socket中的port/" itemprop="url">TCP & UDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-02T15:42:25+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/protocal/" itemprop="url" rel="index">
                    <span itemprop="name">protocal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工作中碰到DNS的local 端口的问题，就是client段的port，不是DNS server的端口。这个是默认开在53上面的。<br>
然后就研究了一下，写在这里。</p>
<h3 id="port-0"><a class="header-anchor" href="#port-0"></a>port 0</h3>
<ul>
<li>可用端口是<code>0 ~ 65535</code>。<code>0</code>在这里说啦，是分配一个随机的未被占用的端口。而<code>65535</code> 事实上是会报错的，也是用不了的。</li>
<li>事实上，确实是可能有race condition存在的。并且很难避免。仔细看了一遍，好像并没有很好的提议。</li>
<li>Spring里面的<code>SocketUtil</code>的源码可以参考</li>
<li><code>ServerSocket</code>里面初始化时候其实是有两部的，第二部是bind，如果传0给构造函数，第二部时候才真正是分配的时候。</li>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/qq_36592572/article/details/82323100" target="_blank" rel="noopener">关于端口最大值65535的问题</a></li>
<li><a href="https://stackoverflow.com/questions/12889702/allowed-port-range-for-tcp" target="_blank" rel="noopener">Allowed Port Range for TCP</a></li>
<li><a href="https://stackoverflow.com/questions/115500/how-do-you-specify-a-port-range-for-java-sockets" target="_blank" rel="noopener">how-do-you-specify-a-port-range-for-java-sockets</a></li>
<li><a href="https://stackoverflow.com/questions/2675362/how-to-find-an-available-port" target="_blank" rel="noopener">how-to-find-an-available-port</a>: 这篇链接里面有大量讨论和实现。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/SocketUtils.html" target="_blank" rel="noopener">Class SocketUtils</a></li>
<li><a href="https://stackoverflow.com/questions/51099027/find-free-port-in-java" target="_blank" rel="noopener">find-free-port-in-java</a></li>
</ul>
</li>
</ul>
<h3 id="tcp-udp"><a class="header-anchor" href="#tcp-udp"></a>TCP &amp; UDP</h3>
<ul>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://stackoverflow.com/questions/12737293/how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind?rq=1" target="_blank" rel="noopener">how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind</a>: 里面有很多如何查找是哪个应用在占用端口的方法</li>
<li><a href="https://stackoverflow.com/questions/27730330/java-what-is-the-difference-between-serversocket-and-datagramsocket" target="_blank" rel="noopener">java-what-is-the-difference-between-serversocket-and-datagramsocket</a></li>
<li><a href="https://www.javaworld.com/article/2077322/core-java-sockets-programming-in-java-a-tutorial.html" target="_blank" rel="noopener">Sockets programming in Java</a></li>
</ul>
</li>
<li>
<p>这回犯一个低级错误。但是也是必然的，毕竟底层网络不够了解。</p>
</li>
<li>
<p>这次犯的错误是这样的，需要发现一个free的port来建立UDP连接，于是就使用了<code>serverSocket</code> 来check 端口，参考以上链接。</p>
</li>
<li>
<p>实际是，<code>TCP</code>和 <code>UDP</code> 需要使用不同的结构。ORZ。可见我的java基础和网络基础都很有点薄弱啊。对<code>socket</code>的理解也着实不灵啊。</p>
</li>
<li>
<p><code>UDP</code> 应当使用<code>DatagramSocket</code>结构来建。</p>
</li>
</ul>
<h4 id="udp"><a class="header-anchor" href="#udp"></a>UDP</h4>
<ul>
<li><code>UDP</code>的全称：<code>user datagram protocol</code>。</li>
<li>each time you send datagrams, you also need to send the local socket descriptor and the receiving socket’s address. As you can tell, additional data must be sent each time a communication is made.</li>
</ul>
<h4 id="tcp"><a class="header-anchor" href="#tcp"></a>TCP</h4>
<ul>
<li><code>TCP</code>的全称： <code>transfer control protocol</code></li>
<li>Once two sockets have been connected, they can be used to transmit data in both (or either one of the) directions.</li>
</ul>
<h4 id="when-is-udp-when-is-tcp"><a class="header-anchor" href="#when-is-udp-when-is-tcp"></a>When is UDP &amp; when is TCP</h4>
<ul>
<li><code>UDP</code>有数据大小限制，每次发的时候都要带上信息，不可靠，但是速度高。</li>
<li><code>TCP</code>是面向连接的，所有有建立连接时间。<strong><em>UDP也要建连接呀</em></strong> TCP的数据更像流，而不是一个个数据包，没有大小限制，可靠，但是速度慢很多。</li>
<li>TCP is useful for implementing network services – such as remote login (rlogin, telnet) and file transfer (FTP)</li>
<li>UDP is often used in implementing client/server applications in distributed systems built over local area networks.</li>
<li>一出杯具： 杯具的是，作为一个bug 处理，在学习了一堆，并且记录了一堆之后，自我感觉良好的本人还是犯错了。因为，我们的产品里面不仅仅使用了<code>UDP</code>，还使用了<code>TCP</code>。嘿，我给漏掉了。所以，就算协议学会了，明白了，也得清楚，实现不一定按规矩来的。毕竟都是人来做的。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/26/K8s端口映射命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/26/K8s端口映射命令/" itemprop="url">K8s常用命令集2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T11:17:05+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>K8s的前两篇文档大而乱啊。所以的话，还是小而精更好吧。</p>
<p>接着记录命令，最好相关命令放在一起。</p>
<ul>
<li><code>kubectl port-forward</code>
<ul>
<li>
<p>Forward one or more local ports to a pod. This command requires the node to have ‘socat’ installed. <strong><em>socat是什么?</em></strong></p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://imti.co/kubernetes-port-forwarding/" target="_blank" rel="noopener">Kubernetes Port Forwarding for Local Development</a></li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward" target="_blank" rel="noopener">官方文档</a></li>
</ul>
</li>
<li>
<p>用例：</p>
<ul>
<li>以下命令的含义是：将本地端口<code>8080</code>和<code>8081</code>，映射到<code>k8s</code>服务<code>ok</code>的<code>8080</code>和<code>80</code>端口上面。<code>-n</code>代表的<code>namespace</code></li>
<li>默认地址是<code>localhost</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  kubectl port-forward service/ok 8080:8080 8081:80 -n the-project
</code></pre>
<ul>
<li><code>kubectl edit</code> 命令可以用来修改一个资源。<code>kubectl edit deployment &lt;resource_name&gt; -n &lt;namespace&gt;</code>,需要注意的是修改是暂时的，如果使用<code>helm upgrade</code>命令，那么修改会被覆盖掉
<ul>
<li>参考链接： <a href="https://stackoverflow.com/questions/45502729/how-do-i-edit-a-resource-configuration-with-kubectl" target="_blank" rel="noopener">kubectl edit</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/26/Java-Remote-Debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/26/Java-Remote-Debug/" itemprop="url">Java Remote Debug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T10:51:48+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为Java程序员，不会remote debug，是不现实的。实际上，几年前也用过。但是悲催的是，再次要用的时候就搞不清了。<br>
现在还是k8s平台，端口映射就更复杂一点。三两下一绕就更不清楚了。所以还是先把remote debug搞清楚。<br>
再去绕端口号。</p>
<h3 id="什么是remote-debug"><a class="header-anchor" href="#什么是remote-debug"></a>什么是remote debug</h3>
<p>服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。</p>
<h3 id="怎么做remote-debug"><a class="header-anchor" href="#怎么做remote-debug"></a>怎么做remote debug</h3>
<h4 id="使用特定jvm参数运行服务端代码"><a class="header-anchor" href="#使用特定jvm参数运行服务端代码"></a>使用特定JVM参数运行服务端代码</h4>
<ul>
<li>不是说打包的时候，而是运行jar包的时候，java -jar带上需要的参数
<ul>
<li><code>address</code>是进行通信需要的端口。那么服务器端运行的程序会在这个端口上面开一个<code>socket</code></li>
<li><code>socket</code>比较好理解的，通信方式</li>
<li>所以之前进行debug mode的时候，肯定要改一下产品端module运行时候的JVM参数的</li>
</ul>
</li>
</ul>
<pre><code>-Xdebug -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=${debug_port}
</code></pre>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/wy2325/p/5600232.html" target="_blank" rel="noopener">IntelliJ远程调试教程</a></li>
</ul>
</li>
</ul>
<h4 id="在ide里面进行设置-本地连接远程服务器debug端口"><a class="header-anchor" href="#在ide里面进行设置-本地连接远程服务器debug端口"></a>在IDE里面进行设置，本地连接远程服务器debug端口</h4>
<ul>
<li>
<p>参考链接里面的设置方法，其实就配远程服务器的地址和debug 端口</p>
</li>
<li>
<p>还需要点击一下debug，让本地attach上去。</p>
</li>
</ul>
<h4 id="调试代码"><a class="header-anchor" href="#调试代码"></a>调试代码</h4>
<ul>
<li>这时候就可以进行remote debug了。打好断点，然后往服务器发送请求就可以了</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/19/ifconfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/19/ifconfig/" itemprop="url">ifconfig & some basic concept</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T10:21:25+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>ifconfig</code>是最常用的命令。然而，只是大概的了解。每次看一下之后，后面又会忘。<br>
网络的基本概念也是，每次都是看一点，不成系统的感觉。所以把基础网络概念放在这里。<br>
前后一年时间，这回大致是明白了。想当年大学时代，我网络学得不错的啊 😇</p>
<h3 id="网络基础概念"><a class="header-anchor" href="#网络基础概念"></a>网络基础概念</h3>
<h4 id="物理地址-mac地址"><a class="header-anchor" href="#物理地址-mac地址"></a>物理地址(MAC地址)</h4>
<ul>
<li>什么是<code>MAC地址</code>？ MAC地址（<code>Media Access Control Address</code>，介质访问控制），直译为媒体访问控制地址，也称为局域网地址（<code>LAN Address</code>），以太网地址（<code>Ethernet Address</code>）或物理地址（<code>Physical Address</code>），它是一个用来确认网上设备位置的地址。</li>
<li>形象地说，<code>MAC地址</code>就如同身份证上的身份证号码，具有全球唯一性。</li>
<li><code>MAC地址</code>采用十六进制数表示，共六个字节（48位）。其中，前三个字节是由<code>IEEE</code>的注册管理机构<code>RA</code>负责给不同厂家分配的代码(高位24位），也称为“编制上唯一的标识符”，后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。</li>
<li><code>MAC地址</code>用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</li>
<li>参考链接
<ul>
<li><a href="https://zhidao.baidu.com/question/6331169.html" target="_blank" rel="noopener">百度知道的迅速概念</a></li>
<li><a href="https://www.zhihu.com/question/49335649" target="_blank" rel="noopener">IP地址和MAC地址的区别和联系-这篇的第一个回答非常清晰</a></li>
<li><a href="https://www.zhihu.com/question/21546408" target="_blank" rel="noopener">有了 IP 地址，为什么还要用 MAC 地址？</a></li>
</ul>
</li>
</ul>
<h4 id="ip地址"><a class="header-anchor" href="#ip地址"></a>IP地址</h4>
<ul>
<li>主要的参考链接仍旧是上面知乎上的一篇。里面的回答非常清晰</li>
<li>网络上面关于<code>IP</code>地址，<code>MAC</code>地址的解释很多，有说<code>IP</code>是门牌地址，<code>MAC</code>是身份证号，乍一看似乎明白了，但是仍旧不清晰，很多事物的来源是有历史原因的。</li>
<li>在最早的时候是没有因特网的，只有以太网。当然，最早的是电话网络，物理网线的那个网络。</li>
<li>以太网是目前常用的局域网的技术，对应于数据链路层。同层的有令牌环(这个我印象深刻啊)，还有<code>ATM</code>技术。在以太网里面，使用的是<code>MAC</code>地址。</li>
<li>而后来出现了互联网，将各个局域网给连接起来，这时候，<code>MAC</code>地址的局限性就出现了，毕竟设计最初就是局域网用的，不可能让每个交换机记录世界上所有的<code>MAC</code>地址。</li>
<li>于是互联网中引入了<code>IP</code>地址。<code>IP</code>地址是因特网（因特网协议就是<code>TCP/IP</code>）的概念，而因特网本身设计时候就是以连接多个以太网为目的的，所以因特网并不考虑数据链路层和物理层的内容。</li>
<li><code>IP</code>地址就是帮着客户在多个以太网中间转发，在以太网内部，就是<code>MAC</code>地址的事情了。</li>
<li>当然，因特网也可以架构在其他类型的局域网之上，例如令牌环网。</li>
<li>那么<code>IP</code>是如何找到各个局域网的，会在另一篇博客里面阐述</li>
</ul>
<h4 id="子网掩码"><a class="header-anchor" href="#子网掩码"></a>子网掩码</h4>
<ul>
<li>
<p>子网掩码(<code>subnet mask</code>)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个<code>IP地址</code>的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
</li>
<li>
<p>子网掩码不能单独存在，它必须结合IP地址一起使用。</p>
</li>
<li>
<p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分</p>
</li>
<li>
<p>子网掩码是一个<code>32</code>位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</p>
</li>
<li>
<p>计算稍微有点绕，看知乎上面的比喻比较清楚，举例：</p>
<ul>
<li>
<p>比如我们申请到的网络号为 <code>210.73.a.b</code>，该网络地址为c类IP地址，网络标识为<code>210.73.a</code>，主机标识是<code>b</code>。</p>
</li>
<li>
<p>假设需要16个子网。那么就是<code>1111</code></p>
</li>
<li>
<p>然后c类地址的最后一位是主机标识。那么就是<code>11110000</code>.前四位代表子网，后四位代表主机名。最后掩码是<code>255.255.255.240</code>。也可以写成<code>210.73.a.0/28</code></p>
</li>
<li>
<p>28代表28个1</p>
</li>
<li>
<p>再看知乎的例子，<code>192.168.1.x</code>分成4个子网。那么就是<code>11111111,11111111,11111111,11000000</code>， 所以第一个子网就是<code>192.168.1.0/26</code></p>
</li>
<li>
<p>看IP地址的话就是，这四个网段的开头就是：</p>
<pre><code>192.168.1. 00 000000 --&gt; 00 111111 
192.168.1. 01 000000 --&gt; 01 111111
192.168.1. 10 000000 --&gt; 10 111111
192.168.1. 11 000000 --&gt; 11 111111
</code></pre>
</li>
</ul>
</li>
<li>
<p>参考链接</p>
</li>
</ul>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener">百度百科的解释</a></li>
<li><a href="https://www.zhihu.com/question/56895036" target="_blank" rel="noopener">知乎问答</a></li>
</ul>
<h4 id="广播地址"><a class="header-anchor" href="#广播地址"></a>广播地址</h4>
<ul>
<li><code>Broadcast Address</code>(广播地址)是专门用于同时向网络中所有工作站进行发送的一个地址。</li>
<li>在使用<code>TCP/IP</code>协议的网络中，主机标识段<code>host ID</code>为全<code>1</code>的IP 地址为广播地址，广播的分组传送给<code>host ID</code>段所涉及的所有计算机。例如，对于<code>10.1.1.0</code> （<code>255.255.255.0</code> ）网段，其广播地址为<code>10.1.1.255</code> （<code>255</code> 即为二进制的<code>11111111</code>），当发出一个目的地址为<code>10.1.1.255</code>的分组（封包）时，它将被分发给该网段上的所有计算机。</li>
</ul>
<h3 id="ifconfig"><a class="header-anchor" href="#ifconfig"></a>ifconfig</h3>
<p>这个命令是<code>linux</code>的</p>
<h4 id="ifconfig命令输出详解"><a class="header-anchor" href="#ifconfig命令输出详解"></a>ifconfig命令输出详解</h4>
<ul>
<li><code>eth0</code> --&gt; 网卡</li>
<li><code>HWaddr</code> --&gt; MAC</li>
<li><code>inet addr</code> --&gt; internal address, IP</li>
<li><code>Bcast</code> --&gt; 广播地址</li>
<li><code>Mask</code> --&gt; 子网掩码</li>
<li><code>Link encap</code> --&gt; 网络类型为以太网，这里也可能出现其他类型。比如 <code>Local Loopback</code></li>
</ul>
<pre><code>[root@linuxchao ~]# ifconfig
eth0 Link encap:Ethernet HWaddr 00:03:0D:27:86:41
inet addr:192.168.1.86 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::203:dff:fe27:8641/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:618 errors:0 dropped:0 overruns:0 frame:0
TX packets:676 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:491238 (479.7 KiB) TX bytes:86286 (84.2 KiB)
Interrupt:5 Base address:0x8c00
</code></pre>
<ul>
<li>参加链接
<ul>
<li><a href="http://c.biancheng.net/view/797.html" target="_blank" rel="noopener">Linux ifconfig命令：配置网络接口</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/09/DNS协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/09/DNS协议/" itemprop="url">DNS协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T15:35:36+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/protocal/" itemprop="url" rel="index">
                    <span itemprop="name">protocal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2>
<p>工作中要用到DNS协议，需要学习一下，省得碰到的时候每次都要再看一遍。 DNS也是TCP/IP里面的一个基础协议。所以也会涉及到一些TCP/IP协议的部分。<br>
话说一个简单的DNS协议也有一堆可以写啊。不容易啊。</p>
<h3 id="dns在tcp-ip协议里的位置"><a class="header-anchor" href="#dns在tcp-ip协议里的位置"></a>DNS在TCP/IP协议里的位置</h3>
<ul>
<li>从参考链接名就能看出来， DNS是应用层的协议</li>
<li>TCP/IP是四层。OSI是7层。</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1195962/e9uc1yy5n7.png?imageView2/2/w/1620" alt></p>
<blockquote>
<p>图片来自参考链接1</p>
</blockquote>
<ul>
<li>参考链接：
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1023700" target="_blank" rel="noopener">TCP/IP（六）应用层（DNS和HTTP协议）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1358564" target="_blank" rel="noopener">DNS协议入门</a></li>
<li><a href="https://cloud.tencent.com/developer/information/dns%E7%9A%84%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">DNS协议栈</a></li>
</ul>
</li>
</ul>
<h3 id="概述"><a class="header-anchor" href="#概述"></a>概述</h3>
<ul>
<li><code>Domain Name System</code> 域名系统。也可以叫做域名解析协议。</li>
<li>简单的解释就是DNS协议会把网址，比如将”<a href="http://sallyslove.github.io/hexo_blog%E2%80%9D%E7%9A%84%E5%9F%9F%E5%90%8D%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%83%BD%E5%A4%9F%E7%90%86%E8%A7%A3%E7%9A%8432%E4%BD%8D%E7%9A%84IP%EF%BC%8C%E5%8F%91%E5%88%B0%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%BB%E3%80%82">sallyslove.github.io/hexo_blog”的域名转换成为计算机能够理解的32位的IP，发到网络层去。</a></li>
<li>域名和IP的对应关系保存在一个叫hosts文件中。最初，通过互联网信息中心来管理这个文件，如果有一个新的计算机想接入网络，或者某个计算IP变更都需要到信息中心申请变更hosts文件。其他计算机也需要定期更新，才能上网。但是这样太麻烦了，就出现了DNS系统。</li>
<li>其实我们现在的电脑上面也是有这个文件的，就是<code>/window/systems/drivers/etc</code>下面也有hosts文件。注释里面很清楚写着，这个文件“used by Microsoft TCP/IP for Windows.”</li>
<li>目前的DNS系统中，如果有 hosts文件，仍旧会优先查询这个文件的</li>
</ul>
<h3 id="流程"><a class="header-anchor" href="#流程"></a>流程</h3>
<ul>
<li>过程相当的简单明了啊。client端发消息给域名解析服务器，服务器在自己里面一顿找，有就直接返回</li>
<li>没有就去根服务器找，根服务器找了之后会存到低一次没找到的域名解析服务器进行缓存。</li>
<li>再去找的时候就从缓存里面直接拿。不需要再去根服务器跑一趟了</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1195962/vspbulgxi2.png?imageView2/2/w/1620" alt></p>
<blockquote>
<p>图片来自参考链接1</p>
</blockquote>
<h3 id="详解"><a class="header-anchor" href="#详解"></a>详解</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825" target="_blank" rel="noopener">DNS（域名解析协议）详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1358564" target="_blank" rel="noopener">DNS 协议入门</a></li>
</ul>
</li>
</ul>
<h4 id="域名"><a class="header-anchor" href="#域名"></a>域名</h4>
<p>好吧，要了解DNS协议，首先要了解域名。各种域名都隶属于域名系统根域的下级。</p>
<ul>
<li>域名是分层次的。第一级域名，比如com，代表公司，这是company的缩写吧。再比如org,嗯，我看出来了，organization的开头。net网络提供商。大家有严格遵守吗?</li>
<li>第二级域名其实是公司名，比如baidu，bing。微软为啥叫bing啊。</li>
<li>对应不同层级的域名，有相应的服务器。根域名服务器之类。每一级域名服务器都知道下级域名服务器的IP地址。这个按照上面的流程也能知道。应该下层也知道上一层的地址，不然没法求助啊。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/DNS_domain_name.png" alt></p>
<blockquote>
<p>图片来自上面的参考链接1</p>
</blockquote>
<h4 id="协议"><a class="header-anchor" href="#协议"></a>协议</h4>
<ul>
<li>DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。</li>
<li>上面提到不同层级的域名会有不同层级的域名服务器来对应，每一层级也有主副服务器，辅助服务器与主服务器会进行同步，这个时候会用TCP协议，大批量数据传输，TCP是相对稳定的链接</li>
<li>而客户端向域名服务器查询时候用的是UDP协议， 效率更高，不需要经过三次握手</li>
</ul>
<h4 id="实现"><a class="header-anchor" href="#实现"></a>实现</h4>
<ul>
<li><code>dnsjava</code>是DNS的一个Java实现。这是一个3pp。还有其他一些实现，比如<code>dns4j</code>，<code>dnsjnio</code>，<code>jdnss</code>,<code>eagledns</code>。</li>
<li>要打开dnsjava的log，需要将设置<code>System.setProperty(&quot;dnsjava.options&quot;,&quot;verbose&quot;);</code> 这种操作也真是比较老了。</li>
<li>maven dependency是以下这样。</li>
</ul>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;dnsjava&lt;/groupId&gt;
   &lt;artifactId&gt;dnsjava&lt;/artifactId&gt;
   &lt;version&gt;2.1.7&lt;/version&gt;
</code></pre>
<ul>
<li><code>dnsjava</code>类图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/dnsjava_class_diagram.png" alt></p>
<ul>
<li>
<p><code>dnsjava</code> 流程图<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/dnsjava_sequence_diagram.png" alt></p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/zhu_tianwei/article/details/45128537" target="_blank" rel="noopener">DNS BIND之dnsjava java客户端操作</a></li>
</ul>
</li>
</ul>
<h4 id="使用"><a class="header-anchor" href="#使用"></a>使用</h4>
<ul>
<li><code>lookup</code>遇到错误“network error”，这个是因为在以下原因。 其实我碰到的就是BindException，“address already in use”</li>
<li>参考链接：
<ul>
<li><a href="https://coderanch.com/t/585844/java/org-xbill-DNS-Lookup-error" target="_blank" rel="noopener">org.xbill.DNS.Lookup() error.</a></li>
<li><a href="https://github.com/dnsjava/dnsjava/issues/71" target="_blank" rel="noopener">我自己报的issue</a></li>
<li><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.xbill.DNS.ExtendedResolver" target="_blank" rel="noopener">Java Code Examples for org.xbill.DNS.ExtendedResolver</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/06/25/Cassandra_Maintain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/06/25/Cassandra_Maintain/" itemprop="url">Cassandra Maintain</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T17:01:57+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index">
                    <span itemprop="name">cassandra</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://thelastpickle.com/blog/2016/07/27/about-deletes-and-tombstones.html" target="_blank" rel="noopener">关于Cassandra的删除和墓碑</a></li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html#defragmentation" target="_blank" rel="noopener">最新官方文档，非常清楚</a></li>
<li><a href="https://zhaoyanblog.com/archives/966.html" target="_blank" rel="noopener">有上篇文章的翻译</a></li>
<li><a href="https://www.cnblogs.com/didda/p/4728588.html" target="_blank" rel="noopener">Cassandra 的压缩策略STCS，LCS 和 DTCS</a></li>
</ul>
<h2 id="delete-data"><a class="header-anchor" href="#delete-data"></a>Delete Data</h2>
<ul>
<li>找了一下博客，发现居然都没有一个章节是关于删除数据的</li>
<li>事实上，<code>Cassandra</code>里面的删除是一种写操作，会插入墓碑。在上面的参加链接里面详尽描述了这个过程</li>
<li>可以使用<code>SSTabledump</code>命令来进行查询。<strong><em>但是并没有在我们的环境中找到这个命令</em></strong></li>
<li>需要注意的是这里讨论的都是删除之后再<code>flush</code>到<code>SSTable</code>里的情况，<code>Memtable</code>里面的数据删除会有所不痛</li>
<li><code>gc_grace_seconds</code>：在删除数据之后会保存一段时间的墓碑，以此来保证数据同步。</li>
</ul>
<h3 id="删除某一行的某个数据"><a class="header-anchor" href="#删除某一行的某个数据"></a>删除某一行的某个数据</h3>
<ul>
<li>
<p>可以只删除某一行的某一个数据，如下</p>
</li>
<li>
<p>当删除掉某一行的某个数据的时候，使用上面的<code>SSTabledump</code>命令，这一行数据将没有<code>liveness_info</code></p>
<pre><code>DELETE crates FROM tlp_lab.tombstones WHERE fruit='apple' AND date ='20160617';
</code></pre>
</li>
</ul>
<p>那么这个数据会显示<code>null</code></p>
<pre><code>  alain$ echo &quot;SELECT * FROM tlp_lab.tombstones LIMIT 100;&quot; | cqlsh
  fruit   | date     | crates
  ---------+----------+-----------------
  apple | 20160617 |            null
</code></pre>
<h3 id="删除一行的数据"><a class="header-anchor" href="#删除一行的数据"></a>删除一行的数据</h3>
<ul>
<li>
<p>删除掉一行之后，这一行的数据的<code>cell</code>也将没有任何数据</p>
<pre><code>&quot;rows&quot; : [
{
  &quot;type&quot; : &quot;row&quot;,
  &quot;position&quot; : 19,
  &quot;clustering&quot; : [ &quot;20160617&quot; ],
  &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:31:41.142454Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:31:41Z&quot; },
  &quot;cells&quot; : [ ]
}

&quot;rows&quot; : [
{
  &quot;type&quot; : &quot;row&quot;,
  &quot;position&quot; : 125,
  &quot;clustering&quot; : [ &quot;20160616&quot; ],
  &quot;liveness_info&quot; : { &quot;tstamp&quot; : &quot;2016-06-16T18:52:41.903751Z&quot;, &quot;ttl&quot; : 2592000, &quot;expires_at&quot; : &quot;2016-07-16T18:52:41Z&quot;, &quot;expired&quot; : false },
  &quot;cells&quot; : [
    { &quot;name&quot; : &quot;crates&quot;, &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T18:52:41.903750Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T18:52:41Z&quot; } },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;6&quot; ], &quot;value&quot; : &quot;&quot; },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;7&quot; ], &quot;value&quot; : &quot;&quot; },
    { &quot;name&quot; : &quot;crates&quot;, &quot;path&quot; : [ &quot;8&quot; ], &quot;value&quot; : &quot;&quot; }
  ]
}
</code></pre>
</li>
</ul>
<h3 id="删除一个范围内的数据"><a class="header-anchor" href="#删除一个范围内的数据"></a>删除一个范围内的数据</h3>
<ul>
<li>
<p>这个含义就是，比如下面的命令，这样可以一次性删除好几行数据</p>
<pre><code>DELETE FROM tlp_lab.tombstones WHERE fruit='apple' AND date &gt; '20160615';
</code></pre>
</li>
<li>
<p>那么存下来的数据会变为，<code>type</code>变化了</p>
<pre><code>&quot;rows&quot; : [
    {
      &quot;type&quot; : &quot;range_tombstone_bound&quot;,
      &quot;start&quot; : {
        &quot;type&quot; : &quot;exclusive&quot;,
        &quot;clustering&quot; : [ &quot;20160615&quot; ],
        &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:53:21.133300Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:53:21Z&quot; }
      }
    },
    {
      &quot;type&quot; : &quot;range_tombstone_bound&quot;,
      &quot;end&quot; : {
        &quot;type&quot; : &quot;inclusive&quot;,
        &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-16T19:53:21.133300Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-16T19:53:21Z&quot; }
      }
</code></pre>
</li>
</ul>
<h3 id="删除一个partition的数据"><a class="header-anchor" href="#删除一个partition的数据"></a>删除一个partition的数据</h3>
<ul>
<li>
<p>命令如下：</p>
<pre><code>DELETE FROM tlp_lab.tombstones WHERE fruit='pickles';
</code></pre>
<p>会在<code>partition</code>的地方加入<code>deletion_info</code>，而通常情况下只有<code>key</code>和<code>position</code></p>
<pre><code>{
  &quot;partition&quot; : {
    &quot;key&quot; : [ &quot;pickles&quot; ],
    &quot;position&quot; : 0,
    &quot;deletion_info&quot; : { &quot;marked_deleted&quot; : &quot;2016-06-17T09:38:52.550841Z&quot;, &quot;local_delete_time&quot; : &quot;2016-06-17T09:38:52Z&quot; }
}
  
&quot;partition&quot; : {
   &quot;key&quot; : [ &quot;apple&quot; ],
   &quot;position&quot; : 0
},  
</code></pre>
</li>
</ul>
<h3 id="集合数据"><a class="header-anchor" href="#集合数据"></a>集合数据</h3>
<ul>
<li>需要额外注意的一点是，如果使用集合数据，比如<code>list</code>，那么在更新的时候，会有一个潜在的删除操作。会将旧的数据删除，这一点非常恼人，需要注意</li>
</ul>
<h3 id="gc-grace-seconds参数"><a class="header-anchor" href="#gc-grace-seconds参数"></a>gc_grace_seconds参数</h3>
<ul>
<li><code>gc_grace_seconds</code>参数的默认值为10天，这个参数的意思就是这个数据被删除之后，相应的<code>tombstone</code>也不会立刻在<code>compaction</code>中被移除</li>
<li>这个值的目的是为了保证删除的一致性。以防有的节点上面删除失败，出现幽灵数据。在维护操作章节中有进一步的解释。假设有删除失败，然后客户做了<code>repair</code>操作，那么这个数据会被复制到已经删除的节点上面。那么就错了。相反，如果是插墓碑，即使有节点没插上，<code>repair</code>的时候也只会复制个墓碑过去。这也就是为什么需要需要维持一阵墓碑</li>
</ul>
<h2 id="维护操作"><a class="header-anchor" href="#维护操作"></a>维护操作</h2>
<ul>
<li><code>minor compaction</code>: 这个就是<code>C#</code>自己做的压缩</li>
<li><code>major compaction</code>: 这个就是手动的用<code>nodetool</code>做的，会对所有的当前<code>node</code>上面的<code>SSTable</code>进行压缩</li>
<li><code>user defined compaction</code>： 客户自定义的，对部分<code>SSTable</code>进行压缩。用户可以只针对一张表来做压缩，Cassandra会对数据进行校验，使用<code>unchecked_tombstone_compaction</code> 参数可以跳过这个校验过程</li>
<li><code>Scrub</code>: 这个操作会尝试修复<code>SSTable</code>，所以这个动作有可能会删除有效但是已经坏掉的数据，如果这个发生，得用<code>repair</code>来修复</li>
<li>在以下的参考链接里面还有一些奇特的维护操作，暂时没学习</li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html" target="_blank" rel="noopener">维护操作和压缩</a></li>
</ul>
<h2 id="compacting-sstable-data"><a class="header-anchor" href="#compacting-sstable-data"></a>Compacting SSTable Data</h2>
<p><img src="https://docs.datastax.com/en/cassandra/3.0/cassandra/images/dml_compaction.png" alt="官网压缩数据图片"></p>
<h3 id="为什么需要compaction"><a class="header-anchor" href="#为什么需要compaction"></a>为什么需要Compaction</h3>
<ul>
<li><code>cassandra</code>并不会删除数据。当需要<code>update</code>一个数据的时候，也不是在<code>SSTable</code>里面进行覆盖，而是会插入一个新的数据，带上新的<code>version</code>。</li>
<li>这样做的话，<code>cassandra</code>写入数据会非常快，因为不需要查询，但是弊端就是会有越来越多的数据。</li>
<li>这个时候就需要进行<code>compaction</code>。</li>
</ul>
<h3 id="什么是compaction"><a class="header-anchor" href="#什么是compaction"></a>什么是Compaction</h3>
<ul>
<li>To keep the multiple versions of the SSTables from overwhelming it, the database merges SSTables on a regular basis to get rid of the older versions of the data。 <code>cassandra</code>会在一个基础之上对旧的版本的数据进行合并，这个就是<code>compaction</code></li>
<li><code>cassandra</code>默认会进行很多次小的<code>compaction</code>。在有新生成<code>SStable</code>的时候，或者默认5分钟会进行一次检查，需不需要进行<code>minor compaction</code></li>
<li>会合并同一行的，不同版本的数据。不同版本带着不同的<code>timestamp</code></li>
</ul>
<h3 id="什么情况下墓碑会在compaction中被移除"><a class="header-anchor" href="#什么情况下墓碑会在compaction中被移除"></a>什么情况下墓碑会在Compaction中被移除</h3>
<ul>
<li>这也是来自上篇参考文档的。这篇文档比较清楚</li>
<li>事实上有好几个要求：
<ul>
<li><code>gc_grace_seconds</code> 已经过了，这点已经在上面解释过了</li>
<li>_If partition X contains the tombstone, the sstable containing the partition plus all sstables containing data older than the tombstone containing X must be included in the same compaction. We don’t need to care if the partition is in an sstable if we can guarantee that all data in that sstable is newer than the tombstone. If the tombstone is older than the data it cannot shadow that data._这句话实在太拗口了，含义就是说墓碑得是最老的一个，否则删除不掉？</li>
<li><code>only_purge_repaired_tombstones</code> 这还有一个参数，如果不是repair过程中的墓碑就不删除。这个参数估计很少用吧</li>
<li>还有一个特殊情况，就是整个<code>SSTable</code>里面都是墓碑，这种情况在以时间序列的表并且使用了<code>TTL</code>之后很容易出现。如果没有被整表删除，那么就像上一个bullet里面讲的，说明其他表里面有更老的数据。有一个工具<code>sstableexpiredblockers</code>可以进行查询。还有一个参数可以使用<code>unsafe_aggressive_sstable_expiration</code>，在使用时间压缩策略时候，这个参数可以保证删除这种表</li>
</ul>
</li>
</ul>
<h3 id="compaction的参数和命令"><a class="header-anchor" href="#compaction的参数和命令"></a>compaction的参数和命令</h3>
<ul>
<li>在上篇链接中有，列一部分：
<ul>
<li><code>log_all</code>: 可以记录压缩的日志</li>
<li><a href="http://cassandra.apache.org/doc/latest/operating/compaction.html" target="_blank" rel="noopener">维护操作和压缩</a></li>
</ul>
</li>
<li>命令在上面的链接中也有，这边也列一部分：
<ul>
<li><code>compactionstats</code>: 状态</li>
<li><code>compactionhistory</code>: 历史</li>
</ul>
</li>
<li>如果是在一个正在运行的系统中改变表的参数，可以使用<code>ALTER TABLE</code>命令来进行</li>
</ul>
<h3 id="其他一些campaction细节"><a class="header-anchor" href="#其他一些campaction细节"></a>其他一些Campaction细节</h3>
<ul>
<li>在<code>compaction</code>期间，<code>cassandra</code>会合并<code>key</code>和<code>column</code>，同时会将过期的墓碑删除，还会生成一个新的<code>index</code>？ <strong><em>这个index是什么东西啊</em></strong></li>
<li>合并之后会生成一个新的<code>SSTable</code>。而不需要的数据版本和行就会留在旧的<code>SSTable</code>里面，当正在执行的读操作结束之后，就可以删除掉。</li>
<li><code>compaction</code>期间的资源耗用会上升，但是<code>compaction</code>结束之后应该会释放空间，因为它合并了<code>SSTable</code></li>
<li>旧的被合并的<code>table</code>会被加上<code>deletion</code>标签，并且在数据库重启或者在使用<code>reference counting mechanism</code>的时候。<strong><em>这个<code>reference counting mechanism</code>是什么啊</em></strong></li>
<li><code>compaction</code>的算法是可以配置的，默认的是<code>size-tiered compaction</code>。这个算法会合并大小相近的table，生成大table</li>
</ul>
<h3 id="compaction对读数据的影响"><a class="header-anchor" href="#compaction对读数据的影响"></a>Compaction对读数据的影响</h3>
<ul>
<li><code>compaction</code>是<code>per-node</code>的，所以某个数据在<code>node1</code>上面的旧版本可能删除了。但是在<code>node2</code>上面还有。</li>
<li>这样读的时候会进行一个合并，并且返回最后一个写的<code>version</code>。这个原则是<code>last-write-win</code></li>
<li>Cassandra can read data directly from the new SSTable even before it finishes writing, instead of waiting for the entire compaction process to finish.</li>
</ul>
<h3 id="compaction-策略"><a class="header-anchor" href="#compaction-策略"></a>Compaction 策略</h3>
<ul>
<li>不同的策略决定了如何来选择<code>SSTable</code>以及压缩后的行如何插入到新的表格中</li>
<li>我在压缩策略的道路上越走越远了啊。😂</li>
</ul>
<h4 id="sizetieredcompactionstrategy-stcs"><a class="header-anchor" href="#sizetieredcompactionstrategy-stcs"></a>SizeTieredCompactionStrategy (STCS)</h4>
<h5 id="工作流程"><a class="header-anchor" href="#工作流程"></a>工作流程</h5>
<ul>
<li>当有4个大小相近的<code>STable</code>的时候就开始合并，所以并不是完全相同大小的</li>
<li>将这些大小相近的<code>SSTable</code>合并成一个，当有4个更大的<code>table</code>的时候，再合并成更大的<code>SSTable</code></li>
<li>所以会有很多大小不同的<code>SSTable</code>同时存在</li>
</ul>
<h4 id="参数"><a class="header-anchor" href="#参数"></a>参数</h4>
<h5 id="优缺点"><a class="header-anchor" href="#优缺点"></a>优缺点</h5>
<ul>
<li>优势：写密集的工作良好。</li>
<li>逆势：
<ul>
<li>可能降低读的效率。因为策略不保证同一行的数据被限制在有限的数据文件里面，这样在读取的时候会需要读取更多的数据文件。</li>
<li>可能长期保持旧数据；不同版本的同一行会可能分布在不同的<code>SSTable</code>里面。并且不利于删除旧数据</li>
<li>需要的内存和磁盘都会随着时间增加。磁盘在下面的问题章节中可以看到；而内存也是显而易见的，当<code>SSTable</code>的大小达到一定级别，一次压缩需要的内存会很大。因为需要<code>load SSTable</code>到内存里面</li>
</ul>
</li>
</ul>
<h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5>
<ul>
<li>
<p>在实际的工作中碰到了缺点中的问题，系统在工作3个月的时候能够在一个节点上面占用靠13G的磁盘量。</p>
</li>
<li>
<p>观察下来，其实策略是在正常工作的。里面明显能够看到大小不同的data文件。</p>
</li>
<li>
<p>现在客户的需求是不手动操作来解决占用磁盘的问题。总的来说，貌似不现实，毕竟多数建议是关闭自动SSTable压缩，改用手动在空闲期间进行压缩</p>
<pre><code>total 13G
 115M Jan 24  2019 la-2421-big-Data.db
 101M Jan 24  2019 la-2443-big-Data.db
 453K Jan 24  2019 la-2447-big-Data.db
 124M Feb  3 14:47 lb-5276-big-Data.db
 216M Feb  3 14:54 lb-5280-big-Data.db
 235M Feb  3 14:54 lb-5281-big-Data.db
 680M Feb  4 11:24 lb-5294-big-Data.db
 781M Feb  4 11:36 lb-5295-big-Data.db
 2.8G Feb  4 11:54 lb-5296-big-Data.db
 3.3G Feb  4 12:52 lb-5298-big-Data.db
 3.5G Feb  4 12:54 lb-5297-big-Data.db
</code></pre>
</li>
</ul>
<h4 id="leveledcompactionstrategy-lcs"><a class="header-anchor" href="#leveledcompactionstrategy-lcs"></a>LeveledCompactionStrategy (LCS)</h4>
<h5 id="工作流程-v2"><a class="header-anchor" href="#工作流程-v2"></a>工作流程</h5>
<ul>
<li>
<p>LCS的工作流程是最不清晰的了。网上各类文章，有说L1的数据文件数量是L0的10倍的，有说整体大小的。我一口血都要喷显示器上面了,不带这么不严谨的好嘛 😦</p>
</li>
<li>
<p>看代码其实最清楚了。应该是大小，不是数量：</p>
</li>
<li>
<p>以下代码里面，maxSSTableSizeInBytes= 160M * 1024<em>1024，所以L0最大是160M</em>4</p>
</li>
<li>
<p>代码在<code>org.apache.cassandra.db.compaction.LeveledCompactionStrategy</code></p>
<pre><code>public static long maxBytesForLevel(int level, int levelFanoutSize, long maxSSTableSizeInBytes) {
  if (level == 0) {
      return 4L * maxSSTableSizeInBytes;
  } else {
      double bytes = Math.pow((double)levelFanoutSize, (double)level) * (double)maxSSTableSizeInBytes; 
  }
}
</code></pre>
</li>
<li>
<p><code>LCS</code>一大特点是会尽量保证在同一个层级里面，同一<code>partition key</code>的数据在同一张<code>SSTable</code>表里面。当然<code>L0</code>没法保证，因为这一层级是<code>flush</code>来的</p>
</li>
<li>
<p>为了做到这一点，<code>LCS</code>在进行一次压缩的时候会包括上一级中也有这个<code>partition key</code>的数据，所以这个策略要读表啊。比如在<code>L1</code>级数据大于上限需要压缩的时候，<code>L2</code>级中包含相同<code>key</code>的表也要被一起合并，但是欣慰的是，应该也只有一张表。毕竟每一级都是这么干的。-</p>
</li>
<li>
<p>我们在<code>Cassandra</code>中可以设定进行并行的压缩，那么在<code>LCS</code>策略中需要保证同一个<code>parititon key</code>的数据只在一个压缩线程中，不能有交叉重叠</p>
</li>
<li>
<p>所以，压缩<code>L0</code>层级的时候，会带上所有<code>L1</code>的表一起压缩。如果<code>L0</code>很多，那么没法一次压缩做完所有<code>L0</code>的表格</p>
</li>
<li>
<p>压缩时候优先考虑最高级别的。所有<code>L0</code>是最后考虑的一个层级</p>
</li>
<li>
<p><code>LCS</code>有可能触发<code>major compaction</code>，这点需要进一步考察。</p>
</li>
<li>
<p>如果<code>L0</code>级别的表超过32个，会进行<code>STCS</code></p>
</li>
</ul>
<h5 id="相关参数"><a class="header-anchor" href="#相关参数"></a>相关参数</h5>
<ul>
<li><code>sstable_size_in_mb</code>: 就是上面代码里面那个<code>maxSSTableSizeInBytes</code>，第一层级的大小</li>
<li><code>fanout_size</code>： 各个层级之间的差异，上面代码里面的<code>levelFanoutSize</code></li>
</ul>
<h5 id="优缺点-v2"><a class="header-anchor" href="#优缺点-v2"></a>优缺点</h5>
<ul>
<li>优点：
<ul>
<li>读比较频繁的更推荐这个算法。其实写的应该也可以。目前这应该是应用最广泛的压缩算法了。</li>
<li>容易预测内存需求大小</li>
<li>更容易删除旧数据</li>
<li>需要的磁盘空间更小</li>
</ul>
</li>
<li>缺点：
<ul>
<li>进行得更为频繁，所以需要的I/O比较多</li>
</ul>
</li>
</ul>
<h4 id="timewindowcompactionstrategy-twcs"><a class="header-anchor" href="#timewindowcompactionstrategy-twcs"></a>TimeWindowCompactionStrategy (TWCS)</h4>
<ul>
<li>接上文碰到的问题，刚刚好出问题的表的<code>partition key</code>是日期，所以研究得最多的就是这个策略了。而时间策略是唯一一个可以彻底删除过期的表的策略。当然，要结合下面的<code>TTL</code>一起用。</li>
<li>需要注意的一点是：<code>TCWS</code>是从<code>Cassandra 3.0.8</code>才被引入的。而我们产品仍旧停留在<code>2.2.8</code>上，这也是为什么最后没法采用这个解决方案</li>
</ul>
<h5 id="工作原理"><a class="header-anchor" href="#工作原理"></a>工作原理</h5>
<ul>
<li>这个算法挺有意思的，而且简单好懂。就是说在一段时间内，比如一个小时内，使用<code>STCS</code>算法，然后在时间点上，一个小时结束的时候，把这个小时内的都压成一个大的数据文件。</li>
<li>第二个小时开始的时候，重新算起，上一个小时压出来的大表就放那里不动了。</li>
</ul>
<h5 id="相关参数-v2"><a class="header-anchor" href="#相关参数-v2"></a>相关参数</h5>
<ul>
<li><code>compaction_window_unit</code>:MINUTES, HOURS, or DAYS</li>
<li><code>compaction_window_size</code>:默认为1</li>
<li><code>unsafe_aggressive_sstable_expiration</code>: 这个参数很有意思，就是说当一个表里面都是墓碑的时候，直接把表删除掉。这个参数是一个全局参数，是在启动<code>JVM</code>的时候设置的。因为是有风险的，有可能造成幽灵数据。同时，设置这个参数会覆盖掉<code>unchecked_tombstone_compaction</code>.</li>
</ul>
<h5 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h5>
<ul>
<li><a href="https://thelastpickle.com/blog/2016/12/08/TWCS-part1.html" target="_blank" rel="noopener">TWCS-part1</a></li>
<li><a href="https://thelastpickle.com/blog/2017/01/10/twcs-part2.html" target="_blank" rel="noopener">TWCS-part2</a></li>
</ul>
<h3 id="ttl"><a class="header-anchor" href="#ttl"></a>TTL</h3>
<h4 id="ttl被提出的背景"><a class="header-anchor" href="#ttl被提出的背景"></a>TTL被提出的背景</h4>
<ul>
<li>这是在处理产品的一个问题的时候被提出的，该问题就是，由于某个统计功能一直在写数据，然后每隔一个月左右会删除数据。</li>
<li>表格以<code>date</code>作为<code>partition key</code>，所有数据在一个表里面，所以即使数据被删除了也没法直接<code>truncate</code>表，只能依赖<code>Cassandra</code>的<code>compaction</code>。</li>
<li>最后越来越占磁盘。使用的策略是默认的<code>STCS</code>。然后就有大佬提了<code>TTL</code></li>
<li>我原本在考虑加<code>crontab job</code>，但是其实没有意义，因为<code>Cassandra</code>提供的其实就是类似功能。</li>
</ul>
<h4 id="什么是ttl-time-to-live"><a class="header-anchor" href="#什么是ttl-time-to-live"></a>什么是TTL(time-to-live)</h4>
<ul>
<li><em>TTL: allows to specify an optional Time To Live (in seconds) for the inserted values. If set, the inserted values are automatically removed from the database after the specified time. Note that the TTL concerns the inserted values, not the column themselves. This means that any subsequent update of the column will also reset the TTL (to whatever TTL is specified in that update). By default, values never expire. A TTL of 0 or a negative one is equivalent to no TTL.</em></li>
<li>其实<code>Cassandra</code>里面<code>TTL</code>的概念到处都是。但是通常说的<code>TTL</code>是指参数<code>default_time_to_live</code>，也就是说到了这个时间点，<code>Cassandra</code>会自动将数据删除掉。</li>
<li>默认值为0，也就是<code>Cassandra</code>会认为这个数据一直有效</li>
<li>这个参数在<code>desc tables</code>里面可以看到，但是我们产品的异步模块里面其实在代码里面进行了覆盖。<code>java</code>代码里面弄了个系统参数，在插入数据的时候代入了这个参数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/06/17/软件衡量标准/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/06/17/软件衡量标准/" itemprop="url">软件衡量标准</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T17:20:49+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工作中接触到一些软件衡量标准的需求，必须对这些概念有所了解和理解。所以解释如下了。</p>
<h3 id="scalability"><a class="header-anchor" href="#scalability"></a>Scalability</h3>
<ul>
<li>
<blockquote>
<p>Scalability is the property of a system to handle a growing amount of work by adding resources to the system 维基百科里面的这个解释实在很到位啊。通过加资源来获得更大的能力</p>
</blockquote>
</li>
<li>以下内容基本是维基百科的翻译：
<ul>
<li>用户可扩展性： 能够同时支持多少用户</li>
<li>功能可扩展性： 能不能扩展功能，而不会影响现有功能</li>
<li>地理上的可扩展性： 就是直接的字面含义，类似部署时候的机器是不是必须local在一起。</li>
<li>负载可扩展性： 这就是我们通常意义上面知道的，加node或者加cpu，加内存，能不能够加可处理的能力</li>
<li>代扩展性： 这个有点难以理解，我理解成能不能支持不同版本。比如说，我同时安装java8和java7，那么我可以在maven里面指定生成的代码之类的</li>
<li>种类的可扩展性： 这个可以理解的，就是是不是支持multi-verdor。就像java，可以在windows上面，也可以在linux上面</li>
</ul>
</li>
<li>Scaling horizontally： 就是增减node</li>
<li>Scaling vertically： 增减resource，增减cpu或者内存</li>
<li>总的来说，还是挺复杂的。</li>
<li>参考链接：
<ul>
<li><a href="https://en.wikipedia.org/wiki/Scalability" target="_blank" rel="noopener">维基百科</a></li>
</ul>
</li>
</ul>
<h3 id="testability"><a class="header-anchor" href="#testability"></a>Testability</h3>
<p>testability跟我想象的稍有不同，就是说这个模块或者软件的可测试性。实在有点复杂啊</p>
<ul>
<li>总的来说，感觉实在是太抽象了。 <strong><em>没看懂</em></strong>
<ul>
<li>Class I: there exists a finite complete test suite.</li>
<li>Class II: any partial distinguishing rate (i.e. any incomplete capability to distinguish correct systems from incorrect systems) can be reached with a finite test suite.</li>
<li>Class III: there exists a countable complete test suite.</li>
<li>Class IV: there exists a complete test suite.</li>
<li>Class V: all cases.</li>
</ul>
</li>
<li>参考链接：<br>
+<a href="https://en.wikipedia.org/wiki/Software_testability" target="_blank" rel="noopener">维基百科</a></li>
</ul>
<h3 id="robustness-computer-science"><a class="header-anchor" href="#robustness-computer-science"></a>Robustness (computer science)</h3>
<ul>
<li>robustness is the ability of a computer system to cope with errors during execution and cope with erroneous input。跟想象的不一样啊，更多focus的是handle error的能力</li>
<li>参考链接：
<ul>
<li>[维基百科](<a href="https://en.wikipedia.org/wiki/Robustness_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robustness_(computer_science)</a></li>
</ul>
</li>
</ul>
<h3 id="computer-security"><a class="header-anchor" href="#computer-security"></a>Computer Security</h3>
<ul>
<li>the protection of computer systems from theft or damage to their hardware, software or electronic data, as well as from disruption or misdirection of the services they provide.</li>
<li>参考链接
<ul>
<li><a href="https://en.wikipedia.org/wiki/Computer_security" target="_blank" rel="noopener">维基百科</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/06/17/Java数据类型-一些特别的数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/06/17/Java数据类型-一些特别的数据类型/" itemprop="url">Java数据类型 --- 一些特别的数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T13:14:34+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="java-util-function-supplier"><a class="header-anchor" href="#java-util-function-supplier"></a>java.Util.Function.Supplier</h3>
<ul>
<li>这个接口只有一个方法，Get方法。void，返回一个T</li>
<li>把它当工厂方法看就是了。</li>
<li>顾名思义，提供者。</li>
<li><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">JAVA8 Supplier接口</a></li>
<li>感觉就是一次性生成。同一个接口，在初始化时候给出get函数，可以有不同实现</li>
<li>supplier作为function interface，有@FunctionalInterface annotation。所以可以直接用lamda来作为实现。比如：<code>()-&gt;getString()</code>可以作为<code>Supplier&lt;String&gt;</code>的实现</li>
</ul>
<h3 id="java关键字native"><a class="header-anchor" href="#java关键字native"></a>java关键字native</h3>
<p>我要看native的函数。找不到，OMG。其实之前看到过native的用法，知道这个玩意，但是还是写在这里吧。<br>
感觉一片参考链接就能解释清楚啦。</p>
<ul>
<li>其实就是java吧，不像c和c++善于处理底层的东西。所以就会调用一些不是java写的函数。这些函数就用native关键字来修饰</li>
<li>native是通过JNI（Java Native Interface）接口来调用这些函数的</li>
<li>参考链接
<ul>
<li><a href="https://www.cnblogs.com/b3051/p/7484501.html" target="_blank" rel="noopener">java中native的用法</a></li>
</ul>
</li>
</ul>
<h3 id="生成random的方法"><a class="header-anchor" href="#生成random的方法"></a>生成Random的方法</h3>
<p>有好几个相关的类型，写在这里。是在工作中需要生成随机<code>port</code>碰到的</p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.jianshu.com/p/2f6acd169202#" target="_blank" rel="noopener">Java 随机数 Random VS SecureRandom</a></li>
<li><a href="https://www.bbsmax.com/A/kjdwxba6zN/" target="_blank" rel="noopener">Java中的随机数生成器：Random，ThreadLocalRandom，SecureRandom</a></li>
<li><a href="http://ju.outofmemory.cn/entry/286621" target="_blank" rel="noopener">Java中生成随机数Random、ThreadLocalRandom、SecureRandom</a></li>
<li><a href="https://blog.csdn.net/weixin_33738555/article/details/93434637" target="_blank" rel="noopener">SecureRandom的正确使用</a></li>
<li><a href="https://blog.csdn.net/weixin_35703883/article/details/81138425" target="_blank" rel="noopener">SecureRandom生成随机数</a></li>
<li><a href="https://www.cnblogs.com/deng-cc/p/8064481.html" target="_blank" rel="noopener">SecureRandom</a></li>
</ul>
</li>
</ul>
<h4 id="math-random"><a class="header-anchor" href="#math-random"></a>Math.random</h4>
<ul>
<li>产生的随机数是0 - 1 之间的一个 double，即0 &lt;= random &lt; 1。</li>
<li>第一次调用<code>Math.random()</code>方法时，自动创建了一个伪随机数生成器，实际上用的是 <code>new java.util.Random()</code>。</li>
<li><code>Math.random()</code>方法是线程安全的。</li>
</ul>
<h4 id="java-util-random"><a class="header-anchor" href="#java-util-random"></a>java.util.Random</h4>
<ul>
<li><code>Random</code>类中实现的随机算法是伪随机，也就是有规则的随机</li>
<li>种子一样的情况下，两个<code>Random</code>类产生的是一模一样的数列</li>
<li>所以在安全性要求比较高，或者使用比较频繁时，不适合使用<code>Random</code>，因为值是可预测的</li>
<li>然后生成的随机数是左边闭环，右边开的。</li>
</ul>
<h4 id="java-security-securerandom"><a class="header-anchor" href="#java-security-securerandom"></a>java.security.SecureRandom</h4>
<ul>
<li><code>SecureRandom</code> 其实和<code>Random</code>一样，种子一样的时候生成的数列是固定的</li>
<li>也是继承至 java.util.Random。</li>
<li>不一样的是，<code>SecureRandom</code>收集了一些随机事件，比如鼠标点击，键盘点击等等， 使用这些随机事件作为种子</li>
<li>通过new来初始化，在不适用任何源的情况下，就是说无参数构造函数的话，默认来说会使用<code>NativePRNG</code>算法生成随机数</li>
<li>不要使用人为指定的源，尽量使用系统的随机源。系统的随机源在java8中是可以配置的，配置在<code>$JAVA_HOME/jre/lib/security/java.security</code>中的<code>securerandom.source</code>属性。例如jdk1.8中该配置为:<code>securerandom.source=file:/dev/random</code></li>
<li>实际上SHA1PRNG的性能将近要比NativePRNG的性能好一倍，synchronized的代码少了一半，所以没有特别重的安全需要，尽量使用SHA1PRNG算法生成随机数。</li>
</ul>
<h4 id="java-util-concurrent-threadlocalrandom"><a class="header-anchor" href="#java-util-concurrent-threadlocalrandom"></a>java.util.concurrent.ThreadLocalRandom</h4>
<ul>
<li>java7之后引进的</li>
<li>继承自java.util.Random</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/05/15/Cassandra的repair机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/05/15/Cassandra的repair机制/" itemprop="url">Cassandra的repair机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T17:52:05+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index">
                    <span itemprop="name">cassandra</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cassandra的repair机制"><a class="header-anchor" href="#cassandra的repair机制"></a>Cassandra的repair机制</h2>
<p>这篇讨论一些robustness的东西。主要就是一个节点down了会怎么样。其实目前知道的就是hint，但是记录下来。<br>
从一些文档里面看，这个属于写流程的一部分。确实是，读的话，如果node down了应该不会从上面读取了。会写到the coordinator node上面。version 1.0有所不同，但是这个版本太旧了。</p>
<blockquote>
<p>By design, hinted handoff inherently allows Cassandra to continue performing the same number of writes even when the cluster is operating at reduced capacity.</p>
</blockquote>
<h3 id="hinted-handoff简述"><a class="header-anchor" href="#hinted-handoff简述"></a>Hinted Handoff简述</h3>
<ul>
<li><strong><code>hinted handoff</code> 和 一般说的<code>hint</code>应该是同一个东西。</strong> 前者是一个机制，后者就是这个机制产生的事件或者记录。</li>
<li><code>hinted handoff</code>跟consistency level 相关，毕竟这个是写机制的一部分。</li>
<li>cassandra的config文件里面需要配置几个参数：
<ul>
<li><code>hinted_handoff_enabled</code>：默认为true，打开这个机制</li>
<li><code>max_hint_window_in_ms</code>： 为已经down掉的node记录hint log的时间长度</li>
<li><code>gc_grace_seconds</code>: Configures the time-to-live (TTL) period for a hint so that the database won’t replay the hint after this duration. Setting this parameter to 0 disables hints。 这个参数没用过，后面可以试试看</li>
<li><code>hinted_handoff_throttle_in_kb</code> 和    <code>max_hints_delivery_threads</code> 这两个没咋研究过，先放着吧</li>
</ul>
</li>
<li>按照文档，当写入发生时候，并且a replica node for the key is down。就可能会触发hinted handoff的机制</li>
</ul>
<h4 id="hint-详述"><a class="header-anchor" href="#hint-详述"></a>Hint 详述</h4>
<ul>
<li>
<blockquote>
<p>The hint consists of a target ID for the downed node, a hint ID that is a time UUID for the data, a message ID that identifies the Cassandra version, and the data itself as a blob.</p>
</blockquote>
<ul>
<li>hint里面有：down node的target ID， 标注这条数据的hint ID， 标注cassandra version的message ID以及数据本身</li>
<li>这是cassandra 3.0之后的。之前的可能不一样</li>
</ul>
</li>
<li>
<p>和想象地一样，当Gossipy发现downed node起来之后，coordinator node会将hint记录的数据写过去，并且删除掉hint</p>
</li>
<li>
<blockquote>
<p>The coordinator also checks every ten minutes for hints corresponding to writes that timed out during an outage too brief for the failure detector to notice through gossip.</p>
</blockquote>
</li>
<li>
<p>这句有点难以理解，看了下一句有点明白。如果有的节点宕机时间很短，而Gossdip并没有发现，那么coordinator 会返回一个exception，同时把write fail了，但是会记录一个hint。所以如果瞬间有很多短暂的fail，coordinator node会一下子压力过大，扔出overloadexception</p>
</li>
</ul>
<blockquote>
<p>If a replica node is overloaded or unavailable, and the failure detector has not yet marked the node as down, then expect most or all writes to that node to fail after the timeout triggered by write_request_timeout_in_ms, (10 seconds by default). The coordinator returns a TimeOutException exception, and the write will fail but a hint will be stored.</p>
</blockquote>
<h4 id="hint-和-consistency-level"><a class="header-anchor" href="#hint-和-consistency-level"></a>Hint 和 consistency level</h4>
<ul>
<li>
<blockquote>
<p>当一致性等级设定为ONE，QUORUM，或者ALL的时候，提示的写并不参与到一致性级别的计数中。如果没有足够的节点满足写的一致性级别需要，会抛出 UnavailableException而不是触发Hinted Handoff。（这是Casssandra和Dynamo复制模型不一样的地方之一）</p>
</blockquote>
</li>
<li>接上文，如果将consistency level设置成为Any，那么hint就算了。所以即使只是写了hint，写操作也会成功，但是这时候读数据是读不出来的。</li>
</ul>
<h3 id="repairing-data"><a class="header-anchor" href="#repairing-data"></a>Repairing Data</h3>
<ul>
<li>Read repair: The reconciliation or correction happens when a read finds an inconsistency.</li>
<li>When data is read, a read repair can resolve any data inconsistencies. When data isn’t read, you need to use either the hinted handoff or anti-entropy mechanism to resolve any data inconsistences.</li>
</ul>
<h4 id="read-repair"><a class="header-anchor" href="#read-repair"></a>Read Repair</h4>
<h4 id="anti-entropy"><a class="header-anchor" href="#anti-entropy"></a>anti-entropy</h4>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://wiki.apache.org/cassandra/HintedHandoff" target="_blank" rel="noopener">wiki上面的简介</a></li>
<li><a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsRepairNodesHintedHandoff.html" target="_blank" rel="noopener">官方</a></li>
<li><a href="http://www.cnblogs.com/sing1ee/archive/2012/07/09/2765056.html" target="_blank" rel="noopener">比较好的博客一篇</a>： 看起来很多就是官方文档的翻译</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo_blog/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/hexo_blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/hexo_blog/page/3/">3</a><a class="page-number" href="/hexo_blog/page/4/">4</a><a class="extend next" rel="next" href="/hexo_blog/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lynn Shen</p>
              <p class="site-description motion-element" itemprop="description">35岁开始的博客，有点晚哦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/hexo_blog/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/hexo_blog/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/hexo_blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/hexo_blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/hexo_blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
        <script src="https://billts.site/js/gitment.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
