<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/hexo_blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/hexo_blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/hexo_blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/hexo_blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/page/2/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="35岁开始的博客，有点晚哦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo_blog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sallyslove.github.io/hexo_blog/page/2/">





  <title>跬步</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo_blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo_blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/hexo_blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo_blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/19/ifconfig命令和网络基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/19/ifconfig命令和网络基础/" itemprop="url">ifconfig命令和网络基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T10:21:25+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/protocal/" itemprop="url" rel="index">
                    <span itemprop="name">protocal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ifconfig和ipconfig一样，实在是最常用的命令。然而，只是大概的了解。每次看一下之后，后面又会忘。<br>
网络的基本概念也是，每次都是看一点，不成系统的感觉。所以把基础网络概念放在这里。</p>
<h3 id="ifconfig"><a class="header-anchor" href="#ifconfig"></a>ifconfig</h3>
<p>这个命令是linux的</p>
<h4 id="物理地址-mac地址"><a class="header-anchor" href="#物理地址-mac地址"></a>物理地址(MAC地址)</h4>
<ul>
<li>什么是MAC地址？ MAC地址（Media Access Control Address，介质访问控制），直译为媒体访问控制地址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网上设备位置的地址。形象地说，MAC地址就如同身份证上的身份证号码，具有全球唯一性。</li>
<li>MAC地址采用十六进制数表示，共六个字节（48位）。其中，前三个字节是由IEEE的注册管理机构RA负责给不同厂家分配的代码(高位24位），也称为“编制上唯一的标识符”，后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。</li>
<li>MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</li>
<li>参考链接
<ul>
<li><a href="https://zhidao.baidu.com/question/6331169.html" target="_blank" rel="noopener">百度知道的迅速概念</a></li>
<li><a href="https://www.zhihu.com/question/21546408" target="_blank" rel="noopener">有了 IP 地址，为什么还要用 MAC 地址？</a></li>
</ul>
</li>
</ul>
<h4 id="子网掩码"><a class="header-anchor" href="#子网掩码"></a>子网掩码</h4>
<ul>
<li>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分</li>
<li>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</li>
<li>计算稍微有点绕，看知乎上面的比喻比较清楚，举例：
<ul>
<li>
<p>比如我们申请到的网络号为 <code>210.73.a.b</code>，该网络地址为c类IP地址，网络标识为<code>210.73.a</code>，主机标识是<code>b</code>。</p>
</li>
<li>
<p>假设需要16个子网。那么就是<code>1111</code></p>
</li>
<li>
<p>然后c类地址的最后一位是主机标识。那么就是<code>11110000</code>.前四位代表子网，后四位代表主机名。最后掩码是<code>255.255.255.240</code>。也可以写成<code>210.73.a.0/28</code></p>
</li>
<li>
<p>28代表28个1</p>
</li>
<li>
<p>再看知乎的例子，<code>192.168.1.x</code>分成4个子网。那么就是<code>11111111,11111111,11111111,11000000</code>， 所以第一个子网就是<code>192.168.1.0/26</code></p>
</li>
<li>
<p>看IP地址的话就是，这四个网段的开头就是：</p>
<pre><code>192.168.1. 00 000000 --&gt; 00 111111 
192.168.1. 01 000000 --&gt; 01 111111
192.168.1. 10 000000 --&gt; 10 111111
192.168.1. 11 000000 --&gt; 11 111111
</code></pre>
</li>
</ul>
</li>
<li>参考链接</li>
</ul>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener">百度百科的解释</a></li>
<li><a href="https://www.zhihu.com/question/56895036" target="_blank" rel="noopener">知乎问答</a></li>
</ul>
<h4 id="广播地址"><a class="header-anchor" href="#广播地址"></a>广播地址</h4>
<ul>
<li>Broadcast Address(广播地址)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255的分组（封包）时，它将被分发给该网段上的所有计算机。</li>
</ul>
<h4 id="ifconfig命令输出详解"><a class="header-anchor" href="#ifconfig命令输出详解"></a>ifconfig命令输出详解</h4>
<ul>
<li><code>eth0</code> --&gt; 网卡</li>
<li><code>HWaddr</code> --&gt; MAC</li>
<li><code>inet addr</code> --&gt; internal address, IP</li>
<li><code>Bcast</code> --&gt; 广播地址</li>
<li><code>Mask</code> --&gt; 子网掩码</li>
<li><code>Link encap</code> --&gt; 网络类型为以太网，这里也可能出现其他类型。比如 <code>Local Loopback</code></li>
</ul>
<pre><code>[root@linuxchao ~]# ifconfig
eth0 Link encap:Ethernet HWaddr 00:03:0D:27:86:41
inet addr:192.168.1.86 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::203:dff:fe27:8641/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:618 errors:0 dropped:0 overruns:0 frame:0
TX packets:676 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:491238 (479.7 KiB) TX bytes:86286 (84.2 KiB)
Interrupt:5 Base address:0x8c00
</code></pre>
<ul>
<li>参加链接： 写得非常清楚的博客并不多。
<ul>
<li><a href="http://c.biancheng.net/view/797.html" target="_blank" rel="noopener">Linux ifconfig命令：配置网络接口</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/09/DNS协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/09/DNS协议/" itemprop="url">DNS协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T15:35:36+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/protocal/" itemprop="url" rel="index">
                    <span itemprop="name">protocal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2>
<p>工作中要用到DNS协议，需要学习一下，省得碰到的时候每次都要再看一遍。 DNS也是TCP/IP里面的一个基础协议。所以也会涉及到一些TCP/IP协议的部分。<br>
话说一个简单的DNS协议也有一堆可以写啊。不容易啊。</p>
<h3 id="dns在tcp-ip协议里的位置"><a class="header-anchor" href="#dns在tcp-ip协议里的位置"></a>DNS在TCP/IP协议里的位置</h3>
<ul>
<li>从参考链接名就能看出来， DNS是应用层的协议</li>
<li>TCP/IP是四层。OSI是7层。</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1195962/e9uc1yy5n7.png?imageView2/2/w/1620" alt></p>
<blockquote>
<p>图片来自参考链接1</p>
</blockquote>
<ul>
<li>参考链接：
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1023700" target="_blank" rel="noopener">TCP/IP（六）应用层（DNS和HTTP协议）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1358564" target="_blank" rel="noopener">DNS协议入门</a></li>
<li><a href="https://cloud.tencent.com/developer/information/dns%E7%9A%84%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">DNS协议栈</a></li>
</ul>
</li>
</ul>
<h3 id="概述"><a class="header-anchor" href="#概述"></a>概述</h3>
<ul>
<li><code>Domain Name System</code> 域名系统。也可以叫做域名解析协议。</li>
<li>简单的解释就是DNS协议会把网址，比如将”<a href="http://sallyslove.github.io/hexo_blog%E2%80%9D%E7%9A%84%E5%9F%9F%E5%90%8D%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%83%BD%E5%A4%9F%E7%90%86%E8%A7%A3%E7%9A%8432%E4%BD%8D%E7%9A%84IP%EF%BC%8C%E5%8F%91%E5%88%B0%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%BB%E3%80%82">sallyslove.github.io/hexo_blog”的域名转换成为计算机能够理解的32位的IP，发到网络层去。</a></li>
<li>域名和IP的对应关系保存在一个叫hosts文件中。最初，通过互联网信息中心来管理这个文件，如果有一个新的计算机想接入网络，或者某个计算IP变更都需要到信息中心申请变更hosts文件。其他计算机也需要定期更新，才能上网。但是这样太麻烦了，就出现了DNS系统。</li>
<li>其实我们现在的电脑上面也是有这个文件的，就是<code>/window/systems/drivers/etc</code>下面也有hosts文件。注释里面很清楚写着，这个文件“used by Microsoft TCP/IP for Windows.”</li>
<li>目前的DNS系统中，如果有 hosts文件，仍旧会优先查询这个文件的</li>
</ul>
<h3 id="流程"><a class="header-anchor" href="#流程"></a>流程</h3>
<ul>
<li>过程相当的简单明了啊。client端发消息给域名解析服务器，服务器在自己里面一顿找，有就直接返回</li>
<li>没有就去根服务器找，根服务器找了之后会存到低一次没找到的域名解析服务器进行缓存。</li>
<li>再去找的时候就从缓存里面直接拿。不需要再去根服务器跑一趟了</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1195962/vspbulgxi2.png?imageView2/2/w/1620" alt></p>
<blockquote>
<p>图片来自参考链接1</p>
</blockquote>
<h3 id="详解"><a class="header-anchor" href="#详解"></a>详解</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825" target="_blank" rel="noopener">DNS（域名解析协议）详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1358564" target="_blank" rel="noopener">DNS 协议入门</a></li>
</ul>
</li>
</ul>
<h4 id="域名"><a class="header-anchor" href="#域名"></a>域名</h4>
<p>好吧，要了解DNS协议，首先要了解域名。各种域名都隶属于域名系统根域的下级。</p>
<ul>
<li>域名是分层次的。第一级域名，比如com，代表公司，这是company的缩写吧。再比如org,嗯，我看出来了，organization的开头。net网络提供商。大家有严格遵守吗?</li>
<li>第二级域名其实是公司名，比如baidu，bing。微软为啥叫bing啊。</li>
<li>对应不同层级的域名，有相应的服务器。根域名服务器之类。每一级域名服务器都知道下级域名服务器的IP地址。这个按照上面的流程也能知道。应该下层也知道上一层的地址，不然没法求助啊。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/DNS_domain_name.png" alt></p>
<blockquote>
<p>图片来自上面的参考链接1</p>
</blockquote>
<h4 id="协议"><a class="header-anchor" href="#协议"></a>协议</h4>
<ul>
<li>DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。</li>
<li>上面提到不同层级的域名会有不同层级的域名服务器来对应，每一层级也有主副服务器，辅助服务器与主服务器会进行同步，这个时候会用TCP协议，大批量数据传输，TCP是相对稳定的链接</li>
<li>而客户端向域名服务器查询时候用的是UDP协议， 效率更高，不需要经过三次握手</li>
</ul>
<h4 id="实现"><a class="header-anchor" href="#实现"></a>实现</h4>
<ul>
<li><code>dnsjava</code>是DNS的一个Java实现。这是一个3pp。还有其他一些实现，比如<code>dns4j</code>，<code>dnsjnio</code>，<code>jdnss</code>,<code>eagledns</code>。</li>
<li>要打开dnsjava的log，需要将设置<code>System.setProperty(&quot;dnsjava.options&quot;,&quot;verbose&quot;);</code> 这种操作也真是比较老了。</li>
<li>maven dependency是以下这样。</li>
</ul>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;dnsjava&lt;/groupId&gt;
   &lt;artifactId&gt;dnsjava&lt;/artifactId&gt;
   &lt;version&gt;2.1.7&lt;/version&gt;
</code></pre>
<ul>
<li><code>dnsjava</code>类图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/dnsjava_class_diagram.png" alt></p>
<ul>
<li>
<p><code>dnsjava</code> 流程图<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/protocal/dnsjava_sequence_diagram.png" alt></p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/zhu_tianwei/article/details/45128537" target="_blank" rel="noopener">DNS BIND之dnsjava java客户端操作</a></li>
</ul>
</li>
</ul>
<h4 id="使用"><a class="header-anchor" href="#使用"></a>使用</h4>
<ul>
<li><code>lookup</code>遇到错误“network error”，这个是因为在以下原因。 其实我碰到的就是BindException，“address already in use”</li>
<li>参考链接：
<ul>
<li><a href="https://coderanch.com/t/585844/java/org-xbill-DNS-Lookup-error" target="_blank" rel="noopener">org.xbill.DNS.Lookup() error.</a></li>
<li><a href="https://github.com/dnsjava/dnsjava/issues/71" target="_blank" rel="noopener">我自己报的issue</a></li>
<li><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.xbill.DNS.ExtendedResolver" target="_blank" rel="noopener">Java Code Examples for org.xbill.DNS.ExtendedResolver</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/06/25/Cassandra的数据维护/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/06/25/Cassandra的数据维护/" itemprop="url">Cassandra的数据维护</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T17:01:57+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index">
                    <span itemprop="name">cassandra</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="compacting-sstable-data"><a class="header-anchor" href="#compacting-sstable-data"></a>Compacting SSTable Data</h3>
<h4 id="why-do-we-need-compaction"><a class="header-anchor" href="#why-do-we-need-compaction"></a>Why Do We Need Compaction</h4>
<ul>
<li>cassandra并不会删除数据。当需要update一个数据的时候，也不是在SSTable里面进行覆盖，而是会插入一个新的数据，带上新的version。</li>
<li>这样做的话，cassandra写入数据会非常快，因为不需要查询，但是弊端就是会有越来越多的数据。</li>
<li>这个时候就需要进行compaction。</li>
</ul>
<h4 id="what-is-compaction"><a class="header-anchor" href="#what-is-compaction"></a>What Is Compaction</h4>
<ul>
<li>To keep the multiple versions of the SSTables from overwhelming it, the database merges SSTables on a regular basis to get rid of the older versions of the data。 cassandra会在一个基础之上对旧的版本的数据进行合并，这个就是compaction</li>
<li>cassandra默认会进行很多次小的compaction</li>
</ul>
<h4 id="campaction细节"><a class="header-anchor" href="#campaction细节"></a>Campaction细节</h4>
<ul>
<li>在compaction期间，cassandra会合并key和column，同时会将过期的墓碑删除，还会生成一个新的index？ <strong><em>这个index是什么东西啊</em></strong></li>
<li>合并之后会生成一个新的SSTable。<strong><em>回头要试一下</em></strong></li>
<li>compaction期间的资源耗用会上升，但是compaction结束之后应该会释放空间，因为它合并了SSTable</li>
<li>旧的被合并的table会被加上deletion标签，并且在数据库重启或者在使用reference counting mechanism的时候。<strong><em>这个reference counting mechanism是什么啊</em></strong></li>
<li>compaction的算法是可以配置的，默认的是<code>size-tiered compaction</code>。这个算法会合并大小相近的table，生成大table</li>
</ul>
<h4 id="compaction对读数据的影响"><a class="header-anchor" href="#compaction对读数据的影响"></a>Compaction对读数据的影响</h4>
<ul>
<li>compaction是per-node的，所以某个数据在node1上面的旧版本可能删除了。但是在node2上面还有。</li>
<li>这样读的时候会进行一个合并，并且返回最后一个写的version。这个原则是<code>last-write-win</code></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/06/17/软件衡量标准/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/06/17/软件衡量标准/" itemprop="url">软件衡量标准</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T17:20:49+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工作中接触到一些软件衡量标准的需求，必须对这些概念有所了解和理解。所以解释如下了。</p>
<h3 id="scalability"><a class="header-anchor" href="#scalability"></a>Scalability</h3>
<ul>
<li>
<blockquote>
<p>Scalability is the property of a system to handle a growing amount of work by adding resources to the system 维基百科里面的这个解释实在很到位啊。通过加资源来获得更大的能力</p>
</blockquote>
</li>
<li>以下内容基本是维基百科的翻译：
<ul>
<li>用户可扩展性： 能够同时支持多少用户</li>
<li>功能可扩展性： 能不能扩展功能，而不会影响现有功能</li>
<li>地理上的可扩展性： 就是直接的字面含义，类似部署时候的机器是不是必须local在一起。</li>
<li>负载可扩展性： 这就是我们通常意义上面知道的，加node或者加cpu，加内存，能不能够加可处理的能力</li>
<li>代扩展性： 这个有点难以理解，我理解成能不能支持不同版本。比如说，我同时安装java8和java7，那么我可以在maven里面指定生成的代码之类的</li>
<li>种类的可扩展性： 这个可以理解的，就是是不是支持multi-verdor。就像java，可以在windows上面，也可以在linux上面</li>
</ul>
</li>
<li>Scaling horizontally： 就是增减node</li>
<li>Scaling vertically： 增减resource，增减cpu或者内存</li>
<li>总的来说，还是挺复杂的。</li>
<li>参考链接：
<ul>
<li><a href="https://en.wikipedia.org/wiki/Scalability" target="_blank" rel="noopener">维基百科</a></li>
</ul>
</li>
</ul>
<h3 id="testability"><a class="header-anchor" href="#testability"></a>Testability</h3>
<p>testability跟我想象的稍有不同，就是说这个模块或者软件的可测试性。实在有点复杂啊</p>
<ul>
<li>总的来说，感觉实在是太抽象了。 <strong><em>没看懂</em></strong>
<ul>
<li>Class I: there exists a finite complete test suite.</li>
<li>Class II: any partial distinguishing rate (i.e. any incomplete capability to distinguish correct systems from incorrect systems) can be reached with a finite test suite.</li>
<li>Class III: there exists a countable complete test suite.</li>
<li>Class IV: there exists a complete test suite.</li>
<li>Class V: all cases.</li>
</ul>
</li>
<li>参考链接：<br>
+<a href="https://en.wikipedia.org/wiki/Software_testability" target="_blank" rel="noopener">维基百科</a></li>
</ul>
<h3 id="robustness-computer-science"><a class="header-anchor" href="#robustness-computer-science"></a>Robustness (computer science)</h3>
<ul>
<li>robustness is the ability of a computer system to cope with errors during execution and cope with erroneous input。跟想象的不一样啊，更多focus的是handle error的能力</li>
<li>参考链接：
<ul>
<li>[维基百科](<a href="https://en.wikipedia.org/wiki/Robustness_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robustness_(computer_science)</a></li>
</ul>
</li>
</ul>
<h3 id="computer-security"><a class="header-anchor" href="#computer-security"></a>Computer Security</h3>
<ul>
<li>the protection of computer systems from theft or damage to their hardware, software or electronic data, as well as from disruption or misdirection of the services they provide.</li>
<li>参考链接
<ul>
<li><a href="https://en.wikipedia.org/wiki/Computer_security" target="_blank" rel="noopener">维基百科</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/06/17/Java数据类型-一些特别的数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/06/17/Java数据类型-一些特别的数据类型/" itemprop="url">Java数据类型 --- 一些特别的数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T13:14:34+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="java-util-function-supplier"><a class="header-anchor" href="#java-util-function-supplier"></a>java.Util.Function.Supplier</h3>
<ul>
<li>这个接口只有一个方法，Get方法。void，返回一个T</li>
<li>把它当工厂方法看就是了。</li>
<li>顾名思义，提供者。</li>
<li><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">JAVA8 Supplier接口</a></li>
<li>感觉就是一次性生成。同一个接口，在初始化时候给出get函数，可以有不同实现</li>
<li>supplier作为function interface，有@FunctionalInterface annotation。所以可以直接用lamda来作为实现。比如：<code>()-&gt;getString()</code>可以作为<code>Supplier&lt;String&gt;</code>的实现</li>
</ul>
<h3 id="java关键字native"><a class="header-anchor" href="#java关键字native"></a>java关键字native</h3>
<p>我要看native的函数。找不到，OMG。其实之前看到过native的用法，知道这个玩意，但是还是写在这里吧。<br>
感觉一片参考链接就能解释清楚啦。</p>
<ul>
<li>其实就是java吧，不像c和c++善于处理底层的东西。所以就会调用一些不是java写的函数。这些函数就用native关键字来修饰</li>
<li>native是通过JNI（Java Native Interface）接口来调用这些函数的</li>
<li>参考链接
<ul>
<li><a href="https://www.cnblogs.com/b3051/p/7484501.html" target="_blank" rel="noopener">java中native的用法</a></li>
</ul>
</li>
</ul>
<h3 id="生成random的方法"><a class="header-anchor" href="#生成random的方法"></a>生成Random的方法</h3>
<p>有好几个相关的类型，写在这里。是在工作中需要生成随机<code>port</code>碰到的</p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.jianshu.com/p/2f6acd169202#" target="_blank" rel="noopener">Java 随机数 Random VS SecureRandom</a></li>
<li><a href="https://www.bbsmax.com/A/kjdwxba6zN/" target="_blank" rel="noopener">Java中的随机数生成器：Random，ThreadLocalRandom，SecureRandom</a></li>
<li><a href="http://ju.outofmemory.cn/entry/286621" target="_blank" rel="noopener">Java中生成随机数Random、ThreadLocalRandom、SecureRandom</a></li>
<li><a href="https://blog.csdn.net/weixin_33738555/article/details/93434637" target="_blank" rel="noopener">SecureRandom的正确使用</a></li>
<li><a href="https://blog.csdn.net/weixin_35703883/article/details/81138425" target="_blank" rel="noopener">SecureRandom生成随机数</a></li>
<li><a href="https://www.cnblogs.com/deng-cc/p/8064481.html" target="_blank" rel="noopener">SecureRandom</a></li>
</ul>
</li>
</ul>
<h4 id="math-random"><a class="header-anchor" href="#math-random"></a>Math.random</h4>
<ul>
<li>产生的随机数是0 - 1 之间的一个 double，即0 &lt;= random &lt; 1。</li>
<li>第一次调用<code>Math.random()</code>方法时，自动创建了一个伪随机数生成器，实际上用的是 <code>new java.util.Random()</code>。</li>
<li><code>Math.random()</code>方法是线程安全的。</li>
</ul>
<h4 id="java-util-random"><a class="header-anchor" href="#java-util-random"></a>java.util.Random</h4>
<ul>
<li><code>Random</code>类中实现的随机算法是伪随机，也就是有规则的随机</li>
<li>种子一样的情况下，两个<code>Random</code>类产生的是一模一样的数列</li>
<li>所以在安全性要求比较高，或者使用比较频繁时，不适合使用<code>Random</code>，因为值是可预测的</li>
<li>然后生成的随机数是左边闭环，右边开的。</li>
</ul>
<h4 id="java-security-securerandom"><a class="header-anchor" href="#java-security-securerandom"></a>java.security.SecureRandom</h4>
<ul>
<li><code>SecureRandom</code> 其实和<code>Random</code>一样，种子一样的时候生成的数列是固定的</li>
<li>也是继承至 java.util.Random。</li>
<li>不一样的是，<code>SecureRandom</code>收集了一些随机事件，比如鼠标点击，键盘点击等等， 使用这些随机事件作为种子</li>
<li>通过new来初始化，在不适用任何源的情况下，就是说无参数构造函数的话，默认来说会使用<code>NativePRNG</code>算法生成随机数</li>
<li>不要使用人为指定的源，尽量使用系统的随机源。系统的随机源在java8中是可以配置的，配置在<code>$JAVA_HOME/jre/lib/security/java.security</code>中的<code>securerandom.source</code>属性。例如jdk1.8中该配置为:<code>securerandom.source=file:/dev/random</code></li>
<li>实际上SHA1PRNG的性能将近要比NativePRNG的性能好一倍，synchronized的代码少了一半，所以没有特别重的安全需要，尽量使用SHA1PRNG算法生成随机数。</li>
</ul>
<h4 id="java-util-concurrent-threadlocalrandom"><a class="header-anchor" href="#java-util-concurrent-threadlocalrandom"></a>java.util.concurrent.ThreadLocalRandom</h4>
<ul>
<li>java7之后引进的</li>
<li>继承自java.util.Random</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/05/15/Cassandra的repair机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/05/15/Cassandra的repair机制/" itemprop="url">Cassandra的repair机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T17:52:05+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index">
                    <span itemprop="name">cassandra</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cassandra的repair机制"><a class="header-anchor" href="#cassandra的repair机制"></a>Cassandra的repair机制</h2>
<p>这篇讨论一些robustness的东西。主要就是一个节点down了会怎么样。其实目前知道的就是hint，但是记录下来。<br>
从一些文档里面看，这个属于写流程的一部分。确实是，读的话，如果node down了应该不会从上面读取了。会写到the coordinator node上面。version 1.0有所不同，但是这个版本太旧了。</p>
<blockquote>
<p>By design, hinted handoff inherently allows Cassandra to continue performing the same number of writes even when the cluster is operating at reduced capacity.</p>
</blockquote>
<h3 id="hinted-handoff简述"><a class="header-anchor" href="#hinted-handoff简述"></a>Hinted Handoff简述</h3>
<ul>
<li><strong><code>hinted handoff</code> 和 一般说的<code>hint</code>应该是同一个东西。</strong> 前者是一个机制，后者就是这个机制产生的事件或者记录。</li>
<li><code>hinted handoff</code>跟consistency level 相关，毕竟这个是写机制的一部分。</li>
<li>cassandra的config文件里面需要配置几个参数：
<ul>
<li><code>hinted_handoff_enabled</code>：默认为true，打开这个机制</li>
<li><code>max_hint_window_in_ms</code>： 为已经down掉的node记录hint log的时间长度</li>
<li><code>gc_grace_seconds</code>: Configures the time-to-live (TTL) period for a hint so that the database won’t replay the hint after this duration. Setting this parameter to 0 disables hints。 这个参数没用过，后面可以试试看</li>
<li><code>hinted_handoff_throttle_in_kb</code> 和    <code>max_hints_delivery_threads</code> 这两个没咋研究过，先放着吧</li>
</ul>
</li>
<li>按照文档，当写入发生时候，并且a replica node for the key is down。就可能会触发hinted handoff的机制</li>
</ul>
<h4 id="hint-详述"><a class="header-anchor" href="#hint-详述"></a>Hint 详述</h4>
<ul>
<li>
<blockquote>
<p>The hint consists of a target ID for the downed node, a hint ID that is a time UUID for the data, a message ID that identifies the Cassandra version, and the data itself as a blob.</p>
</blockquote>
<ul>
<li>hint里面有：down node的target ID， 标注这条数据的hint ID， 标注cassandra version的message ID以及数据本身</li>
<li>这是cassandra 3.0之后的。之前的可能不一样</li>
</ul>
</li>
<li>
<p>和想象地一样，当Gossipy发现downed node起来之后，coordinator node会将hint记录的数据写过去，并且删除掉hint</p>
</li>
<li>
<blockquote>
<p>The coordinator also checks every ten minutes for hints corresponding to writes that timed out during an outage too brief for the failure detector to notice through gossip.</p>
</blockquote>
</li>
<li>
<p>这句有点难以理解，看了下一句有点明白。如果有的节点宕机时间很短，而Gossdip并没有发现，那么coordinator 会返回一个exception，同时把write fail了，但是会记录一个hint。所以如果瞬间有很多短暂的fail，coordinator node会一下子压力过大，扔出overloadexception</p>
</li>
</ul>
<blockquote>
<p>If a replica node is overloaded or unavailable, and the failure detector has not yet marked the node as down, then expect most or all writes to that node to fail after the timeout triggered by write_request_timeout_in_ms, (10 seconds by default). The coordinator returns a TimeOutException exception, and the write will fail but a hint will be stored.</p>
</blockquote>
<h4 id="hint-和-consistency-level"><a class="header-anchor" href="#hint-和-consistency-level"></a>Hint 和 consistency level</h4>
<ul>
<li>
<blockquote>
<p>当一致性等级设定为ONE，QUORUM，或者ALL的时候，提示的写并不参与到一致性级别的计数中。如果没有足够的节点满足写的一致性级别需要，会抛出 UnavailableException而不是触发Hinted Handoff。（这是Casssandra和Dynamo复制模型不一样的地方之一）</p>
</blockquote>
</li>
<li>接上文，如果将consistency level设置成为Any，那么hint就算了。所以即使只是写了hint，写操作也会成功，但是这时候读数据是读不出来的。</li>
</ul>
<h3 id="repairing-data"><a class="header-anchor" href="#repairing-data"></a>Repairing Data</h3>
<ul>
<li>Read repair: The reconciliation or correction happens when a read finds an inconsistency.</li>
<li>When data is read, a read repair can resolve any data inconsistencies. When data isn’t read, you need to use either the hinted handoff or anti-entropy mechanism to resolve any data inconsistences.</li>
</ul>
<h4 id="read-repair"><a class="header-anchor" href="#read-repair"></a>Read Repair</h4>
<h4 id="anti-entropy"><a class="header-anchor" href="#anti-entropy"></a>anti-entropy</h4>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://wiki.apache.org/cassandra/HintedHandoff" target="_blank" rel="noopener">wiki上面的简介</a></li>
<li><a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/operations/opsRepairNodesHintedHandoff.html" target="_blank" rel="noopener">官方</a></li>
<li><a href="http://www.cnblogs.com/sing1ee/archive/2012/07/09/2765056.html" target="_blank" rel="noopener">比较好的博客一篇</a>： 看起来很多就是官方文档的翻译</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/04/29/k8s和docker问题解决/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/04/29/k8s和docker问题解决/" itemprop="url">k8s和docker问题解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T15:44:03+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2>
<p>工作中碰到的一些相关问题，有的也许很简单，记录在这里。省得后面再花功夫去看啦。</p>
<h4 id="问题一"><a class="header-anchor" href="#问题一"></a>问题一</h4>
<p>$ kubectl cluster-info<br>
Kubernetes master is running at …</p>
<p>To further debug and diagnose cluster problems, use ‘kubectl cluster-info dump’.<br>
Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of “crypto/rsa: verification error” while trying to verify candidate authority certificate “kubernetes”)</p>
<ul>
<li>参考链接：<a href="https://blog.csdn.net/baobaoxiannv/article/details/83818426" target="_blank" rel="noopener">csdn博客一篇</a></li>
<li>其实就是kube的config文件: <code>~/.kube/config</code> 文件过时了。里面的certification需要更新。从kube server上面把config拿下来替换一些本地的就好了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/04/18/Cassandra里面的Batch操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/04/18/Cassandra里面的Batch操作/" itemprop="url">Cassandra里面的Batch操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T10:17:44+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index">
                    <span itemprop="name">cassandra</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cassandra里面的batch操作"><a class="header-anchor" href="#cassandra里面的batch操作"></a>Cassandra里面的Batch操作</h2>
<p>最近工作比较忙活，一个月都没写blog喽。工作中碰到了一些与cassandra相关的同步异步，simpleStatement，batchStatement的东西。顺势多研究一下。<br>
研究发现，这玩意还挺复杂的啊。</p>
<h3 id="execute-与-executeasync"><a class="header-anchor" href="#execute-与-executeasync"></a>execute 与 executeAsync</h3>
<ul>
<li>
<p>cassandra driver在执行语句时候提供了<code>execute</code>和<code>executeAsync</code> 两个接口</p>
</li>
<li>
<p>对于batch来说，只能调用前者，这个好像不太对。</p>
</li>
<li>
<p>但是进入代码会看到，<code>execute</code>最后调用的也是<code>executeAsync</code></p>
<pre><code>  public ResultSet execute(Statement statement) {
         this.checkNotInEventLoop();
         return this.executeAsync(statement).getUninterruptibly();
  }
</code></pre>
</li>
<li>
<p>这个<code>executeAsync</code>api是在<code>SessionManager</code>里面定义的</p>
</li>
<li>
<p>按照参考链接1里面所述的，从以上代码也可以看出来的<code>execute</code>在于是block的。就是不可打断的。必须得cassandra返回一些数据才能返回。所以它可以保证在invalid request的情况下报错，但是不能保证request就一定执行成功了。</p>
</li>
<li>
<p><code>executeAsync</code>就是非blocking的，也不能保证这个request一定被执行或者在invalid的request的情况下报错</p>
</li>
<li>
<p>参考链接1里面有这么一段话：看起来少量batch，并且是同样partition key的时候，会比较快。</p>
</li>
<li>
<p>我们在产品中的改进在有些场景下面确实performance变好了</p>
</li>
</ul>
<blockquote>
<p>To further improve throughput, you might want to consider using BatchStatement and submitting requests in batches. This is a good option if you keep your batches small (50-250 is a good number) and if your inserts in a batch all share the same partition key.</p>
</blockquote>
<ul>
<li>参考链接：
<ol>
<li><a href="https://stackoverflow.com/questions/34949292/how-cassandra-handle-blocking-execute-statement-in-datastax-java-driver" target="_blank" rel="noopener">How Cassandra handle blocking execute statement in datastax java driver<br>
</a></li>
</ol>
</li>
</ul>
<ol start="2">
<li><a href="http://zqhxuyuan.github.io/2015/11/10/2015-11-10-Cassandra-Client/" target="_blank" rel="noopener">Cassandra Client查询优化</a>: 这篇有点看不明白。但是瞅着还挺好的，先放在这里。</li>
</ol>
<h3 id="batchstatement"><a class="header-anchor" href="#batchstatement"></a>BatchStatement</h3>
<p>严格说来，cassanda里面的batch称为LOGGED batch，而不应该是atomic batch。 Cassanda的策略始终是Eventually Consistent。而且由于cassandra里面add一个数据比delete一个数据要方便太多。所以cassandra会记一堆log啥的，而不是回滚。</p>
<ul>
<li>cassandra是基于co-ordinator来实现的。batch在co-ordinator开始处理之前就留会写到其他node去</li>
<li>如果batch里面的某些失败了，那么是不会回滚的。而是会不断尝试。</li>
<li>LOGGER的batch操作会比unlogged的多做很多事情</li>
</ul>
<h4 id="batchstatement-type"><a class="header-anchor" href="#batchstatement-type"></a>BatchStatement.Type</h4>
<p>这个是BatchStatement class的一个子类</p>
<ul>
<li><code>COUNTER</code>: A counter batch. Note that such batch is the only type that can contain counter operations and it can only contain these. 这个解释也太简单了。意思是说可以知道多少个成功了？</li>
<li><code>LOGGED</code>:
<ul>
<li>Cassandra will first write the batch to its distributed batch log to ensure the atomicity of the batch (atomicity meaning that if any statement in the batch succeeds, all will eventually succeed).这个解释也不太懂啊，到底怎么保证的。 ORZ</li>
<li>默认调用<code>new BatchStatement()</code>就会创一个LOGGED type的Batch-</li>
</ul>
</li>
<li><code>UNLOGGED</code>： A batch that doesn’t use Cassandra’s distributed batch log. Such batch are not guaranteed to be atomic.</li>
</ul>
<h4 id="logged-batch的过程"><a class="header-anchor" href="#logged-batch的过程"></a>LOGGED Batch的过程</h4>
<p><img src="http://3.bp.blogspot.com/-dv9zIC84QD4/VNoNE0YXn8I/AAAAAAAAAX0/b3wtV48fuB0/s1600/Screenshot%2B2015-02-10%2B13.51.56.png" alt></p>
<blockquote>
<p>图片来自参考链接2</p>
</blockquote>
<ul>
<li>所以从图片里面看出来，cassandra收到一个batch的request的时候：
<ul>
<li>由co-ordinator来处理，也就是种子节点</li>
<li>会先写batch log，通常写两个node？</li>
<li>然后再从种子节点写到各个分节点</li>
</ul>
</li>
<li>按照参考链接2里面的描述，performance hit，performance会下降的。因为多做了很多事情，而且是从种子节点分发出去的。</li>
<li>结论就是：只有在为了保证一致性的情况下，才使用batch，而不是说改善performance</li>
</ul>
<h4 id="logged-batch-fail"><a class="header-anchor" href="#logged-batch-fail"></a>LOGGED Batch Fail</h4>
<ul>
<li>首先不会回滚</li>
<li>WriteTimeoutException with write type of BATCH_LOG. 说明在写batch log时候挂了。需要手动再发一下。</li>
<li>WriteTimeoutException with the write type of BATCH。 在真正写request的时候出错了。cassandra会不断重复，直至成功。</li>
</ul>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ol>
<li><a href="https://stackoverflow.com/questions/22664129/atomic-batches-in-cassandra" target="_blank" rel="noopener">Atomic Batches in Cassandra</a></li>
<li><a href="http://christopher-batey.blogspot.com/2015/03/cassandra-anti-pattern-cassandra-logged.html" target="_blank" rel="noopener">Cassandra anti-pattern: Logged batches</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/03/11/Java多线程数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/03/11/Java多线程数据类型/" itemprop="url">Java多线程数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T10:22:53+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇记录改成专门记录和多线程相关的数据类型</p>
<h3 id="executors"><a class="header-anchor" href="#executors"></a>Executors</h3>
<p>这个<code>Executors</code>没有继承或者实现任何其他类。就是说，他嘎嘣自己一个。实际上是一个工具类啊，更确切地说，像一个工厂类。主要功能是返回各种<code>ExecutorService</code>。<br>
其实就是<code>new</code>出各种<code>ThreadPoolExecutor</code>。如下：</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                      new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<h3 id="executorservice"><a class="header-anchor" href="#executorservice"></a>ExecutorService</h3>
<h4 id="概览"><a class="header-anchor" href="#概览"></a>概览</h4>
<pre><code>public interface ExecutorService extends Executor
</code></pre>
<ul>
<li>所以首先来说，这是一个接口</li>
<li>Executor接口很简单，只有一个execute方法。ExecutorService除了这一个方法，还增加了一些方法，增加的方法包括：<code>awaitTerminate</code>，<code>invokeAll</code>，<code>invokeAny</code>，<code>shutdown</code>，<code>shutdownNow</code>，<code>submit</code>等。</li>
<li><a href="https://www.cnblogs.com/Steven0805/p/6393443.html" target="_blank" rel="noopener">Java线程池ExecutorService</a></li>
</ul>
<h4 id="几种常用线程池的具体实现"><a class="header-anchor" href="#几种常用线程池的具体实现"></a>几种常用线程池的具体实现</h4>
<ul>
<li>然后有意思的来了：</li>
<li>Java通过Executors class提供了好几种线程池，这就是我们常用的几种了。</li>
<li><code>newFixedThreadPool</code>：就是说这个玩意，限定好了最大数目，核心数目，然后本质是一个<code>LinkedBlockingQueue</code>套了<code>runnable</code></li>
</ul>
<pre><code> public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
</code></pre>
<ul>
<li><code>newCachedThreadPool</code>：</li>
</ul>
<pre><code>   public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());    }
</code></pre>
<ul>
<li>还有<code>newScheduledThreadPool</code>和<code>newSingleThreadExecutor</code></li>
</ul>
<h4 id="一些要点"><a class="header-anchor" href="#一些要点"></a>一些要点</h4>
<ul>
<li><code>submit</code>与<code>execute</code>的区别：
<ul>
<li>submit接受runnable和callable  有返回值。</li>
<li>execute接受runnable 无返回值</li>
<li>submit方便Exception处理</li>
</ul>
</li>
<li>Runnable与Callable区别
<ul>
<li>runnable接口实现的没有返回值的并发编程。</li>
<li>callable实现的存在返回值的并发编程。使用Future获取返回值。</li>
</ul>
</li>
</ul>
<h3 id="threadpoolexecutor"><a class="header-anchor" href="#threadpoolexecutor"></a>ThreadPoolExecutor</h3>
<pre><code>public abstract class AbstractExecutorService implements ExecutorService
public class ThreadPoolExecutor extends AbstractExecutorService    
</code></pre>
<ul>
<li>从上面可以看出来，ThreadPoolExecutor也是一种Executor，继承自AbstractExecutorService，自然也实现了ExecutorService.</li>
<li><a href="https://www.cnblogs.com/zedosu/p/6665306.html" target="_blank" rel="noopener">ThreadPoolExecutor使用详解</a></li>
</ul>
<h4 id="threadpoolexecutor-shutdown"><a class="header-anchor" href="#threadpoolexecutor-shutdown"></a>ThreadPoolExecutor shutdown</h4>
<p>ThreadPoolExecutor 有三个shutdown方法： <code>shutdown</code>、<code>shutdownNow</code>、<code>awaitTermination</code></p>
<ul>
<li>
<p><code>shutdown</code>： 停止接收外部submit的任务；内部正在跑的任务和队列里等待的任务，会执行完。其实graceful shutdown的感觉啊</p>
</li>
<li>
<p><code>shutdownNow</code>： 停止接收外部提交的任务；忽略队列里等待的任务；尝试将正在跑的任务interrupt中断；返回未执行的任务列表。强制中断。线程会收到InterupptedException.</p>
<ul>
<li>需要注意的是这个方法仅仅是尝试中断线程，它通过的是调用interrupt方法，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。</li>
</ul>
</li>
<li>
<p><code>awaitTermination</code>：只是加了一个wait时间的限制</p>
<ul>
<li>很多博客的里面，这个函数会返回boolean的返回值。就是说<code>awaitTermination</code>一般和<code>shutdown</code>搭配使用，<code>awaitTermination</code>来监控线程有没有结束好。结束了返回<code>true</code>，没结束返回<code>false</code></li>
<li>这个函数还会抛出InterupptedException，但是看代码没太明白什么状况下会抛这个<code>exception</code>。但是是这个函数本身被interrupt了。</li>
<li>有一点不太明白，线程处于阻塞状态，处于阻塞状态时候，还会接收消息？只是不处理？</li>
<li>在实际工作中解决bug碰到了这组函数。事实上就是要三个一起用的。<code>awaitTermination</code>只会返回一个状态，并不会做任何的事情。所以在这个函数返回false的时候应该要调用<code>shutdownNow</code>方法来进一步中断线程</li>
</ul>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://blog.csdn.net/u012168222/article/details/52790400" target="_blank" rel="noopener">shutdown 方法</a></li>
<li><a href="https://blog.csdn.net/zaozi/article/details/38854561#commentBox" target="_blank" rel="noopener">ExecutorService的正确关闭方法</a>： 这篇文章比喻得很清楚，只是不知道正确与否</li>
</ul>
</li>
<li>
<ul>
<li><a href="https://blog.csdn.net/liwenxia626/article/details/80754886" target="_blank" rel="noopener">csdn的另一篇博客</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/03/04/TLS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/03/04/TLS/" itemprop="url">SSL/TLS相关知识-算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T14:50:11+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://xz.aliyun.com/t/2526" target="_blank" rel="noopener">SSL/TLS协议详解(上)：密码套件，哈希，加密，密钥交换算法</a>
<ul>
<li>英文版: <a href="https://www.wst.space/ssl-part1-ciphersuite-hashing-encryption/" target="_blank" rel="noopener">SSL/TLS for dummies part 1 : Ciphersuite, Hashing,Encryption</a></li>
</ul>
</li>
<li><a href="https://xz.aliyun.com/t/2530" target="_blank" rel="noopener">SSL/TLS协议详解(中)——证书颁发机构</a></li>
<li><a href="https://xz.aliyun.com/t/2531" target="_blank" rel="noopener">SSL/TLS协议详解(下)——TLS握手协议</a></li>
<li>以上是一个系列，真的是详解，非常详尽。</li>
</ul>
<h2 id="算法"><a class="header-anchor" href="#算法"></a>算法</h2>
<ul>
<li>这边主要是参考了上面参考链接里面的第一篇，总的来说，应该了解一下这些</li>
</ul>
<h3 id="哈希算法"><a class="header-anchor" href="#哈希算法"></a>哈希算法</h3>
<ul>
<li>哈希算法生成的数据格式被称为散列，散列不是一个可逆的过程。<br>
而之前说过，<code>Base64</code>只是编码，顾名思义，编码只要知道规则，是可以解码的，没有安全性可言。所以编码算法和加密算法不是一回事来着。</li>
<li>所以讲密码哈希一下，是没法看出来原始密码是什么的。</li>
<li>这边可以扩展，进一步研究的是，如果进行攻击的话，称为字典攻击，就是猜密码，将常用的，可能出现的密码都哈希算法一下，去对比。</li>
<li>哈希算法有很多种，比如<code>MD5</code>是一种，虽然之前说就是提取摘要的。<code>SHA-512</code>是另一种。</li>
</ul>
<h3 id="加密算法"><a class="header-anchor" href="#加密算法"></a>加密算法</h3>
<ul>
<li><em>Encryption lies in between hashing and encoding</em> 这句没看明白</li>
<li>加密算法可以分为对称加密和非对称加密两种</li>
</ul>
<h4 id="对称加密"><a class="header-anchor" href="#对称加密"></a>对称加密</h4>
<ul>
<li>主要来自参考链接一， 对称加密的话，文章中用一个例子来讲解：“移位”。比如有数字&quot;123&quot;，对其进行加密，都增大3，成为“456”，就是对称加密了。</li>
<li>其中的数字3就是<code>Encryption key (symmetric key)</code>。对称加密的时候，知道<code>key</code>的话，就可以进行解密了。</li>
<li><em>Anyone who knows the encryption key and can apply the reverse of Caesar’s algorithm and retrieve the original Plaintext.</em> 凯撒算法就是上面这种意味式的加密算法。</li>
<li>有此可知，在<code>TLS</code>中使用简单的对称加密不是很安全的。毕竟知道<code>Encryption key</code>就可以进行解密了。<br>
对称加密一代代发展，现在也有比较复杂的算法，比如<code>Triple Data Encryption Algorithm</code>，后面可以再进一步研究。AES（高级加密标准）和3DES（三重数据加密算法）的复杂算法也是有的</li>
<li>从过程可以知道，<code>key</code>是非常关键的。但是由于是对称加密解密，双方必须都知道约定的值，那么第一步就是传递<code>key</code>，而这个时候是没法加密的。所以就出现了不对称加密。<em>So we need a secure mechanism to exchange the keys without an attacker actually seeing it. There comes the role of Asymmetric Key Encryption.</em></li>
<li>在<code>TLS</code>中，传输和接收数据的时候，可以使用对称加密算法。事实上，很可能大部分都是使用的对称加密。不对称加密涉及双密钥架构并且密钥长度通常很大，因此加密-解密开销非常高。与对称密钥加密相比，它需要更多的时间和<code>CPU</code>占有率。</li>
</ul>
<h4 id="不对称加密"><a class="header-anchor" href="#不对称加密"></a>不对称加密</h4>
<ul>
<li>1976年，Whitfield Diffie和Martin Hellman首次提出了非对称加密的概念，该算法被称为<code>Diffie-Hellman</code>密钥交换。然后在1978年，麻省理工学院的Ron Rivest，Adi Shamir和Leonard Adleman发表了<code>RSA</code>算法。</li>
<li>不对称加密的简单解释就是：用不同的<code>key</code>来进行加密和解密。</li>
<li>非对称加密也称为公钥基础结构，又称<code>PKI public key ixxx</code></li>
<li>不对称加密通常用于在刚开始传输对称加密的<code>key</code>的时候</li>
<li>公钥用来给对方使用，比如A想给B发消息，那么A需要使用B的公钥来加密自己的消息。<br>
所以公钥是可以与任何想与你通信的人共享的，一般来说，在公钥中会指定使用何种加密算法。 <em>如果密钥对是使用RSA算法生成的，那么它们应该在加密数据时使用相同的算法。</em></li>
<li>私钥用来解密收到的消息。比如A收到了一条消息，那么A应当使用自己的私钥来解密收到的消息</li>
<li>非对称加密算法除了<code>RSA</code>、<code>Diffie-Hellman密钥交换</code>、<code>ECDH（Elliptic Curve Diffie-Hellman）</code>、<code>SRP（安全远程密码）</code>以及由TLS 1.2支持密钥交换算法<code>PSK（Pre Shared Key）</code>。总之，也是有一大堆的</li>
</ul>
<h5 id="rsa算法细节"><a class="header-anchor" href="#rsa算法细节"></a>RSA算法细节</h5>
<ul>
<li>所以<code>RSA</code>算法有几个比较重要的组成，私钥，公钥，加密算法和解密算法</li>
<li>那么一个严肃的问题就是，不同的钥匙进行计算的消息，怎么能够解开呢？接下来就是数学课的时间了。
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/dbs1215/article/details/48953589" target="_blank" rel="noopener">带你彻底理解RSA算法原理</a></li>
<li><a href="https://www.zhihu.com/question/25038691" target="_blank" rel="noopener">RSA 算法的加密原理是什么,知乎问答</a></li>
</ul>
</li>
<li>互质数： 只有一个公因子为1的数。比如6和9，都有公因子为3，那么就不是互质数；而7和9只有公因子为1，就是互质数。</li>
<li>欧拉函数：<code>φ(n)</code>。 小于或等于n的正整数中与n互质的数的数目。</li>
<li>三个横线的奇怪等号是恒等于。</li>
<li>生成公钥：随机选取两个质数<code>p1、p2</code>，<code>n=p1*p2</code>，再随机选取一个整数<code>e</code>，<code>e</code>与<code>φ(n)</code>互质。公钥就是<code>(e, n)</code>。</li>
<li>根据欧拉函数定理，<code>φ(n) = (p1-1)*(p2-1)</code></li>
<li>费马定理：若p是素数，a与p互素，则<code>a^(p-1）≡1 （mod p）</code> 没看懂这个费马定理</li>
<li>加密算法：假设<code>m</code>为需要加密的信息，那么<code>(m^e) mod n</code>就加密好了，生成加密后的信息<code>c</code></li>
<li>解密算法： 解密算法其实和加密算法的公式是一模一样的，只是这里的<code>m</code>和<code>e</code>换成<code>c</code>和<code>d</code>，成为<code>(c^d) mod n</code>。相当于采用公式都是<code>(x^y) mod n</code>，所以其实使用的公式是一样的</li>
<li>那么这里的<code>(d, n)</code>就被成为私钥。那么如何得到<code>d</code>呢？烧脑的数学就来了。果然数学系才有前途啊 😂 实在是颇为烧脑啊。</li>
<li>各个参考链接中均有实际的例子，我这里就不再烧脑来看了</li>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/qq_38313548/article/details/85387466" target="_blank" rel="noopener">如何获得d</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>(c^d) mod n = ((m^e)mod n)^d mod n = (m^ed) mod n = m
(m^φ(n)) mod n≡1 又 1^k≡1, 所以(m^k*φ(n)) mod n≡1 ，所以(m^(k*φ(n)+1)) mod n≡m
结合以上两条，ed=k*φ(n)+1 , d=(k*φ(n)+1)/e
</code></pre>
<h5 id="dh和rsa的区别"><a class="header-anchor" href="#dh和rsa的区别"></a>DH和RSA的区别</h5>
<ul>
<li>有一本书，叫做“图解密码技术”，</li>
<li><code>RSA</code>利用最大公约数（互质）来求出公钥和私钥。<code>DH密钥协商</code>则是利用生成元来得到共享密钥。</li>
<li>在第一篇参考链接中有<code>DH</code>算法的详细数学过程，暂时略过，这些需要数学基础啊。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo_blog/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/hexo_blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/hexo_blog/page/3/">3</a><a class="page-number" href="/hexo_blog/page/4/">4</a><a class="extend next" rel="next" href="/hexo_blog/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lynn Shen</p>
              <p class="site-description motion-element" itemprop="description">35岁开始的博客，有点晚哦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/hexo_blog/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/hexo_blog/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/hexo_blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/hexo_blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/hexo_blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
        <script src="https://billts.site/js/gitment.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
