<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo_blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo_blog/css/main.css">


<link rel="stylesheet" href="/hexo_blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sallyslove.github.io","root":"/hexo_blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/page/4/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lynn Shen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sallyslove.github.io/hexo_blog/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>跬步</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo_blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">跬步</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不积跬步，无以至千里</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo_blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo_blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/" class="post-title-link" itemprop="url">Jetty Graceful shutdown</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-22 15:21:42" itemprop="dateCreated datePublished" datetime="2019-02-22T15:21:42+08:00">2019-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-16 10:09:54" itemprop="dateModified" datetime="2019-08-16T10:09:54+08:00">2019-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/" class="post-meta-item leancloud_visitors" data-flag-title="Jetty Graceful shutdown" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/22/Jetty-Graceful-shutdown/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="jetty"><a class="header-anchor" href="#jetty"></a>Jetty</h2>
<p>工作中需要了解Jetty启停的一些知识，可能不能看到全貌，这边记录下来。毕竟不是web的产品。了解得还不够深入啊。</p>
<h3 id="what-is-graceful-shutdown"><a class="header-anchor" href="#what-is-graceful-shutdown"></a>what is graceful shutdown</h3>
<ul>
<li>Graceful shutdown of a server, context or connector is when existing request/connections are allowed to gracefully complete while no new requests and/or connections are accepted.</li>
<li>It is configured on the Server instance with the setGracefulShutdown(long) method. Heres an example of setting this via the jetty.xml file, where we specify a “grace” period of 30000 milliseconds:<br>
<Set name="gracefulShutdown">30000</Set></li>
<li>The parameter may be already not used any more</li>
</ul>
<h3 id="how-it-works"><a class="header-anchor" href="#how-it-works"></a>How it works</h3>
<ul>
<li>As soon as the shutdown command is given, the container will close the connectors so that they do not accept any more inbound connections.</li>
<li>所以在<code>ServerControllerImpl</code>里面，如果HTTP的配置参数是false，Connector确实是一上来就停掉了。但是怎么都到<code>JettyServer的</code>getContext（）`函数里面的</li>
<li><code>ServerControllerImpl</code> 应该是HTTP server的controller</li>
</ul>
<pre><code> if (!ServerControllerImpl.this.configuration.isHttpEnabled()) {
                connectorsx = ServerControllerImpl.this.jettyServer.getConnectors();
                if (connectorsx != null) {
                     ...
                      this.stopConnector(backupConnector);
                            ServerControllerImpl.this.jettyServer.removeConnector(backupConnector);
  ...
</code></pre>
<ul>
<li>This will inform most load balancers that the server is no longer part of the cluster.</li>
<li>The contexts are closed so that they do not accept any more requests, but the requests currently inside the container will drain out and the Server instance will shutdown after the grace period expires.<br>
not very sure here. It seems that connector and context are different. I think the connector is more related with port. But context is more related with servlet.</li>
</ul>
<h3 id="elements"><a class="header-anchor" href="#elements"></a>Elements</h3>
<p>我理解在整个jetty server shutdown的时候有几个东西： connector、context、server。以下是理解，不一定准确：</p>
<ul>
<li>servlet 是在context里面的，context一旦stop掉，servlet也会跟着destroy。context是WebAppHttpContext，servlet是其中的一个web Element。</li>
<li>有三个context，一个是HttpServiceContext， 一个是WebAppHttpContext，还有servlet的context。WebAppHttpContext是jetty stop context时候停掉的，每个web app对应一个。前者是jetty server停掉的时候停掉的。感觉server停掉的时候，webAppHttpContext不一定都结束了。但是jetty server停掉的时候，HttpServiceContext是停止了。servlet的context结构是servlet里面的一个internal class，跟每个uri绑定。</li>
<li>connector是在jetty里面定义的,有几种connector，比如<code>org.eclipse.jetty.server.ssl.SslSelectChannelConnector</code>，<code>org.eclipse.jetty.server.nio.SelectChannelConnector</code>。</li>
</ul>
<p>在Connector的interface里面有个maxIdleTimeout的参数，标示这个connection在idle时候会等多久从ESTABLISH状态变成TIME_WAIT状态。但是并没有在代码里面找到调用的地方。</p>
<p>___ 这个是在停的时候调用的那个吗？果然写blog要再清楚一点才好___</p>
<ul>
<li>Connector是在jetty的配置文件里面配置的</li>
</ul>
<h3 id="jetty启动过程"><a class="header-anchor" href="#jetty启动过程"></a>Jetty启动过程</h3>
<p>大部分web容器的启动过程都差不多，分为如下几步：</p>
<ul>
<li>创建用于连接的connector，创建线程池</li>
<li>扫描当前的web程序的部署目录，为他们创建上下文环境，并对他们进行path的路由设置，这个的名字是WebAppHttpContext</li>
<li>初始化创建的web程序上下文，这里就包括创建servlet啥的。，初始化linstener啥的。并做好自己的path路由。.</li>
<li>启动connector，开始监听，整个server开始运行</li>
<li>没看出来HttpServiceContext是什么</li>
<li>参考文档：
<ul>
<li><a href="https://blog.csdn.net/kobejayandy/article/details/20291953" target="_blank" rel="noopener">Jetty的Server创建与启动</a></li>
</ul>
</li>
</ul>
<h3 id="filter-servlet-listener顺序"><a class="header-anchor" href="#filter-servlet-listener顺序"></a>Filter、Servlet、Listener顺序</h3>
<h4 id="启动顺序"><a class="header-anchor" href="#启动顺序"></a>启动顺序</h4>
<ul>
<li>filter的初始化是web server启动的时候初始化的</li>
<li>servlet的初始化是收到对应的第一条request时候进行的</li>
<li>执行时候是先执行filter，再执行servlet</li>
<li>从启动日志来看，启动的顺序为listener-&gt;Filter-&gt;servlet.</li>
</ul>
<h4 id="停止顺序"><a class="header-anchor" href="#停止顺序"></a>停止顺序</h4>
<ul>
<li>容器关闭或者context重新部署，这时候servlet先destroy掉</li>
<li>servlet之后才是filter关闭</li>
</ul>
<h4 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h4>
<ul>
<li><a href="https://www.jianshu.com/p/612c3a6673b2" target="_blank" rel="noopener">Listener、Filter、Servlet执行顺序</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/15/%E5%B8%B8%E7%94%A8k8s%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/15/%E5%B8%B8%E7%94%A8k8s%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">常用k8s命令记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-15 14:15:01" itemprop="dateCreated datePublished" datetime="2019-02-15T14:15:01+08:00">2019-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-05 11:27:22" itemprop="dateModified" datetime="2020-11-05T11:27:22+08:00">2020-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/15/%E5%B8%B8%E7%94%A8k8s%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" class="post-meta-item leancloud_visitors" data-flag-title="常用k8s命令记录" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/15/%E5%B8%B8%E7%94%A8k8s%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/15/%E5%B8%B8%E7%94%A8k8s%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常用k8s命令"><a class="header-anchor" href="#常用k8s命令"></a>常用k8s命令</h2>
<p>这篇记录一下常用的<code>k8s</code>命令，我怕我会忘啊  -_-#<br>
没错，这是<code>docker</code>那篇的姐妹篇哦。棒棒哒</p>
<h3 id="集群命令"><a class="header-anchor" href="#集群命令"></a>集群命令</h3>
<ul>
<li><code>kubectl cluster-info</code></li>
</ul>
<h3 id="查询命令"><a class="header-anchor" href="#查询命令"></a>查询命令</h3>
<ul>
<li>
<p><code>kubectl get nodes</code>：用下面这条命令可以打出<code>node</code>的具体信息</p>
<pre><code>kubectl get nodes -o wide
</code></pre>
</li>
<li>
<p><code>kubectl get pods</code>： <code>get pods</code>的话，会把<code>replication cotronller</code>， <code>service</code>， <code>deployment</code>都给打印出来</p>
</li>
<li>
<p><code>kubectl get rc</code>: <code>replication controller</code>打印出来。</p>
</li>
</ul>
<pre><code>$ kubectl get pods
NAME     READY     STATUS    RESTARTS   AGE
http-7b77c4cd66-74zqx          1/1       Running   0          4s
http-7b77c4cd66-fhlmx          1/1       Running   0          19m
http-7b77c4cd66-xrbpf          1/1       Running   0          4s
httpexposed-5c4cf8b7d8-qprzc   1/1       Running   0          11m

$ kubectl get deployments
NAME DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
http          3         3         3            3           19m
httpexposed   1         1         1            1           11m
</code></pre>
<ul>
<li><code>kubectl describe deployment http</code></li>
<li><code>kubectl describe svc http</code> 能看到很多信息，包括整个cluster对外的ip，各个node的内部ip之类</li>
<li><code>kubectl get ing</code> 可以用来看Ingress</li>
<li><code>kubectl config set-context $(kubectl config current-context) --namespace=&lt;insert-namespace-name-here&gt;</code></li>
<li><code>kubectl config get-contexts</code></li>
<li><code>kubectl get namespaces</code></li>
</ul>
<h3 id="创建类命令"><a class="header-anchor" href="#创建类命令"></a>创建类命令</h3>
<ul>
<li>
<p><code>kubectl run first-deployment --image=katacoda/docker-http-server --port=80</code></p>
<ul>
<li><code>-port</code>仍旧是内部的端口</li>
<li>外部端口可以用<code>--hostport=8001</code>指定， 但是这样做的话， —<em>Under the covers, this exposes the Pod via Docker Port Mapping.</em> As a result, you will not see the service listed using <code>kubectl get svc</code>。目前的理解是，因为是用的<code>docker</code>的方法，所以<code>k8s</code>不知道
<ul>
<li>用<code>docker ps</code>命令能看到这个<code>container</code>，然后可以注意到有两个<code>ps</code>进程。其中一个是<code>paused</code>状态，然后我们的端口<code>8001</code>其实开在这个<code>paused</code>的<code>ps</code>上面。</li>
<li><em>The ports are exposed on the Pod, not the http container itself. The Pause container is responsible for defining the network for the Pod. Other containers in the pod share the same network namespace. This improves network performance and allow multiple containers to communicate over the same network interface.</em> 感觉这段解释很关键啊。这个container的名字是： k8s_POD_“httpexposed”,最后一个字段是我们起的pod的名字</li>
</ul>
</li>
<li><code>--replicas</code>： 复制因子</li>
</ul>
</li>
<li>
<p><code>kubectl scale --replicas=3 deployment http</code> scale的命令</p>
</li>
<li>
<p><code>kubectl create -f deployment.yaml</code> 通过yaml文件创建一个deployment</p>
</li>
<li>
<p><code>kubectl create -f service.yaml</code> 也可以通过<code>yaml</code>文件创建<code>service</code></p>
<ul>
<li><code>ymal</code>文件里面的内容还不是非常清楚。参考<a href="https://blog.csdn.net/luanpeng825485697/article/details/83753260" target="_blank" rel="noopener">k8s yaml文件详解</a></li>
</ul>
</li>
<li>
<p><code>kubectl apply -f deployment.yaml</code>如果<code>yaml</code>文件有改动的话，可以用这条命令来update</p>
</li>
</ul>
<pre><code> $ kubectl apply -f deployment.yaml
  Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
  deployment.extensions/webapp1 configured
</code></pre>
<ul>
<li>
<p><code>kubectl exec $pod -- /usr/bin/curl -s localhost/unhealthy</code></p>
</li>
<li>
<p><code>kubectl create namespace</code>创建namespace</p>
</li>
<li>
<p><code>kubectl delete pvc --all --namespace default</code> 用这个命令来做<code>delete</code>。一堆都行。<code>pvc</code>换成<code>pod</code>，<code>deployments</code>，<code>secret</code>，<code>configmap</code>，<code>service</code>啥的</p>
</li>
</ul>
<h3 id="工作中常用实用命令"><a class="header-anchor" href="#工作中常用实用命令"></a>工作中常用实用命令</h3>
<h4 id="端口映射"><a class="header-anchor" href="#端口映射"></a>端口映射</h4>
<ul>
<li><code>kubectl port-forward</code>
<ul>
<li>
<p>Forward one or more local ports to a pod. This command requires the node to have ‘socat’ installed. <strong><em>socat是什么?</em></strong></p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://imti.co/kubernetes-port-forwarding/" target="_blank" rel="noopener">Kubernetes Port Forwarding for Local Development</a></li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward" target="_blank" rel="noopener">官方文档</a></li>
</ul>
</li>
<li>
<p>用例：</p>
<ul>
<li>以下命令的含义是：将本地端口<code>8080</code>和<code>8081</code>，映射到<code>k8s</code>服务<code>ok</code>的<code>8080</code>和<code>80</code>端口上面。<code>-n</code>代表的<code>namespace</code></li>
<li>默认地址是<code>localhost</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  kubectl port-forward service/ok 8080:8080 8081:80 -n the-project
</code></pre>
<h4 id="临时编辑资源"><a class="header-anchor" href="#临时编辑资源"></a>临时编辑资源</h4>
<ul>
<li><code>kubectl edit</code> 命令可以用来修改一个资源。<code>kubectl edit deployment &lt;resource_name&gt; -n &lt;namespace&gt;</code>,需要注意的是修改是暂时的，如果使用<code>helm upgrade</code>命令，那么修改会被覆盖掉
<ul>
<li>参考链接： <a href="https://stackoverflow.com/questions/45502729/how-do-i-edit-a-resource-configuration-with-kubectl" target="_blank" rel="noopener">kubectl edit</a></li>
</ul>
</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li><a href="http://docs.kubernetes.org.cn/475.html" target="_blank" rel="noopener">k8s中文文档</a></li>
<li><a href="https://www.katacoda.com/courses/kubernetes/kubectl-run-containers" target="_blank" rel="noopener">codekara的在线课程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/14/%E5%B8%B8%E7%94%A8Docker%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/14/%E5%B8%B8%E7%94%A8Docker%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-14 15:16:01" itemprop="dateCreated datePublished" datetime="2019-02-14T15:16:01+08:00">2019-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-18 09:54:12" itemprop="dateModified" datetime="2021-06-18T09:54:12+08:00">2021-06-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/14/%E5%B8%B8%E7%94%A8Docker%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" class="post-meta-item leancloud_visitors" data-flag-title="Docker" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/14/%E5%B8%B8%E7%94%A8Docker%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/14/%E5%B8%B8%E7%94%A8Docker%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Docker</code>相关的信息都记录在这里</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://www.jianshu.com/p/f0a0f6a43907" target="_blank" rel="noopener">Dockerfile RUN，CMD，ENTRYPOINT命令区别</a></li>
</ul>
<h2 id="常用docker命令"><a class="header-anchor" href="#常用docker命令"></a>常用docker命令</h2>
<p>这篇记录一下 <code>Docker</code> 相关的知识，我怕我会忘啊 😅</p>
<ul>
<li><code>docker run -d / -it / -v / -p /--name/-l</code>
<ul>
<li><code>-d</code>: background; <code>-v</code>: 磁盘映射 ；<code>-p</code>：端口映射; <code>-l</code>: label</li>
</ul>
</li>
<li><code>docker build -t （build-directory） dockerfile</code> build docker image
<ul>
<li><code>-t</code> 指定编译出来的image的名字。可以带上版本。比如：firstImage:v1</li>
<li><code>-f</code> 指定dockerfile的名字</li>
</ul>
</li>
<li><code>docker inspect</code>看一个image的信息或者container的信息
<ul>
<li>docker inspect -f “” katacoda-label-example</li>
<li>These labels will remain even if the image has been untagged. When an image is untagged, it will have the name <none></li>
</ul>
</li>
<li><code>docker exec</code></li>
</ul>
<h2 id="docker的概念"><a class="header-anchor" href="#docker的概念"></a>Docker的概念</h2>
<ul>
<li><code>Label</code>就是中文含义一样的标签，<code>key-value</code>的形式，比如user=lynn，这样子。除了user，还会有version啊
<ul>
<li>LABEL vendor=Katacoda \ com.katacoda.version=0.0.5 \ com.katacoda.build-date=2016-07-01T10:47:29Z \ com.katacoda.course=Docker</li>
<li>container, image, demon都可以有label，在查看时候都可以用上</li>
</ul>
</li>
<li>参考链接：<a href="https://www.katacoda.com/courses/docker/2" target="_blank" rel="noopener">karacoda docker在线课程</a></li>
</ul>
<h2 id="dockerfile"><a class="header-anchor" href="#dockerfile"></a>Dockerfile</h2>
<blockquote>
<p><a href="https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html" target="_blank" rel="noopener">Debugging Docker builds</a></p>
</blockquote>
<ul>
<li>这几天正好在做<code>docker image</code>，几点经验写在下面：
<ul>
<li>打包： 使用原始的<code>docker build</code>命令自然是可以的，产品中就不是这样了。<code>JAVA</code>使用的自然是<code>maven</code>的<code>docker plugin</code>，这个很多年前就用过。而这回<code>SCALA</code>里面，感觉是自然带的，直接<code>sbt</code>里面<code>package</code>就可以打出，也许这个理解有差池。</li>
<li>调试，制作<code>docker image</code>的过程我是大致明白的，其实每一步都会有一个临时的<code>image</code>，然后会在此基础上面起一个容器，在这个容器里面去执行。所以出错了，需要找到这一步的临时镜像和容器。</li>
<li>参考以下链接，主要是用<code>docker commit 20f3e5cebec5 tempimagename</code> 将临时的镜像存储下来</li>
</ul>
</li>
</ul>
<h3 id="cmd-run"><a class="header-anchor" href="#cmd-run"></a>CMD &amp; RUN</h3>
<ul>
<li><code>CMD</code> 和 <code>RUN</code>都可以执行命令，两者的区别如下：
<ul>
<li><code>RUN</code>会生成新的镜像层，所以通常用来安装软件</li>
<li><code>CMD</code>则是在镜像部署完之后执行的命令</li>
</ul>
</li>
<li>如果在启动命令的时候带上命令的话，那么<code>CMD</code>的命令会被覆盖掉
<ul>
<li><code>docker run -it [image] /bin/bash</code>比如，执行了这句，那么即使有既定的<code>CMD</code>，也会不执行了。</li>
<li>所以可以利用这一点，为镜像设置默认启动命令，然后在实际启动时候替换。比如，<code>CMD echo &quot;hello world&quot;</code>, 可以在实际中启动改为<code>hello new world</code></li>
</ul>
</li>
</ul>
<h3 id="entrypoint"><a class="header-anchor" href="#entrypoint"></a>ENTRYPOINT</h3>
<ul>
<li><code>ENTRYPOINT</code>是执行的起点，比如<code>bash</code>, <code>mysql</code>这些。
<ul>
<li>一个例子可以为<code>ENTRYPOINT [&quot;/bin/echo&quot;]</code>，<code>CMD &quot;world&quot;</code>。那么启动的时候会执行<code>echo world</code></li>
</ul>
</li>
</ul>
<h2 id="maven-docker-plugin"><a class="header-anchor" href="#maven-docker-plugin"></a>Maven Docker Plugin</h2>
<ul>
<li><code>maven</code>有好几个支持<code>Docker</code>的<code>plugin</code></li>
<li><code>io.fabric8:docker-maven-plugin</code> 就是其中的一个</li>
</ul>
<h2 id="一些开源工具"><a class="header-anchor" href="#一些开源工具"></a>一些开源工具</h2>
<h3 id="tini-a-tiny-but-valid-init-for-containers"><a class="header-anchor" href="#tini-a-tiny-but-valid-init-for-containers"></a>Tini（A tiny but valid init for containers）</h3>
<blockquote>
<p><a href="https://github.com/krallin/tini/" target="_blank" rel="noopener">Tini_github</a><br>
<a href="https://zhuanlan.zhihu.com/p/59796137" target="_blank" rel="noopener">在entrypoint.sh中使用Tini的优势是什么？</a><br>
<a href="https://link.zhihu.com/?target=https%3A//github.com/krallin/tini/issues/8%23issuecomment-146135930">上文的原文</a></p>
</blockquote>
<ul>
<li>这是对所有容器有效的初始化小工具</li>
<li>从<code>Docker1.13</code>之后，<code>Docker</code>里面已经包含<code>Tini</code>了。只需要<code>docker run</code>就可以了</li>
<li>在第二篇链接中有阐述我为什么要使用<code>Tini</code>，来自作者的解释。尽量摘要翻译如下：
<ul>
<li><code>Docker</code>为容器做了资源独立分割，这是各个层面的，包括网络，内存等等。一个容器里面的进程是一个独立的进程空间。那么第一个初始化的进程叫<code>PID1</code>，也就是初始化的进程。</li>
<li><code>ENTRYPOINT</code>其实就是<code>PID1</code>，如果没有设置<code>ENTRYPOINT</code>，那么就是<code>CMD</code>就会决定<code>PID1</code>是什么</li>
<li>和其他的进程不一样，<code>PID1</code>需要照顾那些僵尸进程，对僵尸进程进行回收。这就是<code>Tini</code>会做的。也是<code>JVM</code>不会在意的。(自然不在意喽，<code>JVM</code>自己只是个进程，不是<code>init</code>进程来着。)</li>
<li>
<blockquote>
<p>One problem is, if you run Bash as PID 1, then all signals you send to your Docker container (e.g. using docker stop or docker kill) end up sent to Bash, which does not forward them anywhere (unless you code it yourself). In other words, if you use Bash to run Jenkins, and then run docker stop, then Jenkins will never see the stop command!</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>这段有点没看明白，如果将<code>bash</code>作为<code>init</code>进程，它当然也有杀死僵尸进程的职责。但是它不会将<code>docker kill</code>这种命令发到该发的地方。<code>Tini</code>补上了这个不足，会将这个命令或者说指令发到正在运行的<code>java</code>程序里面。但是<code>docker kill</code>这种难道不应该由<code>docker demon</code>来负责吗。或者说<code>docker demon</code>会将容器杀掉，但是里面运行的应用并不知道这个事情，就变成<code>kill -9</code>那种了</strong></p>
<ul>
<li>还有一个好处是，假使你的程序崩溃，通常都是在<code>shell</code>里面拉起来的。那么一旦<code>java</code>程序崩了，那么<code>bash</code>会跟着退出来。并且<code>bash</code>极有可能是以<code>code 0</code>退出来的。而实际上内里的应用是崩溃式退出。当然这可以通过让<code>bash</code>来处理信号来解决，但是这会是更多的活计，而加上<code>Tini</code>是几行代码。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/02/14/Scala/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/02/14/Scala/" class="post-title-link" itemprop="url">Scala Concept</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-14 10:18:49" itemprop="dateCreated datePublished" datetime="2019-02-14T10:18:49+08:00">2019-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 10:19:47" itemprop="dateModified" datetime="2021-02-24T10:19:47+08:00">2021-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/02/14/Scala/" class="post-meta-item leancloud_visitors" data-flag-title="Scala Concept" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/02/14/Scala/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/02/14/Scala/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="scala概念快速解释"><a class="header-anchor" href="#scala概念快速解释"></a>Scala概念快速解释</h2>
<ul>
<li><code>Scala</code>有很多特有的概念。如果要看懂代码就得大致明白含义，这篇博客就是快速解释一下，其中可能会有不够准确的地方，就是不求甚解，只求迅速读懂<code>scala</code>代码了.</li>
<li>隔了一段时间又开始看<code>scala</code>的代码，结果发现这篇博客写得太不声情并茂了。<code>scala</code>还是比较复杂的。这么简单写几句不太成，得给一点例子才行。</li>
</ul>
<h3 id="enum"><a class="header-anchor" href="#enum"></a>Enum</h3>
<ul>
<li>简单来说，并没有枚举这个类型，但是可以继承<code>Enumeration</code>来达到枚举的效果</li>
<li>通常定义一个<code>object</code>来继承<code>Enumeration</code></li>
<li>使用<code>Enum</code>，类型都是<code>Enum.Value</code></li>
<li><a href="http://kubicode.me/2015/06/06/Scala/Enum-in-Scala/" target="_blank" rel="noopener">Scala中的Enum，这篇对比了一下java和scala的枚举</a></li>
</ul>
<h3 id="none"><a class="header-anchor" href="#none"></a>&lt;-</h3>
<ul>
<li>
<p><code>for</code> 循环里面用的，看下面这个例子就比较清楚：</p>
<pre><code>for(x &lt;- 1 to 5)  println(i)

for { 
     x&lt;-1 to 5
     y&lt;-2 to 6
   } println (x,y)
</code></pre>
</li>
<li>
<p>参考链接： <a href="https://stackoverflow.com/questions/31799536/what-is-%E2%86%90-in-scala" target="_blank" rel="noopener">what-is-←-in-scala</a></p>
</li>
</ul>
<h3 id="sealed-class"><a class="header-anchor" href="#sealed-class"></a>sealed class</h3>
<h3 id="val和var的区别"><a class="header-anchor" href="#val和var的区别"></a>val和var的区别</h3>
<ul>
<li><code>val</code>就是常量，只能赋值一次</li>
<li><code>var</code>变量，可以赋值多次</li>
<li><a href="https://www.cnblogs.com/IChing/p/7093345.html" target="_blank" rel="noopener">scala基础- val和var的区别</a></li>
</ul>
<h3 id="object"><a class="header-anchor" href="#object"></a>object</h3>
<p>看了几篇博客，解释都不够清晰的感觉，还是<code>stackoverflow</code>上面解释得更清楚.</p>
<ul>
<li>有好几种用法：
<ul>
<li>
<p>作为<code>static</code>函数的<code>class</code>文件，这是最常见到的用法：</p>
<pre><code>object A {
  def twice(i: Int): Int = 2*i
}
</code></pre>
<p>这样可以直接调用<code>A.twice</code>，没有必要先声明一个<code>A</code>的对象。这种是类似<code>java</code>里面的<code>static</code>函数的</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>参考链接：<a href="https://stackoverflow.com/questions/1755345/difference-between-object-and-class-in-scala" target="_blank" rel="noopener">difference-between-object-and-class-in-scala</a></li>
</ul>
<h3 id="trait"><a class="header-anchor" href="#trait"></a>trait</h3>
<ul>
<li><a href="http://www.runoob.com/scala/scala-traits.html" target="_blank" rel="noopener">Scala Trait(特征)</a></li>
<li>类似<code>java</code>的<code>Interface</code>，其实更近似于抽象类</li>
<li>但是可以使用<code>with</code>关键字多重继承，很好用的感觉哦</li>
<li><code>scala</code>本身还是有<code>interface</code>关键字的，本身也可以使用<code>with</code>关键字来实现接口</li>
</ul>
<h3 id="case-class"><a class="header-anchor" href="#case-class"></a>case class</h3>
<ul>
<li><a href="https://blog.csdn.net/bluishglc/article/details/50914001" target="_blank" rel="noopener">csdn上的一篇文章</a></li>
<li>简单来说，<code>case class</code>会默认生成很多东西，比如伴生对象，比如工厂方法，比如<code>toString</code>， <code>copy</code>，构造方法参数同名的属性</li>
<li>最开心的用法，应该就是不用<code>new</code>出一个对象来。而是可以直接<code>methodName(构造函数参数)</code>这样来获取一个对象。其实是同名的工厂方法</li>
<li>还有一个开心的用法就是<code>case class</code>可以直接用在<code>case</code>语句里面进行判断</li>
</ul>
<h3 id="implicit"><a class="header-anchor" href="#implicit"></a>implicit</h3>
<ul>
<li>
<p>隐式转换。例子如下：</p>
<pre><code>    def display(input:String):Unit = println(input)
    implicit def typeConvertor(input:Int):String = input.toString
    display(12)
</code></pre>
</li>
<li>
<p>本来的话，<code>display</code>函数只能接收一个字符串类型的参数，但是在相同作用域里面有隐式函数的存在，自动将整型转换成了字符串下类型</p>
</li>
<li>
<p>需要注意的一点是，在相同作用域里面，相同参数，相同返回值的函数，函数名并不关键。确实不关键，在调用<code>display(12)</code>的时候，我们并没有说，啊，请用隐式函数<code>typeConvertor</code></p>
</li>
<li>
<p>所以，如果有另一个隐式函数，也是将整型转换为字符串，<code>scala</code>会出错。因为回不知道用哪一个</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/rollenholt/p/4118567.html" target="_blank" rel="noopener">详尽解释的博客，博主其他博客也不错</a></li>
</ul>
</li>
</ul>
<h3 id="asscala"><a class="header-anchor" href="#asscala"></a>asScala</h3>
<ul>
<li><code>import scala.collection.JavaConverters._</code></li>
<li>理解就是将<code>Java</code>的一些结构自动转为<code>Scala</code>的结构</li>
<li>以下参考里面将<code>ArrayList</code>转成了<code>mutable.Buffer</code>。</li>
<li>参考链接
<ul>
<li><a href="https://blog.csdn.net/guotong1988/article/details/51454281" target="_blank" rel="noopener">asScala</a></li>
</ul>
</li>
</ul>
<h3 id="actor"><a class="header-anchor" href="#actor"></a>Actor</h3>
<ul>
<li>
<p><code>actor</code>其实不是<code>scala</code>的概念，<code>Linux</code>里面就有的。但是感觉写在<code>scala</code>里面比较合适。</p>
</li>
<li>
<p><a href="https://cloud.tencent.com/developer/article/1135999" target="_blank" rel="noopener">漫谈并发编程：Actor模型</a>这篇里面其实蛮清楚的。基础的一些用法在这边看一下也就明白一些了</p>
</li>
<li>
<p>基于<code>Actor</code>的并发编程中，所有的对象都是一个<code>actor</code>，类似面向对象编程中，所有的都是对象一样。只是<code>Actor</code>再和<code>Scala</code>结合，这个可读性，必须熟悉代码的才行。</p>
</li>
<li>
<p>首先有一个<code>ActorSystem</code>，然后<code>Actor</code>是家族式的，有一个父的<code>Actor</code>，然后其他<code>Actor</code>由父而来。父<code>Actor</code>可以创建子<code>Actor</code>，事实上，是整个<code>life cycle</code>的控制</p>
</li>
<li>
<p>顶层的父<code>Actor</code>用以下语句创建。<code>Props</code>里面的就是<code>Actor</code>的类的名字，后面一个参数是<code>Actor</code>的名字</p>
<pre><code>system.actorOf(Props[BetterMaster], &quot;master&quot;)
</code></pre>
</li>
<li>
<p>子<code>Actor</code>创建的方式是类似的，只是是由父 <code>Actor</code>创建的。父<code>Actor</code>内部，通过调用<code>ActorContext</code>的<code>actorOf()</code>方法来创建它自身的<code>child actor</code>。和父<code>Actor</code>一样，参数是<code>Actor</code>的实现的类的名字和<code>Actor</code>的名字。</p>
</li>
</ul>
<pre><code>	context.actorOf(Props[BetterTalker], &quot;talker&quot;)
</code></pre>
<ul>
<li><code>Actor</code>本身是<code>TRAIT</code>，<code>preStart</code>与<code>postStop</code>是很重要的方法。这样，通过这些函数，可以控制一个<code>Actor</code>的生命周期。在我们的代码里面通过重载父<code>Actor</code>的<code>preStart</code>方法，来控制了整个<code>Actor System</code></li>
</ul>
<h4 id="tell"><a class="header-anchor" href="#tell"></a>tell</h4>
<ul>
<li><code>tell</code>其实是一个函数，也就是<code>!</code>，看到这感叹号简直是 😂 这都个可读性只能OMG了。</li>
<li><a href="https://stackoverflow.com/questions/49649745/what-is-the-second-argument-of-the-actorref-tell-method" target="_blank" rel="noopener">tell<br>
的第二个参数是干嘛的</a></li>
<li><code>tell</code>有两个参数，第一个是消息，第二个是回调的<code>Actor</code>，就是说收到消息的<code>Actor</code>可以给第二个参数(也是个<code>Actor</code>)发送消息，来告诉它自己收到了第一个参数指定的消息。同时收到消息的<code>Actor</code>也会认为消息是第二个参数发来的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/01/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/01/28/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-28 16:21:54" itemprop="dateCreated datePublished" datetime="2019-01-28T16:21:54+08:00">2019-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-10-28 08:39:58" itemprop="dateModified" datetime="2017-10-28T08:39:58+08:00">2017-10-28</time>
              </span>

          
            <span id="/hexo_blog/2019/01/28/hello-world/" class="post-meta-item leancloud_visitors" data-flag-title="Hello World" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/01/28/hello-world/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/01/28/hello-world/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start"><a class="header-anchor" href="#quick-start"></a>Quick Start</h2>
<h3 id="create-a-new-post"><a class="header-anchor" href="#create-a-new-post"></a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server"><a class="header-anchor" href="#run-server"></a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files"><a class="header-anchor" href="#generate-static-files"></a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="header-anchor" href="#deploy-to-remote-sites"></a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/01/21/Cassandra%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/01/21/Cassandra%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Cassandra数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-21 15:35:56" itemprop="dateCreated datePublished" datetime="2019-01-21T15:35:56+08:00">2019-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 16:45:42" itemprop="dateModified" datetime="2021-02-22T16:45:42+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/01/21/Cassandra%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra数据结构" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/01/21/Cassandra%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/01/21/Cassandra%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cassandra-数据结构"><a class="header-anchor" href="#cassandra-数据结构"></a>Cassandra 数据结构</h2>
<p>必须了解<code>Cassandra</code>的数据结构。本身并不是多么复杂，而且有足够多的文档，所以简单写一下。</p>
<h3 id="keyspace"><a class="header-anchor" href="#keyspace"></a>KeySpace</h3>
<ul>
<li>好像没啥需要解释的。</li>
<li>在论文里面看到说<code>namespace</code>的另一个作用是可以做数据重复。</li>
</ul>
<h3 id="column"><a class="header-anchor" href="#column"></a>Column</h3>
<ul>
<li><code>Column</code>是<code>Cassandra</code>中最小的数据单元，它是一个三元的数据类型，包含<code>name,value,timestamp.</code></li>
<li><code>name</code>是必须的，<code>value</code>不是必须的，<code>timestamp</code>经常可以忽略不计，如下图<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Cassandra/cassandra_column.png" alt="引用自第一篇参考链接"></li>
</ul>
<blockquote>
<p>引用自csdn</p>
</blockquote>
<h3 id="super-column"><a class="header-anchor" href="#super-column"></a>Super Column</h3>
<ul>
<li>可以将<code>SuperColumn</code>想象成<code>Column</code>的数组，它包含一个<code>name</code>以及一系列<code>Column</code>.</li>
<li><code>SuperColumn</code>本身不包含<code>timestamp</code>属性。使用<code>SuperColumn</code>有一个限制，要读取其中一个子列的值，必须把所有子列都反序列化，且不能在子列中建索引<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Cassandra/cassandra_super_column.png" alt=""></li>
</ul>
<blockquote>
<p>引用自csdn</p>
</blockquote>
<ul>
<li>
<p>参考链接里面有以下的例子</p>
<pre><code> {   // 这是一个SuperColumn
     name: &quot;info&quot;,
     // 包含一系列的Columns
     value: {
        street: {name: &quot;street&quot;, value: &quot;1234 x street&quot;, timestamp: 123456789},
        city: {name: &quot;city&quot;, value: &quot;san francisco&quot;, timestamp: 123456789},
        zip: {name: &quot;zip&quot;, value: &quot;94107&quot;, timestamp: 123456789},
  }
}
</code></pre>
</li>
</ul>
<h3 id="columnfamily"><a class="header-anchor" href="#columnfamily"></a>ColumnFamily</h3>
<ul>
<li>
<p><code>columnFamily</code>相当于数据库中的表</p>
</li>
<li>
<p>每一行有一个<code>row</code>的名字，然后每一行里面是一个个的<code>column</code>，也可以是<code>super column</code></p>
</li>
<li>
<p><code>ColumnFamily</code>是一个包含了许多<code>Row</code>的结构，每一个<code>Row</code>都包含有<code>client</code>提供的<code>Key</code>以及和该<code>Key</code>关联的一系列<code>Column</code>。</p>
</li>
<li>
<p>每一行里面的<code>column</code>的名字可以是不变的。也可以是可变的。静态和动态<code>column</code></p>
</li>
<li>
<p>需要注意的是，数据写入的时候已经经过排序了。就是说一行的所有<code>column</code>，会根据它的名字来进行排序。</p>
</li>
<li>
<p>第二个参考链接里面的例子：</p>
</li>
</ul>
<pre><code>   UserProfile = { // 这是一个ColumnFamily
        phatduckk: {   // 这是对应ColumnFamily的key
            // 这是Key下对应的Column
            username: &quot;gpcuster&quot;,
            email: &quot;gpcuster@gmail.com&quot;,
            phone: &quot;6666&quot;
        }, // 第一个row结束
        ieure: {   // 这是ColumnFamily的另一个key
          //这是另一个Key对应的column
          username: &quot;pengguo&quot;,
          email: &quot;pengguo@live.com&quot;,
          phone: &quot;888&quot;
        }
</code></pre>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Cassandra/cassandra_column_family.png" alt=""></p>
<blockquote>
<p>引用自第一篇参考链接文档</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Cassandra/cassandra_storage_picture.png" alt=""></p>
<blockquote>
<p>引用自第二篇参考链接文档</p>
</blockquote>
<h3 id="对应到表的定义里面"><a class="header-anchor" href="#对应到表的定义里面"></a>对应到表的定义里面</h3>
<p>目前对于表结构的理解是这样的，可能后面有更正：</p>
<ul>
<li>如果用<code>desc tables</code>去查看一张表。那么可以看到<code>primaryKey</code>字样，类似<code>PRIMARY KEY ()</code>，还有<code>CLUSTERING ORDER</code> 字样</li>
<li><strong><em>那么这个primary key就是对应数据模型里面的row的名字。也就是super column的名字。只不过这个名字是几个primaryKey联合起来组成的。？</em></strong></li>
<li><code>primaryKey</code>可以用来查询数据。<code>primary key</code>分为两个部分<code>partition key</code>和<code>clustering key</code>， 前者组合起来决定一个数据的存储在哪个<code>node</code>上面, 后者会用来排序。而 <code>CLUSTERING ORDER</code>决定排序时候使用的参数的顺序</li>
<li>查询是时候必须给出所有的<code>partition key</code>，之前有过<code>ALLOW FILTERING</code>的字段来容忍缺失<code>partition key</code>，现在没有这个功能了。</li>
</ul>
<p>如下：</p>
<pre><code>PRIMARY KEY ((race_year, race_name), rank)
</code></pre>
<p>这里的<code>race_year</code>和<code>race_name</code>就是组合的<code>partition key</code>,而<code>rank</code>就是<code>a clustering column</code>，用来排序的</p>
<ul>
<li>也可能看到<code>CLUSTERING ORDER BY</code>的字样里面，有<code>ASC</code>，代表升序排序，可以指定为<code>DESC</code>降序排序</li>
<li>在<code>3.0</code>的版本之前，还可能看到<code>COMPACT STORAGE</code>，现在已经没有啦，所以也就不写了。</li>
</ul>
<h3 id="data-moduling"><a class="header-anchor" href="#data-moduling"></a>data moduling</h3>
<ul>
<li>最近看了一些关于建模的文章。文章里面一些反复强调的事如下：
<ul>
<li><code>cassandra</code>不同于其他数据库的是，它写的成本低，读的成本高。</li>
<li>基于这一点，必须在一开始先考虑<code>query</code>的需求，然后数据可以<code>duplicated</code>。而在关系数据库建模时候，完全是不一样的。</li>
<li>基于<code>cassandra</code>的写和存储的方式，需要读取的数据应该放在同一个<code>partition</code>里面。</li>
<li>文章里面的这句话说明了<code>partition</code>的定义和重要性：</li>
</ul>
<blockquote>
<p>a set of rows that share a partition key is called a partition<br>
Cassandra is a partitioned row store with tunable consistency.<br>
You perform several optimizations in the physical data modeling stage, including the specifying of partition sizes and ordering.</p>
</blockquote>
</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li><a href="https://blog.csdn.net/aesop_wubo/article/details/20289837" target="_blank" rel="noopener">数据模型</a></li>
<li><a href="http://www.cnblogs.com/gpcuster/archive/2010/03/12/1684072.html" target="_blank" rel="noopener">大话Cassandra数据模型</a></li>
<li><a href="https://stackoverflow.com/questions/24949676/difference-between-partition-key-composite-key-and-clustering-key-in-cassandra" target="_blank" rel="noopener">primary key partition key and clustering key</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/01/21/Cassandra%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/01/21/Cassandra%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Cassandra读数据过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-21 15:35:32" itemprop="dateCreated datePublished" datetime="2019-01-21T15:35:32+08:00">2019-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-09 17:44:25" itemprop="dateModified" datetime="2021-07-09T17:44:25+08:00">2021-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/01/21/Cassandra%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra读数据过程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/01/21/Cassandra%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/01/21/Cassandra%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cassandra读数据过程"><a class="header-anchor" href="#cassandra读数据过程"></a>Cassandra读数据过程</h2>
<p>数据库读数据过程必须知道。</p>
<h3 id="大致的读流程"><a class="header-anchor" href="#大致的读流程"></a>大致的读流程</h3>
<p><img src="https://docs.datastax.com/en/archived/cassandra/3.0/cassandra/images/dml_caching-reads_12.png" alt="官方读流程图片"></p>
<blockquote>
<p>官方读流程图片</p>
</blockquote>
<ul>
<li>
<p>Check the memtable</p>
</li>
<li>
<p>Check row cache, if enabled</p>
</li>
<li>
<p>Checks Bloom filter</p>
</li>
<li>
<p>Checks partition key cache, if enabled</p>
</li>
<li>
<p>Goes directly to the compression offset map if a partition key is found in the partition key cache, or checks the partition summary if not<br>
If the partition summary is checked, then the partition index is accessed</p>
</li>
<li>
<p>Locates the data on disk using the compression offset map</p>
</li>
<li>
<p>Fetches the data from the SSTable on disk</p>
</li>
<li>
<p>在存贮数据的时候，<code>Cassandra</code>会将同样的数据存储很多份，这个在写的时候已经提及过。</p>
</li>
<li>
<p>在读的时候读几个节点同样是由复制因子和<code>consistency level</code>策略决定的。也就是说写几个，读几个。</p>
</li>
</ul>
<h3 id="caches"><a class="header-anchor" href="#caches"></a>Caches</h3>
<p>这篇也作为<code>KeyCache</code>和<code>RowCache</code>学习的blog.<br>
<code>RowCache</code>缓存的是数据，而<code>KeyCache</code>缓存的是在<code>SSTable</code>文件中的位置。<br>
<code>Cassandra</code>读数据慢，写数据快。</p>
<p>以下几种<code>cache</code>都是针对<code>SSTable</code>来说的</p>
<p>参考链接：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/25079311/difference-between-cassandra-row-caching-and-partition-key-caching" target="_blank" rel="noopener">row cache 和 key cache</a></li>
</ul>
<h4 id="rowcache"><a class="header-anchor" href="#rowcache"></a>rowCache</h4>
<ul>
<li><code>rowCache</code>就是将整个<code>partition</code>放在内存里面来增速</li>
<li>不是默认开的，在2.2之后，会将这些行存进非栈的内存里面，使得系统不需要进行<code>GC</code></li>
<li>当存在内存中的行被更新之后，这一行会被删除，直到再次读取</li>
<li>同样，当一个<code>partition</code>被更新了，这个<code>partition</code>会被从内存里面删除，一般不推荐使用。因为很容易失效</li>
<li>参数：
<ul>
<li><code>rows_per_partition</code>：<em>set the number of rows the database must cache in a partition.This attribute has three values: ALL, NONE, and N.</em></li>
</ul>
</li>
</ul>
<h4 id="bloom-filters"><a class="header-anchor" href="#bloom-filters"></a>bloom filters</h4>
<ul>
<li><code>Bloom Filters</code> 就是在写<code>ssTable</code>时候同时写的<code>filter.db</code>文件。但是实际是读的时候用的一个机制</li>
<li>读的时候会用这个机制来看一个数据key是不是在某个<code>SSTable</code>里面。当filter表示不在，肯定是不在；但是说在，可能不在。就是说可能假绿的。也会给出一个概率值，某个<code>partition</code>在不在这个<code>SSTable</code>里面</li>
<li>假绿的概率是万分之一</li>
<li>可以配置<code>bloom_filter_fp_chance</code>来降低假绿，但是会占更多内存</li>
<li><code>Bloom Filters</code> 也是存储在<code>off-heap</code> memory里面的。并且是每张<code>SSTable</code>都有一个的</li>
<li><em>A Bloom filter can establish that a SSTable does not contain certain partition data.</em></li>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/u010900754/article/details/78307808" target="_blank" rel="noopener">bloom 过滤器</a></li>
<li><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">算法原理</a></li>
<li><a href="https://blog.csdn.net/nangongyanya/article/details/54089568" target="_blank" rel="noopener">Cassandra Bloom 过滤器</a></li>
</ul>
</li>
</ul>
<h4 id="keycache"><a class="header-anchor" href="#keycache"></a>keyCache</h4>
<ul>
<li>key cache：stores a map of partition keys to row index entries。stores a cache of the partition index in off-heap memory</li>
<li><code>keyCache</code>又叫做<code>partition key cache</code>，里面存贮的是每一个<code>partition</code>在<code>SSTable</code>表里面开始的<code>index</code></li>
<li>也在<code>off-heap</code>里面</li>
<li><code>key_cache_size_in_mb</code>：所有表的<code>keyCache</code>一起的大小的配置</li>
</ul>
<p><img src="%5Chexo_blog%5Cimages%5Cpasted-4.png" alt="upload successful"></p>
<h4 id="counter-cache"><a class="header-anchor" href="#counter-cache"></a>counter cache</h4>
<ul>
<li>A counter cache improves performance for the counters that you’ll need to access frequently. 好像没怎么听说过counter的概念。这个cache也是第一次看到有。</li>
</ul>
<h4 id="partition-summary-partition-index"><a class="header-anchor" href="#partition-summary-partition-index"></a>Partition Summary &amp; Partition Index</h4>
<ul>
<li><code>partition index</code>是存储在磁盘上面的文件，里面是_an index of all partition keys mapped to their offset._</li>
<li><code>partition summary</code>是存储在内存中的<code>partition index</code>的采样。也是在<code>off-heap</code>里面的。也就是几乎所有帮助读的机制都存在<code>off-heap</code>的内存里面</li>
<li><code>partition summary</code>的采样存储举例来说，假设因子是20，那么就是第一个和第20个的偏移量被存储了。</li>
<li>如果在读的时候必须读到<code>partition summary</code>，那么整个读的过程会有两次访问磁盘</li>
</ul>
<h3 id="gossip-protocal"><a class="header-anchor" href="#gossip-protocal"></a>Gossip Protocal</h3>
<h3 id="limit"><a class="header-anchor" href="#limit"></a>Limit</h3>
<ul>
<li><code>Cassandra</code>根据<code>primary key</code>来读取数据，这个<code>key</code>就是存在<code>keyCache</code>里面的内容。然后会读取一片数据。<em>这里理解正确吗？<code>keyCache</code>里面的不是<code>partition index</code>里面的内容吗？</em></li>
<li>读取时候可以指定<code>limit</code>值，这样会读取有限的内容，而不是一大片。</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li>非常详尽清晰的一篇文档：<a href="https://www.oschina.net/question/12_11855" target="_blank" rel="noopener">Cassandra数据结构和写入读取</a></li>
<li><a href="https://docs.datastax.com/en/archived/cassandra/3.0/cassandra/dml/dmlAboutReads.html" target="_blank" rel="noopener">官方文档读流程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/01/17/Cassandra-%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/01/17/Cassandra-%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Cassandra 写数据过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-17 16:37:00" itemprop="dateCreated datePublished" datetime="2019-01-17T16:37:00+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-08 10:19:59" itemprop="dateModified" datetime="2021-07-08T10:19:59+08:00">2021-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/01/17/Cassandra-%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra 写数据过程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/01/17/Cassandra-%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/01/17/Cassandra-%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cassandra-写流程"><a class="header-anchor" href="#cassandra-写流程"></a>Cassandra 写流程</h2>
<h3 id="大致流程"><a class="header-anchor" href="#大致流程"></a>大致流程</h3>
<p>到把数据写到磁盘中分为以下几个步骤：</p>
<ol>
<li>先找到应该往哪几个节点写</li>
<li>写<code>log</code>到<code>commit log</code></li>
<li>写数据到<code>memtable</code></li>
<li>从<code>memtable</code>中<code>flush</code>数据</li>
<li>将数据存储在<code>SSTables</code>中的磁盘中</li>
</ol>
<ul>
<li>客户端写一条数据必须指定 <code>Keyspace、ColumnFamily、Key、Column Name 和 Value</code>，还可以指定 <code>Timestamp</code>，以及数据的安全等级。<br>
<strong><em>这个<code>key</code>又是什么<code>key</code>呢，<code>partition Key, primary Key</code>,是后文说根据<code>key</code>算出<code>token</code>，然后再根据<code>token</code>算出<code>partition Index</code>的</em></strong></li>
</ul>
<pre><code>Cassandra Node ---&gt;Commitlog---&gt; Memtable

Commitlog ---&gt; Periodically sync to  disk

Memtable  ---&gt; Periodically flush to SSTable
</code></pre>
<h3 id="replica-factor"><a class="header-anchor" href="#replica-factor"></a>Replica Factor</h3>
<ul>
<li>
<p><code>CassandraServer</code> 接收到要写入的数据时：</p>
<ul>
<li>创建一个 <code>RowMutation</code> 对象，再创建一个 <code>QueryPath</code> 对象，这个对象中保存了 <code>ColumnFamily</code>、<code>Column Name</code> 或者 <code>Super Column Name</code>。</li>
<li>把用户提交的所有数据保存在 <code>RowMutation</code> 对象的 Map&lt;String, ColumnFamily&gt; 结构中。</li>
<li>根据提交的<code>Key</code>计算集群中那个节点应该保存这条数据。这个计算的规则是：将<code>Key</code>转化成<code>Token</code>，然后在整个集群的<code>Token</code>环中根据二分查找算法找到与给定的<code>Token</code>最接近的一个节点。</li>
<li>如果用户指定了数据要保存多个备份，那么将会顺序在<code>Token</code>环中返回与备份数相等的节点。这是一个基本的节点列表，后面<code>Cassandra</code>会判断这些节点是否正常工作，如果不正常寻找替换节点。还有还要检查是否有节点正在启动，这种节点也是要在考虑的范围内，最终会形成一个目标节点列表。最后把数据发送到这些节点。</li>
<li><strong><em>所以在真正开始写入数据之前，cassandra会做这些事情？在commitLog之前？</em></strong> 我想应该是之前</li>
</ul>
</li>
<li>
<p><code>Replica Factor</code>和<code>consistency level</code>不是一个东西，然后有一个算法。比如，<code>replica set</code>是3， <code>consistency level</code>的策略是<code>Querum</code>。这样需要<code>consistent</code>的节点是<code>replica set/2 +1</code> ，所以就是<code>2</code></p>
</li>
</ul>
<h3 id="eventual-consistency"><a class="header-anchor" href="#eventual-consistency"></a>Eventual Consistency</h3>
<p>这在<code>Cassandra</code>里面是非常关键的一个概念。写在这里。因为与写的机制相关最多。</p>
<ul>
<li>
<p><strong><em>Cassandra must make tradeoffs among data consistency, availability, and partition tolerance. Cassandra必须在数据一致性、可用性和分区容忍之间平衡</em></strong></p>
<ul>
<li>
<p>Availability: all clients are able to access the data so they can read and write data. 可用性：所有客户都能够读取和写入数据</p>
</li>
<li>
<p>Consistency的概念：</p>
<ul>
<li>a read always return the latest written data： 读取时候返回最后一次写入的数据</li>
<li>All clients will read the same value for an element of data even when the database is simultaneously updating data： 当数据库同步完成的时候，所有客户端应该得到同样的数据</li>
</ul>
</li>
<li>
<p>Partition tolerance：a database can be split into multiple machines and be able keep functioning even during network segmentation breaks： 一个数据库可以分布在不同的机器上面，并且能够在网络出现故障时候保持正常功能</p>
<p>这里应该和关系型的传统数据库不一样。Cassandra是分布式数据库，所有node的地位是一样的。<strong><em>说好的seed呢，怎么感觉有seed， seed应该是Gossip机制里面提出的。参考博客内文档<code>Cassandra system log分析</code>后面也许会换一份文档放</em></strong></p>
<p>Oracle这种数据库一般是单机版的，没有cluster， 但是有主从备份，所有不一样的</p>
</li>
</ul>
</li>
<li>
<p>严格意义上面的Consistency对于分布式数据库来说很难做到。所以有Eventual consistency requires that all updates must be present on all the copies (replicas) of data in a distributed database, but allows for the fact that the process can take a bit of time.<br>
就是说更新是都要进行的，但是可以有一段时间差</p>
</li>
<li>
<p>tuneable consistency： 可配置的consistency。写和读都可以配。</p>
</li>
</ul>
<h3 id="commit-log"><a class="header-anchor" href="#commit-log"></a>commit log</h3>
<p><a href="https://stackoverflow.com/questions/34592948/what-is-the-purpose-of-cassandras-commit-log" target="_blank" rel="noopener">stackoverflow问答</a><br>
这篇文章里面解释得挺清楚的。这里基本就是翻译以下。这个<code>commit log</code>也就是装机时候配置的那个<code>commitlog_directory</code>的配置项。<br>
<code>commit log</code>大小配置是<code>per-node</code>来配置的，所有的<code>table share</code>这个配置。而<code>Memtable</code>和<code>SSTable</code>是<code>per-table</code>配置的</p>
<ul>
<li>
<p><code>cassandra</code>是先写到内存，再写到<code>disk</code>上面的，但是如果当机了。那么内存的数据就会丢。</p>
</li>
<li>
<p>这个时候就需要<code>commitLog</code>，<code>cassandra</code>会从当机的时间点开始，将<code>commitlog</code>里面的数据再写到<code>memTable</code>里面。这个过程并不快，所以最好在<code>restart</code>之前手动进行一下<code>memTable</code>的<code>flush</code>。</p>
</li>
<li>
<p>A commit log serves just one purpose: to hold committed data until it’s permanently written to disk in the SSTables</p>
</li>
<li>
<p>commitLog需要写的数据少，并且只写到一个地方，所以比写SSTable要快</p>
</li>
<li>
<p>在工作中碰到的一个问题就是commitLog损坏了，然后cassandra就起不来了。有一个配置项可以忽略commitLog报错。</p>
</li>
<li>
<blockquote>
<p>Data in the commit log is purged after its corresponding data in the memtable is flushed to an SSTable on disk.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Commit log replay is the process of reading the commit log to recover lost writes in the event of interrupted operations.</p>
</blockquote>
</li>
<li>
<p>The database flushes memtables to disk when the space configured for the commit log reaches its limit. 这里配置的应该是磁盘空间大小，commit log只会写到磁盘上面。不会写到内存里面。</p>
</li>
<li>
<p>By default, the database doesn’t compress the commit log, but you can make it compress.</p>
</li>
<li>
<p>The database archives the commit log at the following times. You configure commit log archiving in the commitlog_archiving.properties file. _<strong><em>archive和compress不是一个概念的感觉。但是前者是指什么呢</em></strong></p>
<ul>
<li>When the node starts up</li>
<li>When it writes a commit log to disk</li>
<li>At a point in time that you specify</li>
</ul>
</li>
</ul>
<h3 id="memtable"><a class="header-anchor" href="#memtable"></a>MemTable</h3>
<ul>
<li>
<blockquote>
<p>Each memtable is dedicated to storing data for a specific table, and there may be multiple memtables per table.</p>
</blockquote>
</li>
<li>每次写的时候只写其中一张memtable memTable在内存里面看不到哦</li>
<li>memTable有两种，一种是写的这种，另外一种是从SSTable读进来的，这种不会重新写回到磁盘里面</li>
<li><code>nodetool flush</code> or the <code>nodetool drain</code> command 来触法手动的flush。前者是指定table。后一个命令是flush这个node。期间会停止任何connection的接听，所以需要在执行命令之后重启整个node</li>
</ul>
<h3 id="sstable"><a class="header-anchor" href="#sstable"></a>SSTable</h3>
<p>第二篇参考链接非常好，但是图片忒不清楚。</p>
<p><img src="https://www.ibm.com/developerworks/cn/opensource/os-cn-cassandraxu2/image010-large.jpg" alt=""></p>
<blockquote>
<p>引用自第二篇参考链接</p>
</blockquote>
<h4 id="sstable特性"><a class="header-anchor" href="#sstable特性"></a>SSTable特性</h4>
<ul>
<li>不可修改</li>
<li>Cassandra在写SSTable的时候是batch操作，因为每次都是对应的Memtable满的时候才写的，不太会有峰值，这样保证写入的效率</li>
</ul>
<h4 id="sstable数据存储"><a class="header-anchor" href="#sstable数据存储"></a>SSTable数据存储</h4>
<ul>
<li>SSTable是<code>Sorted String Table</code></li>
<li>SSTable分为data、index、filter三个文件写到磁盘上面，其实还有好几个其他文件:<br>
以下是一个目录里面的文件</li>
</ul>
<pre><code> Filter.db
 Statistics.db
 CompressionInfo.db
 Digest.adler32
 TOC.txt(就是文件列表)
 Summary.db
 Data.db
 Index.db
</code></pre>
<ul>
<li>Primary index: A list of partition keys and the start position of rows in the data file written on disk(记得读的时候蛮有用的)</li>
<li>Partition summary： 这个summary文件跟上面的Index Summary应该就是一个文件。解释也是一样。A sample of the partition index stored in memory</li>
<li>Bloom filter：
<ul>
<li>
<blockquote>
<p>A structure stored in memory that checks if row data exists in the memtable before accessing SSTables on disk<br>
按照这个解释，有点不明白，这么说应该是memory里面才有的。<br>
- 找到解释了：Filter 文件存的内容就是 BloomFilter 对象的序列化结果。<strong><em>但是这样的话，将其序列化后保存到disk上面有什么用呢？ Bloom filters for an SSTable enhance read performance。后面读的时候看看怎么来enhance的</em></strong></p>
</blockquote>
</li>
</ul>
</li>
<li>Statistics： Contains the statistical metadata about the SSTable’s data</li>
</ul>
<ul>
<li>
<p>存贮的目录就是yaml文件里面配置的<code>data_file_directories</code>确定</p>
</li>
<li>
<p>For example, /data/data/ks1/cf1-5be396077b811e3a3ab9dc4b9ac088d/la-1-big-Data.db represents a data file. ks1 represents the keyspace name to distinguish the keyspace for streaming or bulk loading data. A hexadecimal string, 5be396077b811e3a3ab9dc4b9ac088d in this example, is appended to table names to represent unique table IDs.<br>
同样会有：la-1-big-Index.db</p>
</li>
<li>
<p><strong><em>la是啥？</em></strong></p>
</li>
<li>
<p>用<code>./tools/bin/sstable2json</code>可以打开这堆data文件来看。下面是打开一个data文件的输出。</p>
<ul>
<li>从输出来看，存储的时候的key就是partition key。如果有多个，会用<code>：</code>隔开</li>
<li>然后它是这样的：
<ul>
<li>不是partition key的primary key会作为第一个column的名字，同样用:隔开。</li>
<li>接下来不是key的column和不是partition key的primary key联合起来作为column的名字。</li>
<li>比如：那么key就是&quot;name:age&quot;, 然后cells里面的第一行会是,最后是时间戳<br>
<code>[&quot;address:salary&quot;,&quot;&quot;,1558958953681000]</code></li>
<li>第二行会是：<br>
<code>[&quot;address:salary:character&quot;,character_value,1558958953681000]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    name text PRIMARY KEY,
    age bigint,
    address int,
    salary int,
    character blob,
    PRIMARY KEY ((name, age), address, salary)
</code></pre>
<h3 id="从memtables到sstable"><a class="header-anchor" href="#从memtables到sstable"></a>从memTables到SSTable</h3>
<ul>
<li>
<p>Cassandra flushes the memtables to disk when either the commit log space threshold or the memtable cleanup threshold is reached.</p>
<ul>
<li><code>memtable_cleanup_threshold</code> 后面一种应该和这个参数有关</li>
<li>在<code>expert cassandra</code>的书里有三种情况下面会flush。不包括手动flush</li>
</ul>
</li>
<li>
<blockquote>
<p>To flush the data, Cassandra sorts memtables by token and then writes the data to disk sequentially.<br>
Cassandra在将数据写到disk的时候，同时会将memtables按照token排序。_这个token是不是就是key算出来的那个token？但是table怎么按照token排序呢，应该说的是table里面的数据吧 _</p>
</blockquote>
</li>
<li>
<blockquote>
<p>A partition index is also created on the disk that maps the tokens to a location on disk.<br>
partition index是在这里才算出来的。那么之前就都是token。___ Memtble里面的也都是token？___</p>
</blockquote>
</li>
<li>
<p>flush的时候不是一把头全写进去的。会先把memTable的数据放到一个queue里面。这个queue的大小可以在configuration里面定义。</p>
<blockquote>
<p>The queue can be configured with the memtable_heap_space_in_mb or memtable_offheap_space_in_mb setting</p>
</blockquote>
</li>
<li>
<p>You can manually flush a table using nodetool flush.</p>
</li>
<li>
<blockquote>
<p>Consequently, a partition is typically stored across multiple SSTable files.</p>
</blockquote>
</li>
<li>
<p>相同partition key的记录应该是存贮在一个node上面，但是也有可能是多个文件，要看数据量。</p>
</li>
</ul>
<h3 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h3>
<ul>
<li><a href="https://blog.csdn.net/fs1360472174/article/details/55005335/" target="_blank" rel="noopener">官方文档–读写数据</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-cassandraxu2/index.html" target="_blank" rel="noopener">cassandra数据库详解</a></li>
<li><a href="https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataWritten.html" target="_blank" rel="noopener">cassandra读写过程</a></li>
<li><a href="https://blog.csdn.net/qinzhihu/article/details/8807776" target="_blank" rel="noopener">一篇很通俗的blog</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/01/17/Cassandra%20System%20Log%20Analyses/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/01/17/Cassandra%20System%20Log%20Analyses/" class="post-title-link" itemprop="url">Cassandra System Log Analyses</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-17 14:28:35" itemprop="dateCreated datePublished" datetime="2019-01-17T14:28:35+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 15:32:29" itemprop="dateModified" datetime="2021-06-04T15:32:29+08:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/cassandra/" itemprop="url" rel="index"><span itemprop="name">cassandra</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/01/17/Cassandra%20System%20Log%20Analyses/" class="post-meta-item leancloud_visitors" data-flag-title="Cassandra System Log Analyses" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/01/17/Cassandra%20System%20Log%20Analyses/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/01/17/Cassandra%20System%20Log%20Analyses/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>了解<code>Cassandra</code>的<code>system log</code>，可以看到<code>Cassandra</code>在干嘛。其中会涉及到<code>cassandra</code>的一些机制，概念记录下来。</p>
<h2 id="nodetool"><a class="header-anchor" href="#nodetool"></a>Nodetool</h2>
<p><code>Cassandra</code>的状态可以用<code>NodeTool</code>来检查，如果采用了<code>ssl</code>认证，那么命令是 <code>NodeTool --ssl</code></p>
<h2 id="gossip-tasks"><a class="header-anchor" href="#gossip-tasks"></a>Gossip Tasks</h2>
<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-cassandra3x3/index.html" target="_blank" rel="noopener">Apache Cassandra 3.X 系列</a></p>
</blockquote>
<ul>
<li>名字太好记 ，有没有 😃</li>
<li><code>Cassandra</code>的各个节点是无中心化对待的。能做到这一点的一个关键是使用了<code>Gossip</code>协议。这是一个很适用于不可信网络的协议
<ul>
<li><code>Cassandra</code>中<code>Gossip</code>协议被实现在类<code>Gossiper</code>中。</li>
<li><code>Gossiper</code>类维护了一个节点列表，这个列表里包括存活的和死亡的节点。</li>
<li><code>GossipTask</code> 是位于 <code>org.apche.cassandra.gms.Gossip</code> 类下的一个内部类。</li>
<li><code>GossipTask</code>会向其他节点发消息，默认时间是<code>1s</code></li>
</ul>
</li>
</ul>
<h3 id="pending-task-log"><a class="header-anchor" href="#pending-task-log"></a>Pending task log</h3>
<ul>
<li>
<p>在<code>log</code>里面会有：</p>
<pre><code>[GossipTasks:1] 2019-01-03 04:19:33,680 Gossiper.java:751 - Gossip stage has 378 pending tasks; skipping status check (no nodes will be marked down)
</code></pre>
</li>
</ul>
<h3 id="pause-error-not-making-nodes-down"><a class="header-anchor" href="#pause-error-not-making-nodes-down"></a>Pause Error: Not making Nodes Down</h3>
<blockquote>
<p><a href="http://www.cnblogs.com/jobforlife/p/7092467.html" target="_blank" rel="noopener">error解释</a></p>
</blockquote>
<ul>
<li>在<code>log</code>里面经常会出现</li>
<li>含义：<code>cassandra</code>在做其他事情，导致<code>Gossip</code>停顿了， <code>hang</code>住了。但是并不标示<code>node</code>状态。</li>
<li>通常是<code>GC</code>的时候，这一句的上一句<code>log</code>确实提示了一次<code>55742ms</code>的<code>GC</code></li>
<li><strong><code>GC</code>通常也发生在有很多<code>task</code>的时候，所以应该看看其他在做什么<code>task</code></strong></li>
</ul>
<pre><code>WARN  [GossipTasks:1] 2019-01-02 00:00:04,546 FailureDetector.java:287 - Not marking nodes down due to local pause of 54491963082 &gt; 5000000000
</code></pre>
<h2 id="service-thread"><a class="header-anchor" href="#service-thread"></a>Service Thread</h2>
<p>没有看到这个<code>Service Thread</code>的具体解释。从<code>log</code>里面看有很多功能</p>
<h3 id="gcinspector"><a class="header-anchor" href="#gcinspector"></a>GCInspector</h3>
<ul>
<li>在<code>log</code>里面是：</li>
</ul>
<pre><code>INFO  [Service Thread] GCInspector.java:284 - ConcurrentMarkSweep GC in 55742ms.  CMS Old Gen: 7331643368 -&gt; 7331643360; Par Eden Space: 1006632960 -&gt; 784484600; Par Survivor Space: 125829104 -&gt; 0
</code></pre>
<ul>
<li>这句<code>log</code>的意思是：做了一次<code>CMS GC</code>。然后数字对应，<code>11</code>位是<code>G</code>，<code>9</code>位是<code>M</code>，所以 <code>eden</code>区是784M</li>
<li>参考本站<code>GC</code>的文章了解更多<code>CMS</code>算法的内容</li>
</ul>
<h3 id="statuslogger"><a class="header-anchor" href="#statuslogger"></a>StatusLogger</h3>
<p>如此简单的一个函数也有好几种<code>log</code>啦。</p>
<h4 id="stage"><a class="header-anchor" href="#stage"></a>Stage</h4>
<p>打印出各种<code>stage</code>的状态，一个接一个的<code>pool</code>的状态。真心不少啊。</p>
<ul>
<li>在<code>log</code>里面会有：</li>
</ul>
<pre><code>INFO  [Service Thread] StatusLogger.java:52 - Pool Name Active   Pending      Completed   Blocked  All Time Blocked
</code></pre>
<h4 id="cache"><a class="header-anchor" href="#cache"></a>Cache</h4>
<p>输出<code>KeyCache</code> 和 <code>RowCache</code>的状态</p>
<ul>
<li>在<code>log</code>里面是：</li>
</ul>
<pre><code>INFO  [Service Thread] StatusLogger.java:88 - Cache Type  Size Capacity KeysToSave
INFO  [Service Thread] StatusLogger.java:90 - KeyCache   1406343  104857600
</code></pre>
<h4 id="memtable"><a class="header-anchor" href="#memtable"></a>memTable</h4>
<ul>
<li>在<code>log</code>里面是：</li>
</ul>
<pre><code>  [Service Thread]  StatusLogger.java:98 - Table                       Memtable        ops,data
  [Service Thread]  StatusLogger.java:106   
                &lt;table_name&gt;    6284,288376
</code></pre>
<ul>
<li><code>Cassandra</code>的<code>API</code>里面对于<code>StatusLogger</code>也没有解释。 ORZ，看来是个很直白的文件啊<br>
-<code>org.apache.cassandra.utils.StatusLogger</code> 只有一个函数<code>log()</code></li>
</ul>
<pre><code>logger.info(String.format(&quot;%-25s%20s&quot;, &quot;Table&quot;, &quot;Memtable ops,data&quot;));
logger.info(String.format(&quot;%-25s%20s&quot;,
                   cfs.keyspace.getName() 
				   + &quot;.&quot; + cfs.name,                                      cfs.metric.memtableColumnsCount.getValue() 
				   + &quot;,&quot; + cfs.metric.memtableLiveDataSize.getValue())); }
</code></pre>
<ul>
<li>所以，第一个数值是<code>memTable</code>的<code>column</code>的个数，第二个是<code>data</code>的<code>size</code></li>
<li>一个问题是： 这个<code>column</code>也太多了吧。。。。。。</li>
<li>被大神吊打了。这个值是表访问次数。</li>
</ul>
<h2 id="periodic-commit-log-syncer"><a class="header-anchor" href="#periodic-commit-log-syncer"></a>PERIODIC-COMMIT-LOG-SYNCER</h2>
<ul>
<li>在<code>log</code>里面是：</li>
</ul>
<pre><code>WARN  [PERIODIC-COMMIT-LOG-SYNCER]  AbstractCommitLogService.java:117 - Out of 5 commit log syncs over the past 573s with average duration of 9734.40ms

WARNING [PERIODIC-COMMIT-LOG-SYNCER]  NoSpamLogger.java:94 - Out of 1 commit log syncs over the past 0.00s with average duration of 10508.31ms, 1 have exceeded the configured commit interval by an average of 508.31ms
</code></pre>
<ul>
<li>这个应该是将<code>commit log</code>写到<code>disk</code>上面的<code>task</code>。没有再查资料。参考本站<code>cassandra</code>写过程那篇博客</li>
</ul>
<h2 id="indexsummarymanager"><a class="header-anchor" href="#indexsummarymanager"></a>IndexSummaryManager</h2>
<ul>
<li>在<code>log</code>里面是：</li>
</ul>
<pre><code>INFO  [IndexSummaryManager:1] IndexSummaryRedistribution.java:74 - Redistributing index summaries
</code></pre>
<ul>
<li><strong>Manages the fixed-size memory pool for index summaries, periodically resizing them in order to give more memory to hot sstables and less memory to cold sstables.</strong></li>
<li>还不是很理解，就是说<code>index summary</code>一开始也是存在内存中的吗？确实在参数配置里面有<code>index_summary_capacity_in_mb</code>和<code>index_summary_resize_interval_in_minutes</code></li>
</ul>
<h2 id="compactionexecutor"><a class="header-anchor" href="#compactionexecutor"></a>CompactionExecutor</h2>
<blockquote>
<p><a href="https://stackoverflow.com/questions/59324352/maximum-memory-usage-reached-4294967296-cannot-allocate-chunk-of-1048576" target="_blank" rel="noopener">cannot-allocate-chunk</a></p>
</blockquote>
<pre><code>[CompactionExecutor:290]  AutoSavingCache.java:395 - Saved CounterCache (55 items) in 47 ms

[CompactionExecutor:291]  AutoSavingCache.java:395 - Saved KeyCache (2979 items) in 55 ms

[CompactionExecutor:460]  BigTableWriter.java:211 - Writing large partition 

[CompactionExecutor:483]  NoSpamLogger.java:91 - Maximum memory usage reached (536870912), cannot allocate chunk of 1048576
</code></pre>
<ul>
<li>上面是<code>compactionExecutor</code>的日志，开始三行都是比较容易理解的。</li>
<li>最后一句是关于一个<code>File Cache</code>，也叫<code>Buffer Tool</code>的。这个含义是说这个<code>Cache</code>已经满了。默认的配置就是<code>512M</code></li>
<li>在下面的这篇链接里面有描述， <code>File Cache</code>是为了读数据的时候加速用的。如果有大批量的读数据，那么这个<code>Cache</code>就会被撑满。</li>
<li>结合上面<code>readStage</code>的<code>exception</code>，<code>Cassandra</code>的读性能应该是下降了</li>
</ul>
<h2 id="stage-v2"><a class="header-anchor" href="#stage-v2"></a>Stage</h2>
<h3 id="mutationstage"><a class="header-anchor" href="#mutationstage"></a>MutationStage</h3>
<pre><code>[MutationStage-3]  ColumnFamilyStore.java:2187 - Truncating &lt;table_name&gt;
</code></pre>
<h3 id="migrationstage"><a class="header-anchor" href="#migrationstage"></a>MigrationStage</h3>
<pre><code>[MigrationStage:1]  ColumnFamilyStore.java:427 - Initializing &lt;table_name&gt;

[MigrationStage:1]  MigrationCoordinator.java:448 - Sending schema pull request to /xx.xx.xx.xx at 1621984266178 with timeout 10000
</code></pre>
<h3 id="readrepairstage"><a class="header-anchor" href="#readrepairstage"></a>ReadRepairStage</h3>
<blockquote>
<p><a href="https://stackoverflow.com/questions/50207323/cassandra3-exception-in-thread-threadreadrepairstage-operation-timed-out-r" target="_blank" rel="noopener">cassandra3-exception-in-thread-threadreadrepairstage</a></p>
</blockquote>
<pre><code>[ReadRepairStage:23]  CassandraDaemon.java:244 - Exception in thread Thread[ReadRepairStage:23,5,main]
</code></pre>
<ul>
<li>
<p>我们自己的日志里面只有上面一句话。<code>stackoverflow</code> 上面的有打出来的是<code>readtimeout</code>错误</p>
<pre><code>ERROR [ReadRepairStage:12] 2018-05-07 10:35:19,056 CassandraDaemon.java:228 - Exception in thread Thread[ReadRepairStage:12,5,main]
org.apache.cassandra.exceptions.ReadTimeoutException: Operation timed out - received only 0 responses.
</code></pre>
</li>
</ul>
<h3 id="contermutationstage"><a class="header-anchor" href="#contermutationstage"></a>ConterMutationStage</h3>
<blockquote>
<p><a href="https://stackoverflow.com/questions/45306061/cassandra-writetimeoutexception-exception-in-countermutationstage-node-dies-ev" target="_blank" rel="noopener">writetimeoutexception-exception-in-countermutationstage</a><br>
<a href="https://stackoverflow.com/questions/29667596/after-high-traffic-cassandra-writetimeoutexception" target="_blank" rel="noopener">Stack Overflow - writetimeoutexception</a></p>
</blockquote>
<pre><code>[CounterMutationStage-227]  AbstractLocalAwareExecutorService.java:166 - Uncaught exception on thread Thread[CounterMutationStage-227,5,main]
</code></pre>
<ul>
<li>不知道为啥，上面的<code>log</code>没有打出具体的信息。在我这里也叫看不到到底是什么错误了</li>
<li>上面的链接里面是<code>WriteTimeoutException</code>，我们自己的系统里面也是<code>timeout</code>的错误。按照分析，可能是<code>I/O</code>撑不住了。这么看来也完全有可能，目前从日志里面，看不出来磁盘和内存的错误。</li>
<li>第二个链接中的<code>Cassandra</code>的版本比较旧，还是<code>2.x</code>，日志的表头有些不同，但是也是犹豫<code>CounterMutationStage</code>导致的写时候的<code>timeout</code>，其中提到频繁的<code>GC</code>也会导致性能下降<br>
<strong>are your Cassandra nodes experiencing high GC pressure (check pauses in gc log - especially on the other nodes, at times correlating with the WriteTimeou</strong></li>
</ul>
<h2 id="hintsdispatcher"><a class="header-anchor" href="#hintsdispatcher"></a>HintsDispatcher</h2>
<pre><code>[HintsDispatcher:3]  HintsStore.java:133 - Deleted hint file 21869582-fb73-426c-827e-15a75b506223-1622088330901-1.hints
[HintsDispatcher:3]  HintsDispatchExecutor.java:282 - Finished hinted handoff of file 21869582-fb73-426c-827e-15a75b506223-1622088330901-1.hints to endpoint /192.168.94.54: 21869582-fb73-426c-827e-15a75b506223
</code></pre>
<ul>
<li>这回跑测试的时候有一个节点挂了，然后就出现了<code>hint</code>相关的日志</li>
<li>比较有意思的是，每个节点上面都有上诉日志</li>
</ul>
<h2 id="scheduledtasks"><a class="header-anchor" href="#scheduledtasks"></a>ScheduledTasks</h2>
<pre><code>[ReadStage-12]  MonitoringTask.java:93 - Scheduling monitoring task with report interval of 5000 ms, max operations 50 

[ScheduledTasks:1]  NoSpamLogger.java:91 - Some operations were slow, details available at debug level (debug.log)
</code></pre>
<ul>
<li>
<p>这两句日志在源码里面是在一块的，如下：</p>
<pre><code>logger.info(&quot;Scheduling monitoring task with report interval of {} ms, max operations {}&quot;, reportIntervalMillis, maxOperations);
this.reportingTask = ScheduledExecutors.scheduledTasks.scheduleWithFixedDelay(() -&gt; logOperations(ApproximateTime.currentTimeMillis()),   reportIntervalMillis,                   reportIntervalMillis, TimeUnit.MILLISECONDS);
</code></pre>
</li>
<li>
<p>第二句就是在<code>logOperations</code>里面打印出来的。看起来，<code>Cassandra</code>是在加载类的时候起来的<code>MonitoringTask</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/01/14/React%E5%85%A5%E9%97%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/01/14/React%E5%85%A5%E9%97%A8-1/" class="post-title-link" itemprop="url">React入门(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-14 16:35:28" itemprop="dateCreated datePublished" datetime="2019-01-14T16:35:28+08:00">2019-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-15 14:53:45" itemprop="dateModified" datetime="2019-01-15T14:53:45+08:00">2019-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/01/14/React%E5%85%A5%E9%97%A8-1/" class="post-meta-item leancloud_visitors" data-flag-title="React入门(1)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo_blog/2019/01/14/React%E5%85%A5%E9%97%A8-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo_blog/2019/01/14/React%E5%85%A5%E9%97%A8-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="react入门"><a class="header-anchor" href="#react入门"></a>React入门</h1>
<h2 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h2>
<p><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮一峰的博客</a></p>
<h2 id="react-是什么"><a class="header-anchor" href="#react-是什么"></a>React 是什么</h2>
<p>React是Facebook发布的前端框架</p>
<h2 id="react的优势"><a class="header-anchor" href="#react的优势"></a>React的优势</h2>
<p>现在还不知道哪里有优势。最大的应该就是JXS，然后可以组件化。</p>
<h2 id="react的一些相关概念"><a class="header-anchor" href="#react的一些相关概念"></a>React的一些相关概念</h2>
<h3 id="dom"><a class="header-anchor" href="#dom"></a>DOM</h3>
<ul>
<li><code>DOM</code>: 文档对象模型(Document Object Model). 这是表示和处理一个HTML或XML文档的常用方法。<br>
<a href="https://baike.baidu.com/item/DOM/50288#1_2" target="_blank" rel="noopener">DOM:百度百科解释</a></li>
<li>目前的理解是：DOM其实就是一套描述数据结构的方法。一开始大家不统一，后来有W3C给出了规范，可以分为DOM核心，HTML的DOM，XML的DOM这几个</li>
<li>进一步的理解：DOM是前端原来就有的一个概念，然后React给这个概念赋予了一些新的内涵。所有有React DOM这个说法。React DOM其实就是组件。</li>
</ul>
<h3 id="jsx"><a class="header-anchor" href="#jsx"></a>JSX</h3>
<p>JSX 语法是React独有的。目前的理解是：</p>
<ul>
<li>JSX语法在支持JS里面处理HTML。</li>
<li>如果这样的脚本插在html里面，要用<code>text/babel</code>来标记。 babel命令可以将JSX语法编译成为JS语法。</li>
<li>JSX 的基本语法规则：遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</li>
</ul>
<p><a href="https://reactjs.org/docs/rendering-elements.html#jsx-syntax" target="_blank" rel="noopener">JSX语法</a></p>
<h3 id="react组件"><a class="header-anchor" href="#react组件"></a>React组件</h3>
<ul>
<li>使用<code>React.createClass(</code> 来创建一个组件，组件可以认为和HTML的标签一样使用。e.g：MyComponents是创建出来的一个组件。</li>
</ul>
<pre><code>&lt;MyComponent
    &quot;Hello world!&quot;;
/MyComponent&gt;
</code></pre>
<ul>
<li>前面提到过React DOM，其实就是组件。组件在定义时候，只是内存里面的一个数据，但是因为可以作为HTML标签使用，然后render成为HTML里面的DOM，所有被称为virtual DOM</li>
<li>组件类只能包含一个顶层元素。</li>
<li>所有的组件类必须有自己的render方法，来</li>
<li>组件的属性可以在组件类的 <code>this.props</code> 对象上获取, 其中的<code>this.props.children</code>代表所有的子节点。</li>
<li><code>PropTypes</code> 可以用来限定参数的类型， <code>getDefaultProps</code> 方法可以用来设置组件属性的默认值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo_blog/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/hexo_blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/hexo_blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/hexo_blog/page/5/">5</a><a class="extend next" rel="next" href="/hexo_blog/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lynn Shen</p>
  <div class="site-description" itemprop="description">35岁开始的博客，有点晚哦</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo_blog/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo_blog/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ffyWzhHueqJEC5UEfPUhAWzF-MdYXbMMI","app_key":"vS7xTvT1vD1DxluERkmlkvme","server_url":"https://sallyslove.github.io/hexo_blog","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/hexo_blog/lib/anime.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo_blog/js/utils.js"></script>

<script src="/hexo_blog/js/motion.js"></script>


<script src="/hexo_blog/js/schemes/muse.js"></script>


<script src="/hexo_blog/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'ffyWzhHueqJEC5UEfPUhAWzF-MdYXbMMI',
      appKey     : 'vS7xTvT1vD1DxluERkmlkvme',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
