<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/hexo_blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/hexo_blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/hexo_blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/hexo_blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="35岁开始的博客，有点晚哦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo_blog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sallyslove.github.io/hexo_blog/">





  <title>跬步</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo_blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo_blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/hexo_blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo_blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2020/12/10/Scala-Env-Related/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2020/12/10/Scala-Env-Related/" itemprop="url">Scala Env Related</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-10T10:22:10+08:00">
                2020-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Scala/" itemprop="url" rel="index">
                    <span itemprop="name">Scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原来的<code>Scala</code>博客越来越大了。将里面的环境的部分抽出来成为这篇博客。话说对比于<code>Java</code>的<code>Maven</code>，<code>Sbt</code>也太不好用了。</p>
<h2 id="itellij"><a class="header-anchor" href="#itellij"></a>ItelliJ</h2>
<ul>
<li><a href="https://blog.csdn.net/high2011/article/details/76541233" target="_blank" rel="noopener">基本scala环境在IJ里面的搭建</a></li>
</ul>
<h3 id="sbt工程already-exist"><a class="header-anchor" href="#sbt工程already-exist"></a>SBT工程already exist</h3>
<ul>
<li>把一个scala的工程导入，又删除之后， 就再也导不到IJ里面了。</li>
<li>IJ会报错。解决方法在下面的链接里面。</li>
<li><a href="https://stackoverflow.com/questions/24937328/intellij-idea-cannot-import-sbt-project" target="_blank" rel="noopener">scala重复导入</a></li>
</ul>
<h3 id="skipping-scala-files-without-a-scala-sdk"><a class="header-anchor" href="#skipping-scala-files-without-a-scala-sdk"></a>skipping Scala files without a Scala SDK</h3>
<ul>
<li>这个问题是因为没有<code>scala</code>的<code>SDK</code>导致的</li>
<li><a href="https://stackoverflow.com/questions/34798160/problems-importing-scala-libraries-in-intellij" target="_blank" rel="noopener">没有scala SDK</a></li>
<li><a href="https://www.jetbrains.com/help/idea/2016.2/adding-frameworks-support.html" target="_blank" rel="noopener">IJ配置framework support</a></li>
</ul>
<h3 id="depencensy-scala-ij-sbt-not-found-type-moduleid"><a class="header-anchor" href="#depencensy-scala-ij-sbt-not-found-type-moduleid"></a>depencensy.scala IJ SBT not found: type ModuleID</h3>
<ul>
<li>同时也会有&quot;dump project structure from sbt shell&quot;</li>
<li>项目的依赖也无法更新</li>
<li>解决的办法是在导入项目的时候，将<code>Use sbt shell</code>和<code>Download</code>里面的项目都勾上。这样就可以解决一堆问题</li>
</ul>
<h2 id="sbt"><a class="header-anchor" href="#sbt"></a>SBT</h2>
<ul>
<li>安装<code>SBT</code>, <a href="https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html" target="_blank" rel="noopener">SBT下载</a></li>
</ul>
<h3 id="常用命令"><a class="header-anchor" href="#常用命令"></a>常用命令</h3>
<ul>
<li><code>show name</code>: 当前项目名字</li>
<li><code>show libraryDependencies</code>： 常看依赖</li>
<li><code>compile</code>：编译</li>
<li><code>package</code>:打包，如果有<code>Dockfile</code>，会将镜像也做出来</li>
<li><code>sbt evicted</code>: 查看依赖</li>
</ul>
<h3 id="sbt-配置"><a class="header-anchor" href="#sbt-配置"></a>SBT 配置</h3>
<h4 id="仓库配置"><a class="header-anchor" href="#仓库配置"></a>仓库配置</h4>
<ul>
<li><a href="https://www.jianshu.com/p/6db9bac848bd" target="_blank" rel="noopener">sbt仓库设置</a></li>
<li><code>sbt</code>的仓库可以分两层配置
<ul>
<li>
<p>每个项目可以配置自己的仓库，在<code>project</code>目录下面的<code>plugin.sbt</code>里面可以如下配置：</p>
<pre><code>resolvers += &quot;SBT repository&quot; at &quot;https://xxx.xxx.xxx.xxx/&lt;repo&gt;&quot;
</code></pre>
</li>
<li>
<p>在<code>~/.sbt</code>目录下面有一个<code>repository</code>的文件，可以配置仓库。按照上面的链接就可以了。这样配置，就是<code>sbt</code>全局的了</p>
</li>
</ul>
</li>
</ul>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://www.scala-sbt.org/1.x/docs/zh-cn/Directories.html" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://blog.csdn.net/zrc199021/article/details/51776256" target="_blank" rel="noopener">CSDN博客一篇</a></li>
</ul>
<h3 id="could-not-access-type-localtime-in-value-org-joda-time"><a class="header-anchor" href="#could-not-access-type-localtime-in-value-org-joda-time"></a>Could not access type LocalTime in value org.joda.time</h3>
<ul>
<li>在用<code>SBT compile</code>时候报以下的错误：</li>
</ul>
<pre><code>[error] missing or invalid dependency detected while loading class file 'DefaultReads.class'.
[error] Could not access type LocalTime in value org.joda.time,
[error] because it (or its dependencies) are missing. Check your build definition for
[error] missing or conflicting dependencies. (Re-run with `-Ylog-classpath` to see the problematic classpath.)
[error] A full rebuild may help if 'DefaultReads.class' was compiled against an incompatible version of org.joda.time.
</code></pre>
<ul>
<li>
<p><code>google</code>了一堆，在Stack Overflow上面有一堆类似的问题</p>
<ul>
<li><a href="https://stackoverflow.com/questions/8619348/why-is-scala-saying-it-can-t-see-members-of-org-joda-time-period" target="_blank" rel="noopener">joda-time-period</a></li>
<li><a href="https://stackoverflow.com/questions/38218926/cant-compile-scala-sbt-project" target="_blank" rel="noopener">cant-compile-scala-sbt-project</a></li>
</ul>
</li>
<li>
<p>实际解决的方式是：在<code>Dependency.scala</code>里面加入:</p>
<pre><code>val jodaTime: ModuleID = &quot;joda-time&quot; % &quot;joda-time&quot; % &quot;2.10.6&quot;
</code></pre>
<p>val joda: ModuleID = “org.joda”  % “joda-convert” % “1.6”</p>
</li>
<li>
<p>搜索<code>org.joda.time.LocalTime</code>,这个类是在<code>2.10.6</code>版本里面的。</p>
</li>
<li>
<p>奇怪的是这个版本的包没有<code>download</code>下来，手动下载放在<code>repo</code>里面，问题就解决了。</p>
</li>
<li>
<p>看到有的解释是说，如果只装了<code>java</code>，没有装<code>scala</code>的话就需要这两个依赖包，很有可能就是这个原因。因为我并没有额外安装<code>scala</code></p>
</li>
</ul>
<h3 id="object-play-not-found"><a class="header-anchor" href="#object-play-not-found"></a>object play not found</h3>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/36658125/object-play-not-found-in-scala-application" target="_blank" rel="noopener">object-play-not-found-in-scala-application</a></p>
</li>
<li>
<p>在解决这个问题的时候，发现几个有趣的地方：</p>
<ul>
<li>
<p>如果用<code>docker</code>的<code>plugin</code>去做<code>image</code>，和<code>sbt</code>直接<code>package</code>命令做<code>image</code>，前者支持换行时候<code>&amp;&amp;</code>，后者不支持</p>
</li>
<li>
<p><code>dependency</code>文件里面，在<code>java</code>的<code>maven</code>结构下面写成</p>
<pre><code>libraryDependencies += &quot;com.typesafe.play&quot; % &quot;play-json&quot; % &quot;2.5.2&quot;
</code></pre>
</li>
</ul>
<p>就可以了，在scala里面必须带上版本，写成</p>
<pre><code>  libraryDependencies += &quot;com.typesafe.play&quot; % &quot;play-json_2.11&quot; % &quot;2.5.2&quot;
</code></pre>
<p>否则会报错的</p>
</li>
</ul>
<h3 id="conflicting-cross-version-suffix"><a class="header-anchor" href="#conflicting-cross-version-suffix"></a>conflicting cross-version suffix</h3>
<ul>
<li>编译时候报错，这个也是上一个章节中<code>playjson</code>报的错误，其实就是在<code>build</code>文件里面指定了<code>scala</code>的版本是2.12，但是加进去依赖是2.11.就报错了。</li>
<li>将<code>playjson</code>的版本改为<code>play-json_2.12 % 2.7.2</code>也就好了。</li>
<li><a href="https://stackoverflow.com/questions/23617920/why-is-the-error-conflicting-cross-version-suffixes" target="_blank" rel="noopener">why-is-the-error-conflicting-cross-version-suffixes</a></li>
</ul>
<h3 id="not-found-type-moduleid"><a class="header-anchor" href="#not-found-type-moduleid"></a>not found: type ModuleID</h3>
<ul>
<li>这个错误真是狗血，让我很是郁闷了一会。<code>google</code>都没找到啥。在<code>git status</code>之后发现<code>repo</code>里面被改了一堆东西</li>
<li>再<code>git checkout</code>之后就正常了。<code>sbt</code>正常启动起来。</li>
<li>这一堆改动应当是<code>IDE</code>，就是<code>IJ</code>改的。<code>IJ</code>吧，感觉还是<code>maven</code>好用一点。</li>
</ul>
<h3 id="wrong-checksum"><a class="header-anchor" href="#wrong-checksum"></a>wrong checksum</h3>
<ul>
<li>这个错误只要将本地的包删除掉重新编译，不知道为啥会产生这种错误</li>
<li><a href="https://www.cnblogs.com/duchaoqun/p/12703935.html" target="_blank" rel="noopener">sbt wrong checksum</a></li>
</ul>
<h3 id="unsupported-platform-protoc-3-7-0-windows-x86-32-exe"><a class="header-anchor" href="#unsupported-platform-protoc-3-7-0-windows-x86-32-exe"></a>Unsupported platform: protoc-3.7.0-windows-x86_32.exe</h3>
<pre><code>[error] stack trace is suppressed; run 'last synchronizer / Compile / protocGenerate' for the full output
[error] (synchronizer / Compile / protocGenerate) error occurred while compiling protobuf files: Unsupported platform: protoc-3.7.0-windows-x86_32.exe
</code></pre>
<h4 id="问题和解决"><a class="header-anchor" href="#问题和解决"></a>问题和解决</h4>
<ul>
<li>这是个奇怪的问题，问题本身很直白，在<code>gitbash</code>里面调用<code>protoc</code>时候将平台认成了<code>X32</code>，但是本身<code>protoc</code>不支持<code>X32</code>，就报错了。</li>
<li>最后这个问题也没解决，花了一周时间，也没用。应该是因为之前我的笔记本是32位的，后期是64位的，所以认错了。</li>
<li>如果将<code>os.name</code>，<code>os.version</code>，<code>arch</code>这些在其他代码里面打印出来，<code>gitbash</code>里面也是正确是。不知道为啥通过<code>proto</code>调用的就是错误的</li>
<li><code>IJ</code>里面认的是对的，也就没有再纠结了。</li>
</ul>
<h4 id="protobuf"><a class="header-anchor" href="#protobuf"></a>protobuf</h4>
<ul>
<li><code>protoc</code>目前的理解是一种数据模型构建方式，类似<code>XML</code>，<code>JSON</code>。</li>
<li>这个<code>protoc</code>需要一个生成器，就是<code>JAR</code>包里面在找的。</li>
<li>原生来说，这个<code>3pp</code>是支持<code>JAVA</code>的，为了在<code>SCALA</code>里面运用的话，需要额外下载一个<code>plugin</code>：<a href="https://scalapb.github.io/docs/json" target="_blank" rel="noopener">scalapb</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2020/10/19/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2020/10/19/Kafka/" itemprop="url">Kafka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-19T16:07:33+08:00">
                2020-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开始学习卡夫卡，工作需要，开始得有点晚了。毕竟周围很多同事已经会了。嘛，人比人气死人，进步就好 (๑•̀ㅂ•́)و✧</p>
<h2 id="消息队列"><a class="header-anchor" href="#消息队列"></a>消息队列</h2>
<ul>
<li>看到一篇还不错的博客，作者层层深入，所以我觉得我也需要学习一下。</li>
<li><a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">这位作者的系列文章，貌似已经开公众号了，所以点击会跑到微信上面去。汗一个</a></li>
<li>五分钟时间看了一下，果然是好文章啊。</li>
<li>简单来说，使用消息队列可以解耦生产者和消费者；可以实现异步，提高效率</li>
<li>那么为什么在JAVA中已经有了很多现成的消费队列，还需要自己去写一些中间件呢？</li>
<li>这里面的原因挺多的，但是都很好理解，比如固化，JAVA的队列都是内存里面的，一下就没了，对于产品来说，肯定不能接受；再比如数据的处理，不能重复，或者排序。基于各种需求，自然就产生了各种各样的队列</li>
</ul>
<h2 id="zookeeper"><a class="header-anchor" href="#zookeeper"></a>Zookeeper</h2>
<ul>
<li>这位博客作者真是很有意思，深入浅出而且比较搞笑。口水话和我相似啊。所为光头就能变强，自宫就能成功嘛。(≧∇≦)ﾉ</li>
<li>仍旧参考其系列文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485115&amp;idx=1&amp;sn=5d269f40f820c82b460993669ca6242e&amp;chksm=ebd747badca0ceac9953f82e08b1d1a49498ebd4af77ec5d628a0682bb9f0ac5ab347411f654&amp;token=1741918942&amp;lang=zh_CN#rd" target="_blank" rel="noopener">微信的IP也太长了吧，什么是zookeeper</a></li>
<li><code>zookeeper</code>的功能包括：统一配置管理、统一命名服务、分布式锁、集群管理。这些功能听上去都超超超高大上啊~</li>
<li><code>Zookeeper</code>通过感知节点的变化，已经节点数据的变化来实现以上这些高大上的功能点</li>
<li>集群管理大致有点感觉，既然可以感知节点的变化，那么可以建立相应的临时节点，在有新的集群机器加入的时候。</li>
<li>分布式锁的功能就是说某个带锁的<code>zNode</code>，各个集群机器在访问这个<code>zNode</code>时候，会创建一个临时<code>node</code>，这个临时的节点上面有个带个号码，比如<code>0000001</code>，谁的最小，谁就获得访问这个特殊的<code>znode</code>的权利</li>
<li>统一命名服务有点没看明白，后面再研究吧</li>
</ul>
<h2 id="kafka"><a class="header-anchor" href="#kafka"></a>Kafka</h2>
<p><code>kafka</code>是一个消息队列，这个一句话解释感觉好拉风，一句话就说清楚了</p>
<h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3>
<ul>
<li><code>kafka</code>有以下几个基本概念：
<ul>
<li><code>topic</code>: 作为一个产品，<code>kafka</code>可以有多个消息队列，一个消息队列就是一个<code>topic</code>，有点类似数据库的表。对于一个<code>topic</code>，可以有多个生产者，也可以有多个消费者，这点很好理解。</li>
<li><code>partition</code>：因为一个<code>topic</code>上面会有多个消费者和生产者，所以分成了多个<code>partition</code>，每个生产者往不同的<code>partition</code>上面丢数据。<strong>这边有个问题，为什么要新引入这个概念呢？ 多个<code>topic</code>不行吗？</strong></li>
<li><code>broker</code>：那么<code>kafka</code>是支持分布式的，当然如此，也就是集群。那么集群里面可能就不止一个机器上安装了<code>kafka</code>，每个安装了<code>kafka</code>的机器就称为一个<code>broker</code>。需要注意的是，同一个<code>topic</code>的不同<code>partition</code>可能分布在不同的<code>broker</code>上面</li>
<li><code>replica</code>:大概分布式都要复制吧，不然宕机咋整呢 😉。但是这里需要注意的是，读写都只会对主的<code>partition</code>进行，备份就是备份，老老实实做备份的含义。当主<code>partition</code>在的<code>broker</code>宕机了，会重新选一个主的出来</li>
</ul>
</li>
</ul>
<h3 id="生产者"><a class="header-anchor" href="#生产者"></a>生产者</h3>
<ul>
<li><code>Kafka</code>和<code>Cassandra</code>一样，也是先写到缓存里面，然后再写到磁盘里面。不过<code>Kafka</code>只允许追加写入(顺序访问)，避免缓慢的随机 <code>I/O</code>操作。<strong>这句有点不明白，啥叫追加写入</strong></li>
</ul>
<h3 id="消费者"><a class="header-anchor" href="#消费者"></a>消费者</h3>
<ul>
<li>多个消费者消费同一个<code>topic</code>的可以组成一个消费者组，消费者组里面的消费者可以每个去消费一个<code>partition</code>，这样就提高了吞吐量</li>
<li>正常的读磁盘数据是需要将内核态数据拷贝到用户态的，而<code>Kafka</code> 通过调用<code>sendfile()</code>直接从内核空间（DMA的）到内核空间（Socket的），少做了一步拷贝的操作。昨天有同事部分分享时候说是省略了从磁盘读取。感觉这个说法不对，如果数据已经存储到了磁盘上面，是无法省略从磁盘读取的。这个需要进一步的学习</li>
<li>当消费者组里面一个消费者宕机之后，剩下的消费者需要重新分配，将空缺没有人消费的<code>partition</code>给安排出去。这个过程叫做<code>rebalancing</code>。从<code>kafka</code>的日志里面也能看到这句话</li>
<li>因为需要继续消费没消费完的<code>partition</code>，那么就需要知道之前的消费者消费到哪里了，就引入了偏移量这个概念。</li>
<li>偏移量：<code>offset</code>在<code>broker</code>以内部<code>topic(__consumer_offsets)</code>的方式存储，早期的版本可能存在<code>zookeeper</code>里面</li>
</ul>
<h3 id="kafka和zookeeper"><a class="header-anchor" href="#kafka和zookeeper"></a>Kafka和Zookeeper</h3>
<ul>
<li><code>Zookeeper</code>是<code>Kafka</code>一个重要的依赖。</li>
<li>探测<code>broker</code>和<code>consumer</code>的添加或移除。</li>
<li>负责维护所有<code>partition</code>的领导者/从属者关系（主分区和备份分区），如果主分区挂了，需要选举出备份分区作为主分区。</li>
<li>维护<code>topic、partition</code>等元配置信息</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2020/09/15/how-endpoint-be-connected-into-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2020/09/15/how-endpoint-be-connected-into-network/" itemprop="url">how endpoint be connected into network</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-15T17:14:05+08:00">
                2020-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>这篇博客用来记录运行时的过程，包括：
<ul>
<li>网卡接入网络</li>
</ul>
</li>
</ul>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<p>1）<a href="https://www.cnblogs.com/wade-luffy/p/8548519.html" target="_blank" rel="noopener">局域网的路由器&amp;网卡</a></p>
<h2 id="消息层次"><a class="header-anchor" href="#消息层次"></a>消息层次</h2>
<ul>
<li>从以下的两张图片可以清晰地看到网络的分层，以及对应关系。</li>
<li><code>Ethernet II, Src: HewlettP_2f:87:8f (b0:0c:d1:2f:87:8f), Dst: Broadcast (ff:ff:ff:ff:ff:ff)</code>是数据链路层，以太网，从中能看到<code>MAC地址</code>，并且是一个广播消息</li>
<li><code>Internet Protocol Version 4, Src: 0.0.0.0, Dst: 255.255.255.255</code>, IP数据，能看到源和目的地的IP地址</li>
<li><code>User Datagram Protocol, Src Port: 68, Dst Port: 67</code>, UDP协议，能看到进出端口</li>
<li><code>Bootstrap Protocol (Discover)</code> 最终的协议是<code>DHCP</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_package_wireshark.png" alt="DHCP_package_wireshark"></p>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_package.png" alt="DHCP_package"></p>
<h2 id="设备接入网络"><a class="header-anchor" href="#设备接入网络"></a>设备接入网络</h2>
<ul>
<li>以网卡为例，网卡在出厂时候应该是有<code>MAC地址</code>的，在接入网络时，会按照<code>DHCP</code>协议获取<code>IP</code>地址</li>
</ul>
<h3 id="动态主机配置协议-dhcp-dynamic-host-configuration-protocol"><a class="header-anchor" href="#动态主机配置协议-dhcp-dynamic-host-configuration-protocol"></a>动态主机配置协议 DHCP(Dynamic Host Configuration Protocol)</h3>
<ul>
<li><code>IP</code>地址可以有两种分配方式，一种是静态手动分配一个<code>IP</code>，另外一种就是依赖<code>DHCP 动态主机配置协议</code> 进行动态<code>IP分配</code>。前者称为<code>静态IP地址</code>,后者称为<code>动态IP地址</code></li>
<li><code>DHCP</code>的前身是<code>BOOTP协议 Bootstrap Protocol</code>, <code>wireshark</code>里面过滤时候得用<code>BOOTP</code>来过滤</li>
<li><code>DHCP</code>是应用层的协议，和<code>HTTP</code>,<code>DNS</code>在一层。话说这个层不层的，有点无聊啊，好吧，确实数据是包了一层又一层。</li>
<li><code>DHCP</code>和<code>DNS</code>一样，是架在<code>UDP</code>（<code>UDP</code>是传输层协议）上面的,<code>DHCP</code>协议是工作在端口67和68上面</li>
<li>一次IP分配的交互流程如下图，这是按照第一个参考链接，使用<code>ipconfig /release</code>和<code>ipconfig /renew</code>命令后抓到的包，很是有趣啊。<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP.png" alt="DHCP握手"></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_wireshark.png" alt="DHCP_wireshark"></p>
<ul>
<li>
<p>在第一条<code>discover</code>信息里面，可以看到客户端从<code>0.0.0.0</code>的端口<code>68</code>往服务器端的<code>255.255.255.255</code>的端口<code>67</code>发了一条<code>Boot request</code>信息，同时也可以看出来，这条消息在传输层是<code>UDP</code>协议<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_discovery.png" alt="DHCP_discovery"></p>
</li>
<li>
<p>第二条消息是<code>offer</code>消息：</p>
<ul>
<li>里面带了客户端的<code>IP地址</code>，用<code>ipconfig</code>命令来看，也确实是当前我的<code>laptop</code>的<code>IP地址</code>。</li>
<li>这点和第一个参考链接里面的不一样，我自己抓的<code>offer</code>信息，是直接发往当前的<code>client IP</code>地址的，而链接里面的，仍旧是一个广播消息，是发往<code>0.0.0.0</code>的。似乎后者更为合理，毕竟这个时候，有可能有多个客户端在请求。</li>
<li>同时，在<code>(54)</code>消息里面告诉对方自己是个<code>DHCP</code>服务器，毕竟一个局域网中可以存在多个<code>DHCP</code>服务器</li>
<li>在这条消息中，同时包含了子网掩码和<code>DNS</code>服务器<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_offer.png" alt="DHCP_offer"></li>
</ul>
</li>
<li>
<p>第三条消息仍旧是一条广播消息，客户端并没有在此时就使用分配的<code>IP</code>地址，而是在这条消息里面告诉服务器端，它要开始使用这个地址了<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_request.png" alt="DHCP_request"></p>
</li>
<li>
<p>最后一条服务器<code>ACK</code>消息里面，有<code>IP租用时间</code>，<strong><em>为啥我的这个值只有一小时啊</em></strong></p>
<ul>
<li>通常租借期应该是一天，然后在时间到了一半的时候，客户端会给服务器端发续接消息<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_ACK.png" alt="DHCP_ACK"></li>
</ul>
</li>
<li>
<p><code>DHCP starvation attack</code>：这应该是网络安全范畴了，假设用许多假的客户端给服务器发消息，可以占用满所有<code>IP地址</code>，然后可以冒充服务器，给客户端回消息</p>
</li>
<li>
<p><code>DHCP中继</code>： <code>DHCP</code>是一个局域网的协议，当客户端和服务器端不在一个局域网中，就需要用到<code>DHCP中继</code>，在参考链接<code>4和5</code>里面，有描述细节</p>
</li>
<li>
<p>参考链接<br>
1） <a href="https://blog.csdn.net/u012359618/article/details/51872678" target="_blank" rel="noopener">DHCP详解</a><br>
2） <a href="https://zhuanlan.zhihu.com/p/89446304" target="_blank" rel="noopener">DHCP详解2</a><br>
3） <a href="https://zhuanlan.zhihu.com/netops" target="_blank" rel="noopener">知乎找到一个很好的专栏，确实需要系列文章，但是怎么系列，有点难度啊：计算机网络学习笔记</a><br>
4） <a href="https://zhuanlan.zhihu.com/p/152330355" target="_blank" rel="noopener">简述DHCP和DNS</a><br>
5） <a href="https://zhuanlan.zhihu.com/p/109846848" target="_blank" rel="noopener">详解什么是DHCP，DHCP的工作原理</a></p>
</li>
</ul>
<h2 id="设备发消息"><a class="header-anchor" href="#设备发消息"></a>设备发消息</h2>
<h3 id="arp-address-resolution-protocol-地址解析协议"><a class="header-anchor" href="#arp-address-resolution-protocol-地址解析协议"></a>ARP（Address Resolution Protocol）地址解析协议</h3>
<ul>
<li>一个网络设备在分配到<code>IP地址</code>之后，就算是加入到网络里面了。</li>
<li>这时候它要发消息给另一个设备，比如百度，那么需要<code>DNS</code>服务器，将这个域名转换为<code>IP地址</code></li>
<li>假设<code>DNS</code>域名服务器并不在同一个局域网里面，那么就需要路由器将这条消息转发到另一个局域网中。</li>
<li>那么，如何找到路由器呢？ 我们在<code>DHCP</code>协议接入时候,确实是有<code>DNS</code>的<code>IP</code>地址，但是知道<code>IP</code>地址，并没有办法进行直接通信</li>
<li>所以,<code>ARP</code>协议的第一步是广播找到路由器或者无线路由器。</li>
<li>用<code>wireshark</code>抓包，很有意思的是，我自己的笔记本隔一阵就会寻找一个特定的<code>IP</code>，发出广播消息，这个包没抓下来。</li>
<li>抓了一个包,呃，<code>MAC</code>全网唯一，就涂掉了</li>
<li>在广播之后就是简单的问答<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/ARP_wireshark.png" alt="ARP_wireshark"></li>
<li>参考链接：
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/28771785" target="_blank" rel="noopener">知乎专栏，图解ARP协议</a></li>
</ol>
</li>
</ul>
<h3 id="nat-network-address-translation-协议"><a class="header-anchor" href="#nat-network-address-translation-协议"></a>NAT（Network Address Translation）协议</h3>
<ul>
<li>通过将内部网络的私有IP地址翻译成全球唯一的公网IP地址，使内部网络可以连接到互联网等外部网络上。</li>
<li><code>NAT</code>可以分为以下几种：
<ul>
<li>静态转换（Static Translation）：一个公网IP对应一个私有IP，并且只有<code>IP</code>转换，不涉及端口</li>
<li>动态转换（Dynamic Translation）：这个介绍得比较少，实际就是说局域网有多个公有IP地址，并不和局域网内部私有IP地址进行一一绑定。而是动态分配</li>
<li>端口多路复用（Port Address Translation,PAT），网络地址端口转换NAPT（Port-Level NAT），<strong><em>这个和上面的是一个吗？应该是一个</em></strong> NAPT不但要转换IP地址，还要进行传输层的端口转换，对外只有一个公网IP，通过端口来区别不同私有IP主机的数据。这种才是最常用的一种</li>
</ul>
</li>
<li>会看到内部局部地址、外部局部地址、内部全局地址、外部全局地址的说法，其实就是源的私有IP地址，目标的私有IP地址，源的公有IP地址和目标的公有IP地址</li>
<li><code>NAT</code>有个映射记录表，对没有相应记录的数据包进行拒绝，提高了网络安全性。这就是说为什么<code>NAT</code>有安全性；对于<code>NAPT</code>来说，<code>NAT</code>转换表里面是“某个网卡私有IP：端口 -&gt; 网关路由器的公有IP：端口”，相当于局域网的设备都共享一个公有IP地址，然后订住网关路由器的一个端口。</li>
<li><code>NAT</code>的弊端是很明显的，降低效率是肯定的，有一些协议不支持<code>NAT</code>。 <strong><em>这一点需要后续持续学习</em></strong></li>
<li>参考链接：
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35548780" target="_blank" rel="noopener">网络地址转换NAT:包含配置命令，看这一篇可能就可以了</a></li>
<li><a href="https://www.zhihu.com/question/31332694" target="_blank" rel="noopener">NAT转换是怎么工作的？知乎问答</a></li>
<li><a href="https://blog.csdn.net/hzhsan/article/details/45038265" target="_blank" rel="noopener">网络地址转换NAT原理</a></li>
<li><a href="https://www.cnblogs.com/syfwhu/p/5229020.html" target="_blank" rel="noopener">网络协议之NAT穿透</a></li>
</ul>
</li>
</ul>
<h3 id="iptables"><a class="header-anchor" href="#iptables"></a>Iptables</h3>
<h4 id="iptables-简述"><a class="header-anchor" href="#iptables-简述"></a>Iptables 简述</h4>
<ul>
<li><code>Iptables</code>的实质是一种防火墙，是基于<code>Netfilter</code>实现的。</li>
<li><code>Netfilter</code>，在<code>Linux</code>內核中的一個軟體框架，用於管理網路封包。不僅具有網路位址轉換（<code>NAT</code>）的功能，也具備封包內容修改、以及封包過濾等防火牆功能。<a href="https://zh.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter维基百科</a>
<ul>
<li><code>Netfilter</code> 框架提供了一些内核的<code>hook</code>，这些协议栈内有包过滤功能的<code>hook</code>，<code>hook</code>也就构成了<code>netfilter</code>框架</li>
<li>程序可以通过注册<code>hook</code>函数来在封装包的关键路径上面进行处理，实现各种规则</li>
<li><code>netfilter</code>组件也称为内核空间（<code>kernelspace</code>），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</li>
<li><code>iptables</code>组件是一种工具，也称为用户空间（<code>userspace</code>），它使插入、修改和除去信息包过滤表中的规则变得容易。<a href="https://www.cnblogs.com/Dicky-Zhang/p/5904429.html" target="_blank" rel="noopener">超级详细的iptable教程文档</a></li>
</ul>
</li>
<li>所以，其实<code>Iptables</code>只是定义了各种规则，是各种规则的集合。真正在干活的其实是<code>netfilter</code>的<code>hook</code></li>
<li><code>Iptables</code>按照功能分为多个Table， 每个Table里面的每一条规则称为<code>Chain</code>。
<ul>
<li>内置的<code>chain</code>是由内置的<code>hook</code>触发的</li>
<li>所以<code>Chain</code>基本和<code>Hook</code>是一一对应的</li>
<li><code>PREROUTING</code>: 由<code>NF_IP_PRE_ROUTING hook</code>触发，负责刚刚到的包，包经过<code>PRETOUTING chain</code>之后，将进行路由判断。</li>
<li><code>INPUT</code>: 由<code>NF_IP_LOCAL_IN hook</code>触发</li>
<li><code>FORWARD</code>: 由<code>NF_IP_FORWARD hook</code>触发</li>
<li><code>OUTPUT</code>: 由<code>NF_IP_LOCAL_OUT hook</code>触发</li>
<li><code>POSTROUTING</code>: 由<code>NF_IP_POST_ROUTING hook</code>触发</li>
</ul>
</li>
</ul>
<h4 id="iptables-tables"><a class="header-anchor" href="#iptables-tables"></a>Iptables Tables</h4>
<ul>
<li><code>Iptables</code>将它的规则组织在表里面，常见的有这几种：<code>NAT, FILTER, MANGLE , RAW &amp; SECURITY</code></li>
<li><code>filter</code>这是最常见的，就是过滤包，起到防火墙的作用</li>
<li><code>NAT</code>就是何修改包的源/目的地址，这里和协议感觉还有一些不一样</li>
<li><code>MANGLE</code>可以修改包的<code>IP头</code>。包括很多参数。</li>
<li><code>RAW</code>这种包，有点类似匿名功能啊，就是不被<code>Iptables</code>知道这个包有通过过.一但使用了<code>RAW</code>表,在某个链上,<code>RAW</code>表处理完后,将跳过<code>NAT</code>表和<code>ip_conntrack</code>处理,即不再做地址转换和数据包的链接跟踪处理了。</li>
<li><code>Security</code>给包打上<code>SELinux</code>标记，没有仔细了解，和<code>Linux</code>的安全机制有关</li>
</ul>
<h4 id="iptables-chain"><a class="header-anchor" href="#iptables-chain"></a>Iptables Chain</h4>
<ul>
<li>并不是每个表里面有每种链，这点很好理解，因为链和表功能不搭，肯定就放不进去了</li>
<li>画表格貌似失败了，只能截屏一张图片，来自参考链接1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/Iptables_table_chain.png" alt="Tables &amp;amp; Chains"></p>
<h4 id="how-packages-be-routed"><a class="header-anchor" href="#how-packages-be-routed"></a>How Packages be routed</h4>
<ul>
<li>
<p>中文文档这里翻译得不是太好。表格还换了个格式，明显原始的更清楚啊</p>
</li>
<li>
<p>一个包会不会触发<code>netfilter</code>里面的<code>hook</code>，取决于好些因素，假设没有被filter表过滤掉的话，那么会按照以下规则触发：</p>
<ul>
<li>收到的、目的是本机的包：<code>PRETOUTING -&gt; INPUT</code></li>
<li>收到的、目的是其他主机的包：<code>PRETOUTING -&gt; FORWARD -&gt; POSTROUTING</code></li>
<li>本地产生的包：<code>OUTPUT -&gt; POSTROUTING</code>,同样会经过<code>PRETOUTING</code> 和 <code>INPUT</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/Iptables_process.png" alt="Iptable"></p>
</li>
<li>
<p>今天做分享时候这块说得不清楚，几张图片结合起来，其实是很清晰的。</p>
</li>
</ul>
<h4 id="iptables-操作"><a class="header-anchor" href="#iptables-操作"></a>Iptables 操作</h4>
<ul>
<li>
<p>netfilter 框架会对设置的每条一条（出向或入向）规则，自动设置它的反向规则，因此我们只需要设 置一个方向的规则即可。</p>
</li>
<li>
<p>命令格式：</p>
<pre><code># Abstract structure of an iptables instruction:
iptables [-t table] command [match pattern] [action]
</code></pre>
</li>
<li>
<p>选项:</p>
<pre><code>-P  --policy        &lt;链名&gt;  定义默认策略
-L  --list          &lt;链名&gt;  查看iptables规则列表 
-A  --append        &lt;链名&gt;  在规则列表的最后增加1条规则 
-I  --insert        &lt;链名&gt;  在指定的位置插入1条规则
-D  --delete        &lt;链名&gt;  从规则列表中删除1条规则
-R  --replace       &lt;链名&gt;  替换规则列表中的某条规则 
-F  --flush         &lt;链名&gt;  删除表中所有规则 
-Z  --zero          &lt;链名&gt;  将表中数据包计数器和流量计数器归零 
-X  --delete-chain  &lt;链名&gt;  删除自定义链 
-v  --verbose       &lt;链名&gt;  与-L他命令一起使用显示更多更详细的信息
</code></pre>
</li>
<li>
<p>执行指令有：<code>ACCEPT、REJECT、DROP、REDIRECT 、MASQUERADE</code>以外，还多出<code>LOG、ULOG、DNAT、RETURN、TOS、SNAT、MIRROR、QUEUE、TTL、MARK</code>等</p>
<pre><code>SNAT - 修改源IP为固定新IP（静态）, SNAT只对离开路由器的包有意义，因此它只用在POSTROUTING chain中

MASQUERADE - 修改源IP为动态新IP（动态获取网络接口 IP）和SNAT一样，MASQUERADE只对POSTROUTING chain有意义，伪装数据包，例如将 源地址修改为路由器地址。因此如果接口的IP地址发送了变化，MASQUERADE规则不受影响，可以正常工作；而对于SNAT就必须重新调整规则。

DNAT - 修改目的IP，必须在做路由决策之前，因此DNAT 适用于PRETOUTING和OUTPUT（本地生成的包）

REDIRECT - DNAT的一个特殊场景将包重定向到本机另一个端口,重定向到路由器的另一个本地端口，适用于PRETOUTING和OUTPUT chain
</code></pre>
</li>
</ul>
<h4 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h4>
<ol>
<li><a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">深入理解IpTables和Netfilter： 这篇比较好，这回的主要参考，里面也有Netfilter几种hook的介绍</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">上一篇参考链接的英文原文</a><br>
3） <a href="http://arthurchiao.art/blog/nat-zh/" target="_blank" rel="noopener">NAT - 网络地址转换</a></li>
</ol>
<h4 id="实际操作配置"><a class="header-anchor" href="#实际操作配置"></a>实际操作配置</h4>
<ul>
<li>实际操作暂时没时间，也有点兴趣缺缺<br>
参考链接：
<ol>
<li><a href="http://www.ttlsa.com/linux/iptables-router-acl/" target="_blank" rel="noopener">iptables作为路由器实现上网和访问控制</a></li>
<li><a href="https://www.cnblogs.com/linuxws/p/10924817.html" target="_blank" rel="noopener">Iptables-linux服务器做路由转发</a></li>
<li><a href="https://blog.csdn.net/beanewself/article/details/77435208?utm_medium=distribute.pc_relevant.none-task-blog-title-3&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">Linux下搭建路由器</a></li>
</ol>
</li>
</ul>
<h3 id="虚拟网络"><a class="header-anchor" href="#虚拟网络"></a>虚拟网络</h3>
<ul>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2020/02/11/K8s-Ingress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2020/02/11/K8s-Ingress/" itemprop="url">K8s Ingress</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-11T10:42:55+08:00">
                2020-02-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ingress"><a class="header-anchor" href="#ingress"></a>Ingress</h2>
<ul>
<li><em>Ingress enables externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting for a Kubernetes cluster.</em></li>
<li>通常情况下，<code>service</code>和<code>pod</code>的<code>IP</code>仅可在集群内部访问。集群外部的请求需要通过负载均衡转发到<code>service</code>在<code>Node</code>上暴露的<code>NodePort</code>上，然后再由<code>kube-proxy</code>将其转发给相关的<code>Pod</code>。而<code>Ingress</code>就是为进入集群的请求提供路由规则的集合</li>
<li>用<code>NodePort</code>来暴露服务的时候， <code>IP</code>可能会漂移，并且，如果服务太多的话，会有混乱，为此引入了<code>ingress</code>，使用<code>hostname</code>来避免这个问题。</li>
<li>可以认为<code>Ingress</code>包含两个组件：<code>ingress controller</code>和<code>ingress</code></li>
<li>参考链接：
<ul>
<li><a href="https://www.kubernetes.org.cn/ingress" target="_blank" rel="noopener">官方文档 名词解释：Ingress</a></li>
</ul>
</li>
</ul>
<h3 id="ingress-controller"><a class="header-anchor" href="#ingress-controller"></a>Ingress Controller</h3>
<ul>
<li>
<p><code>ingress controller</code>目前主要有两种：基于<code>nginx</code>服务的<code>ingress controller</code>和基于<code>traefik</code>的<code>ingress controller</code>。</p>
<ul>
<li><code>traefik</code>的<code>ingress controller</code>，目前支持<code>http</code>和<code>https</code>协议。</li>
<li>而<code>nginx</code>可以支持<code>TCP</code>负载,但是目前<code>k8s</code>仅仅支持<code>HTTP</code>和<code>HTTPS</code></li>
<li>我们产品里面目前使用的也是<code>nginx</code>。</li>
</ul>
</li>
<li>
<p><code>ingress controller</code>会将新加入的<code>Ingress</code>转化成<code>Nginx</code>的配置文件并使之生效</p>
</li>
<li>
<p>通常会单独安装在一个<code>namespace</code>里面，比如<code>nginx-inigress</code>里面。</p>
</li>
<li>
<p>配套会有一些部署，解释如下：</p>
<ul>
<li><code>Deployment</code>:<code>default-http-backend</code>,对应有同名的<code>service</code>.如果外界访问的域名不存在的话，则默认转发到<code>default-http-backend</code>这个<code>service</code>，会返回404</li>
</ul>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.jianshu.com/p/feeea0bbd73e" target="_blank" rel="noopener">从零开始搭建K8s</a></li>
<li><a href="https://www.ilanni.com/?p=14501" target="_blank" rel="noopener">k8s安装与配置ingress(一)</a>: 文档写得真心不错，格式实在太烂了，看得眼睛疼</li>
<li><a href="https://www.cnblogs.com/justmine/p/8991379.html" target="_blank" rel="noopener">详解k8s组件Ingress边缘路由器并落地到微服务 - kubernetes</a></li>
</ul>
</li>
</ul>
<h3 id="ingress-yaml-file"><a class="header-anchor" href="#ingress-yaml-file"></a>Ingress YAML FILE</h3>
<ul>
<li><code>Ingress.yaml</code>里面的信息不可能完全列这里，有以下一些元素和类型</li>
</ul>
<h3 id="ingress-rule"><a class="header-anchor" href="#ingress-rule"></a>Ingress Rule</h3>
<ul>
<li>还有个<code>ingress-rules</code>的yaml文件。里面的内容如下：
<ul>
<li><code>Kind</code>: <code>Ingress</code> 这个<code>rule</code>规则，哪个<code>endPoint</code>进哪个<code>deployment</code></li>
<li>每个<code>Ingress</code>都需要配置<code>rules</code>，目前<code>Kubernetes</code>仅支持<code>http</code>规则。所以最关键的就是<code>rule</code></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2020/01/09/Linux-Command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2020/01/09/Linux-Command/" itemprop="url">Linux Command</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-09T09:43:08+08:00">
                2020-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工作多年，<code>Linux</code>命令是时不时要用到的。每次都是百度之（虽然不是真的用的百度:P），记录在这里，省得每次还得去找</p>
<h2 id="awk"><a class="header-anchor" href="#awk"></a>AWK</h2>
<ul>
<li><a href="https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html" target="_blank" rel="noopener">linux awk命令详解</a></li>
<li><a href="https://www.cnblogs.com/dakewei/p/9848176.html" target="_blank" rel="noopener">使用awk分割字符串并且获取分割后的最后一个字符串</a></li>
</ul>
<h3 id="example"><a class="header-anchor" href="#example"></a>Example</h3>
<p><code>awk</code> 其实是读入一行，进行查找，再进行操作。可以集合<code>SED</code>和<code>GREP</code>的作用。下面用例子来说明问题</p>
<ul>
<li><code>awk -F'-' '{print $1}'</code>
<ul>
<li>用<code>-</code>做分隔符，然后将<code>-</code>分隔之后的第一列数据输出出来。</li>
<li>如果有版本，比如<code>2.0.1-SNAPSHOT</code>,这个语句就可以得到`2.0.``</li>
</ul>
</li>
<li><code>echo &quot;you-me-he&quot; |awk -F '[-]' '{print $NF}'</code>
<ul>
<li>这条命令是用<code>-</code>分隔之后，打印分隔后的最后一个字符，所以输出<code>he</code></li>
</ul>
</li>
</ul>
<h2 id="curl"><a class="header-anchor" href="#curl"></a>CURL</h2>
<ul>
<li>
<p><a href="https://www.cnblogs.com/duhuo/p/5695256.html" target="_blank" rel="noopener">Linux curl命令详解</a></p>
</li>
<li>
<p><code>curl</code>命令作用广泛，可以作为传输工具使用，我们在产品中也经常用来判断一个<code>URL</code>是否可连接</p>
</li>
</ul>
<h3 id="实例"><a class="header-anchor" href="#实例"></a>实例</h3>
<ul>
<li><code>curl -o linux.html http://www.linux.com</code>： 保存网页，在我们的产品中，使用这种形式进行了文件下载</li>
</ul>
<h2 id="判断文件"><a class="header-anchor" href="#判断文件"></a>判断文件</h2>
<ul>
<li><a href="https://www.cnblogs.com/37yan/p/6962563.html" target="_blank" rel="noopener">shell判断文件存在</a></li>
</ul>
<h3 id="实例-v2"><a class="header-anchor" href="#实例-v2"></a>实例</h3>
<ul>
<li>
<p>判断文件存在与否</p>
<p>if [ ! -f “/data/filename” ];then<br>
echo &quot;文件不存在&quot;<br>
else<br>
rm -f /data/filename<br>
fi</p>
</li>
<li>
<p>判断目录存在与否：将<code>-f</code>换成<code>-d</code></p>
</li>
</ul>
<pre><code>if [ -d &quot;/data/&quot; ];then
echo &quot;文件夹存在&quot;
else
echo &quot;文件夹不存在&quot;
fi
</code></pre>
<h2 id="字符串操作"><a class="header-anchor" href="#字符串操作"></a>字符串操作</h2>
<h3 id="字符串连接"><a class="header-anchor" href="#字符串连接"></a>字符串连接</h3>
<ul>
<li>直接写在一起就可以了</li>
</ul>
<h2 id="生成随机密码"><a class="header-anchor" href="#生成随机密码"></a>生成随机密码</h2>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/EasonJim/p/9041957.html" target="_blank" rel="noopener">Linux下生成随机密码</a></li>
</ul>
<h3 id="实例-v3"><a class="header-anchor" href="#实例-v3"></a>实例</h3>
<ul>
<li><code>date +%s |sha256sum |base64 |head -c 32 ;echo</code> 这样的话说是根据当前时间来算的。所以安全性其实很高啊</li>
</ul>
<h2 id="截取字符串的方法"><a class="header-anchor" href="#截取字符串的方法"></a>截取字符串的方法</h2>
<ul>
<li><a href="https://www.jb51.net/article/56563.htm" target="_blank" rel="noopener">Shell脚本8种字符串截取方法总结</a></li>
</ul>
<h3 id="实例-v4"><a class="header-anchor" href="#实例-v4"></a>实例</h3>
<ul>
<li><code>var=http://www.aaa.com/123.htm</code></li>
<li><code>echo ${var#*//}</code>
<ul>
<li><code>#</code> 号是运算符，<code>*//</code> 表示从左边开始删除第一个 <code>//</code> 号及左边的所有字符</li>
<li>所以这样的话会将<code>http://</code>都给删除掉</li>
</ul>
</li>
<li><code>echo ${var##*/}</code>
<ul>
<li><code>##</code>是运算符指最后一个，<code>*/</code>表示<code>/</code>和<code>/</code>左边的所有字符。所以一个<code>#</code>是第一个，两个是最后一个。</li>
<li>这句话会删除最后一个<code>/</code>以及左边的字符， 结果只留下了<code>123.htm</code></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/12/06/各类问题解决/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/12/06/各类问题解决/" itemprop="url">Problems During Working</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T13:53:11+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开个新博客，来记录工作过程中碰到的各种各类的小问题。</p>
<h2 id="windows"><a class="header-anchor" href="#windows"></a>Windows</h2>
<h3 id="端口被占用"><a class="header-anchor" href="#端口被占用"></a>端口被占用</h3>
<ul>
<li><code>netstat -aon|findstr &quot;8081&quot;</code>，查看占用端口<code>8081</code>的进程</li>
<li><code>tasklist|findstr &quot;9088&quot;</code>，查看进程是哪个应用</li>
<li><code>taskkill /T /F /PID 9088</code> 杀死这个进程</li>
</ul>
<h2 id="env"><a class="header-anchor" href="#env"></a>ENV</h2>
<p>这个章节主要是包括编译啊，版本控制啊，IDE啊之类的小问题</p>
<h3 id="soapui"><a class="header-anchor" href="#soapui"></a>SoapUI</h3>
<ul>
<li>工作里面一般用<code>soapUI</code>来发送请求。之前一直发送的是<code>WSDL</code>的，也就是<code>XML</code>格式。</li>
<li>现在流行<code>REST</code>，昨天尝试了一天也没成功啊。OMG 😦</li>
<li>对应于<code>WSDL</code>的是<code>WADL</code>，用于导入<code>HTTP</code>的请求。但是坑爹的是我们代码里面没有。尝试了以下两种方式：
<ul>
<li>从<code>WSDL</code>转换成为<code>WADL</code>也是可行的。有一个小的工具搜索到： <a href="https://sourceforge.net/p/tinywsdl/wiki/wsdl11/" target="_blank" rel="noopener">tinywsdl</a>,但是可能是<code>WADL</code>不是那么流行，需要写代码来转换。</li>
<li>另一种方式要简单直接很多，就是<code>soapUI</code>的<code>import swagger</code>功能，直接右键就能看到。从<code>swagger</code>网站上面也可以导出生成<code>yaml</code>或者<code>json</code>文件。</li>
<li>不幸的是，遇到了这个错误：<a href="https://github.com/SmartBear/readyapi-swagger-plugin/issues/3" target="_blank" rel="noopener"><br>
error on creating project out of swagger spec<br>
</a></li>
<li>完全一致，<code>JSON</code>的格式报版本问题，<code>YAML</code>的格式报<code>null</code></li>
<li>按照上述网页，应该是<code>swagger</code>插件只能支持字符串格式。然鹅，我的文件里面好多不是字符串的。只能最终放弃了。</li>
</ul>
</li>
</ul>
<h3 id="ij"><a class="header-anchor" href="#ij"></a>IJ</h3>
<h4 id="command-too-long-error"><a class="header-anchor" href="#command-too-long-error"></a>command too long error</h4>
<ul>
<li>
<p>今天尝试跑Junit，结果IJ报错，说我命令行太长：</p>
<pre><code>Error running 'xxxxxxx': Command line is too long. Shorten command line for xxxxxxx or also for JUnit default configuration.
</code></pre>
</li>
<li>
<p>解决方法是在Run…的配置里面，有一个<code>shorten command line</code>选项，选成<code>classpath file</code>，这样就可以了。</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.jetbrains.com/idea/2017/10/intellij-idea-2017-3-eap-configurable-command-line-shortener-and-more/" target="_blank" rel="noopener">configurable-command-line-shortener</a></li>
<li><a href="https://stackoverflow.com/questions/47926382/how-to-configure-shorten-command-line-method-for-whole-project-in-intellij/47927544" target="_blank" rel="noopener">how-to-configure-shorten-command-line</a></li>
</ul>
</li>
</ul>
<h4 id="output-path-same"><a class="header-anchor" href="#output-path-same"></a>Output path same</h4>
<ul>
<li>编译<code>scala</code>项目的时候报的错误。意思是输出路径一样。改一下<code>module</code>的输出路径就可以了。奇怪的是，为啥会一样啊。</li>
<li><a href="https://stackoverflow.com/questions/18920334/output-path-is-shared-between-the-same-module-error/21418406#21418406" target="_blank" rel="noopener">output-path-is-shared</a></li>
</ul>
<h4 id="error-failed-to-load-project-configuration-cannot-parse-file-xxx-idea-workspace-xml-parseerror-at-row-col-1-1-message-content-is-not-allowed-in-prolog"><a class="header-anchor" href="#error-failed-to-load-project-configuration-cannot-parse-file-xxx-idea-workspace-xml-parseerror-at-row-col-1-1-message-content-is-not-allowed-in-prolog"></a>Error:Failed to load project configuration: cannot parse file xxx.idea\workspace.xml: ParseError at [row,col]:[1,1] Message: Content is not allowed in prolog.</h4>
<ul>
<li>大致含义就是这个文件坏了按照stackoverflow上面的，先删除这个文件，再点击“ started 'Invalid Caches/Restart&quot; under “File”.”就可以解决问题了</li>
<li><a href="https://stackoverflow.com/questions/29604148/workspace-xml-file-corrupted-error-on-line-1-content-is-not-allowed-in-prolog" target="_blank" rel="noopener">workspace-xml-file-corrupted</a></li>
</ul>
<h3 id="git"><a class="header-anchor" href="#git"></a>GIT</h3>
<h4 id="filename-too-long-error"><a class="header-anchor" href="#filename-too-long-error"></a>filename too long error</h4>
<ul>
<li>改一下<code>GIT</code>的配置就可以了</li>
<li><code>git config --system core.longpaths true</code></li>
<li><a href="https://ourcodeworld.com/articles/read/109/how-to-solve-filename-too-long-error-in-git-powershell-and-github-application-for-windows" target="_blank" rel="noopener">how-to-solve-filename-too-long-error</a></li>
</ul>
<h3 id="vim"><a class="header-anchor" href="#vim"></a>VIM</h3>
<h4 id="全局替换"><a class="header-anchor" href="#全局替换"></a>全局替换</h4>
<ul>
<li><code>:%s/vivian/sky/g</code>: 替换每一行中所有<code>vivian</code> 为<code>sky</code></li>
<li><a href="http://blog.sina.com.cn/s/blog_736f1c59010136ry.html" target="_blank" rel="noopener">vim替换变量</a></li>
</ul>
<h2 id="java"><a class="header-anchor" href="#java"></a>Java</h2>
<h3 id="mock"><a class="header-anchor" href="#mock"></a>Mock</h3>
<h4 id="checked-exception-is-invalid-for-this-method"><a class="header-anchor" href="#checked-exception-is-invalid-for-this-method"></a>Checked exception is invalid for this method!</h4>
<ul>
<li>用<code>thenThrow</code>时候报了这个错误，这个错误的含义其实是调用的函数并没有抛出模拟的这个函数，所以模拟不起来</li>
<li>我自己是因为在<code>scala</code>里面外面包了一层</li>
</ul>
<h2 id="cassandra"><a class="header-anchor" href="#cassandra"></a>Cassandra</h2>
<h3 id="cassandra-was-never-started"><a class="header-anchor" href="#cassandra-was-never-started"></a>Cassandra was never started</h3>
<ul>
<li>这个问题是在解决POD不断重启的问题的过程中遇到的。</li>
<li>问题的根源其实就是Cassandra的版本被替换了，用户和密码也换掉了</li>
<li>参考链接：
<ul>
<li>
<p><a href="https://docs.datastax.com/en/developer/java-driver/3.1/manual/custom_codecs/extras/" target="_blank" rel="noopener">time codecs</a></p>
<p>2020-03-26 10:39:08,280+0100 [vent Dispatcher] WARN  [com.datastax.driver.core.CodecRegistry] Ignoring codec InstantCodec [timestamp &lt;-&gt; java.time.Instant] because it collides with previously registered codec InstantCodec [timestamp &lt;-&gt; java.time.Instant]</p>
</li>
</ul>
</li>
</ul>
<h2 id="docker"><a class="header-anchor" href="#docker"></a>Docker</h2>
<h3 id="docker-login"><a class="header-anchor" href="#docker-login"></a>docker login</h3>
<pre><code> $ docker login XXXXX
    Authenticating with existing credentials...
    Stored credentials invalid or expired
    Error: Cannot perform an interactive login from a non TTY device
</code></pre>
<ul>
<li>这是由于密码更换了之后原有密码不对造成的问题。加个<code>-u username -p password</code>就能够解决</li>
<li>也可以设置环境变量来解决<code>DOCKER_USERNAME DOCKER_PASSWORD</code></li>
<li>参考链接： <a href="https://community.atlassian.com/t5/Bitbucket-questions/Piplenes-docker-login-can-not-perform-an-interactive-login-from/qaq-p/595736" target="_blank" rel="noopener">docker login can not perform an interactive login from a non TTY</a></li>
</ul>
<h3 id="docker-demon"><a class="header-anchor" href="#docker-demon"></a>docker demon</h3>
<pre><code>error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.25/version: open //./pipe/docker_engine: The system cannot find the file
specified. In the default daemon configuration on Windows, the docker client must be run elevated to connect. This error may also indicate that the docker daemon is not running.
</code></pre>
<ul>
<li><code>&quot;C:\Program Files\Docker\Docker\DockerCli.exe&quot; -SwitchDaemo</code></li>
<li>并没有研究原理啦</li>
<li>参考链接：<a href="https://stackoverflow.com/questions/40459280/docker-cannot-start-on-windows" target="_blank" rel="noopener">docker cannot start on windows</a></li>
</ul>
<h3 id="docker-image-没有名字"><a class="header-anchor" href="#docker-image-没有名字"></a>docker image 没有名字</h3>
<ul>
<li>
<p><code>docker build</code>出来的<code>image</code>没有名字，需要在命令行指定</p>
<pre><code>docker build -t image_name
</code></pre>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://stackoverflow.com/questions/38986057/how-to-set-image-name-in-dockerfile" target="_blank" rel="noopener">how-to-set-image-name-in-dockerfile</a></li>
</ul>
</li>
</ul>
<h3 id="docker-for-desktop-安装"><a class="header-anchor" href="#docker-for-desktop-安装"></a>docker for desktop 安装</h3>
<ul>
<li>安装时候一直提示<code>dockerd</code>文件被<code>windows event log</code>占用了。但是按照各种<code>windows</code>的方法都找不到，最后从<code>gitbash</code>强制删除掉文件再安装就好了。</li>
</ul>
<h3 id="docker-for-desktop-如何安装dashboard"><a class="header-anchor" href="#docker-for-desktop-如何安装dashboard"></a>docker for desktop 如何安装Dashboard</h3>
<ul>
<li>安装<code>k8s</code>的<code>dashboard</code>：
<ul>
<li>使用“docker for desktop“的时候，这个<code>dashboard</code>貌似不是事先装好的。印象不深刻了。需要装一下：</li>
<li><code>kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</code></li>
<li><code>kubectl proxy</code> 再将<code>proxy</code>给弄出来，就可以访问了。</li>
<li>如下图：<br>
<img src="https://user-images.githubusercontent.com/5803001/34945022-c57b369a-fa3c-11e7-85e7-83f716d10705.png" alt></li>
<li>参考链接登录：
<ul>
<li><a href="https://segmentfault.com/a/1190000012850396" target="_blank" rel="noopener">config登录方式</a></li>
<li><a href="https://www.cnblogs.com/guigujun/p/8366530.html" target="_blank" rel="noopener">config登录方式2</a></li>
<li><a href="https://www.cnblogs.com/jackyfei/p/10180465.html" target="_blank" rel="noopener">token方式登录</a></li>
</ul>
</li>
<li>获取token的命令：<code>kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')</code></li>
</ul>
</li>
</ul>
<h2 id="k8s"><a class="header-anchor" href="#k8s"></a>K8S</h2>
<h3 id="连不上k8s"><a class="header-anchor" href="#连不上k8s"></a>连不上K8S</h3>
<pre><code>$ kubectl cluster-info
Kubernetes master is running at ...
To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)
</code></pre>
<ul>
<li>参考链接：<a href="https://blog.csdn.net/baobaoxiannv/article/details/83818426" target="_blank" rel="noopener">csdn博客一篇</a></li>
<li>其实就是<code>kube</code>的<code>config</code>文件: <code>~/.kube/config</code> 文件过时了。里面的<code>certification</code>需要更新。从<code>kube server</code>上面把<code>config</code>拿下来替换一些本地的就好了。</li>
</ul>
<h3 id="k8s的nodeport-service出错"><a class="header-anchor" href="#k8s的nodeport-service出错"></a>K8s的NodePort Service出错</h3>
<h4 id="nodeport-service的nodeport无法访问"><a class="header-anchor" href="#nodeport-service的nodeport无法访问"></a>NodePort Service的NodePort无法访问</h4>
<ul>
<li>在工作中碰到一个问题。<code>NodePort</code>的<code>NodePort</code>无法访问，只有我组开发的一个服务有问题，其他服务都是OK的
<ul>
<li>内部服务使用<code>clusterIP:internalPort</code>访问没有问题</li>
<li>外部机器无法访问</li>
<li>各个机器上面的端口已经完全开好了</li>
<li>只有本机可以使用<code>NodeIP:NodePort</code>访问到服务,也就是<code>deployment</code>起或者<code>pod</code>起的那台机器可以访问服务</li>
<li>只有一套环境有问题，另外一套环境没有问题。有问题的环境上面有<code>kube-proxy</code>服务，而另一套并没在<code>kube-system</code>下面找到<code>kube-proxy</code></li>
</ul>
</li>
<li>先说结论，最后发现是由于在我国抵抗疫情期间，国外友人加了<code>NetworkPolicy</code>导致的，需要在服务的<code>deployment</code>里面加上一个标准位，而添加的网络规则会根据这个标准位来放行或者阻拦<code>traffic</code>
<ul>
<li>使用<code>kubectl get networkpolicy</code>可以看到设置的网络规则，使用<code>describe</code>命令可以看到详细的信息，如下，所以需要加上这个标志位（在deployment的labels里面。）</li>
<li>后续需要进一步学习<code>NetworkPolicy</code>相关知识</li>
</ul>
</li>
</ul>
<pre><code>   Spec:
	PodSelector:     allowTraffic=true
</code></pre>
<ul>
<li>这边来看解决分析过程。
<ul>
<li>由于两套环境上一套是工作的第一反应是两套机器的差异，并且还有一个信息是春节前是工作的，春节后是不工作的。但是由于机器并不是我们自己搭的，只能猜测是环境改变了。</li>
<li><code>kube-proxy</code> 出问题了，因为所有的<code>clusterIP</code>是好的，那么猜测是中间的转发过程出问题了，于是查询看看同一个<code>node</code>上面的<code>kube-proxy</code>的日志，事实上没有任何错误。这边有几个信息，即使在日志里面看到了端口被占用的日志，也并没有什么意义，在测试中，不停地启停<code>service</code>就可能触发这个日志。</li>
<li>在排除掉<code>kube-proxy</code>之后，就怀疑是<code>iptables</code>的错误。参考以下链接，确实在<code>iptables</code>出现问题的时候可能发生类似的错误：</li>
<li>参考链接：<a href="https://stackoverflow.com/questions/46667659/kubernetes-cannot-access-nodeport-from-other-machines" target="_blank" rel="noopener">k8s的nodeport无法从其他机器访问</a></li>
<li><a href="https://www.myf5.net/post/2343.htm" target="_blank" rel="noopener">NodePort Service的请求未被分发到各个node的排错</a></li>
<li>于是看了一整天的<code>iptables</code>。由于时间紧迫，并未能看到全貌，后续会新开一篇博客来补。事实上，<code>NodePort</code>服务类型只比<code>ClusterIP</code>类型多两条规则</li>
<li>而在整个<code>ipTables</code>里面，可以很清晰地看到整个链路，一直转到<code>endpoint</code>上面。尽管里面也有上述两个链接中提到的<code>Docker</code>相关的规则，却不是在<code>filter</code>过滤表里面。而是在<code>NAT</code>转发表里，所以按照链路来看，从<code>NodePort</code>进去的请求最后确实转发到了<code>endpoint</code>，并没有到<code>Docker</code>里面。事实上，我尝试在<code>IpTables</code>里面加上了链接中的路由，并未生效。</li>
<li>在研究了一天<code>iptables</code>之后，转到了比较生硬一些却可能更有效的办法：</li>
<li>研究其他服务的代码改动。事实上，肯定是有加入这个标志位的，但是由于和一些类似格式的改动在一起，没看出来</li>
<li>查询从哪一天开始出现了问题。万幸已经知道2月6号的包有问题，年前是好的，中间并未差几天。在数次装包卸载之后发现了时间点。再比较两个包的差异，发现了这个<code>NetworkPolicy</code>的增加</li>
</ul>
</li>
</ul>
<h3 id="pod不断重启"><a class="header-anchor" href="#pod不断重启"></a>POD不断重启</h3>
<ul>
<li>仍旧是上一个问题相同的项目出的问题，这个项目怎么这么难呢 😦</li>
<li>由于这个项目是架构在<code>OSGI</code>上面的，进入<code>OSGI</code>发现有一个<code>AKKA</code>相关的<code>bundle</code>的状态不对，不是<code>ACTIVE</code>，而是<code>RESOLVED</code>，第一反应就是我在前一周做的改动不对。因为在前一天我进行了<code>IPV6</code>的改动，但是并不工作。</li>
<li>于是回滚掉<code>IPV6</code>的改动，回滚掉再之前的<code>AKKA service</code>相关的改动，然并卵，这时候也已经周五晚上12点了。只能作罢</li>
</ul>
<h4 id="为何没能够更早的发现问题"><a class="header-anchor" href="#为何没能够更早的发现问题"></a>为何没能够更早的发现问题</h4>
<ul>
<li><code>POD</code>并不是起不来，然后一直重启，而是在起来一段时间，大约10来分钟的时候会重启，所以一直没有被发现。这点是一个改变，后续需要注意。</li>
<li>测试方法的问题，我们在测试的时候因为只是功能发布之后的回归测试，仅仅测试了端口是不是通。这样很快，但是也就测不到问题了。</li>
</ul>
<h4 id="周末调试"><a class="header-anchor" href="#周末调试"></a>周末调试</h4>
<ul>
<li>周末的时候和上一次调试不一样的是，上来就选择了各种装包和对比，最后发现3月9号的包是OK的，而12号的就挂了</li>
<li>在这之间，最大的改动是<code>Cassandra</code>改动，这个改动直接导致了10号11号的包都是坏的。</li>
<li>然后再一次，我们这个项目又被国外友人给漏掉了</li>
<li>但是奇特的是，按照对比之后，我们应该连不上<code>Cassandra</code>了才对，但是实际上，整个<code>pod</code>起来的时候，<code>OSGI</code>的服务会最先检查数据库安装，并未报错，所以这点很是奇特。在解决问题后发现，应该是创了不同的<code>user</code>，<code>super user</code>仍旧是存在的。所以连接并未报错，但是实际的服务却不对了</li>
<li>对比包无效之后，回到最初的问题上面，为什么<code>POD</code>会自动重启</li>
</ul>
<h4 id="k8s-pod重启"><a class="header-anchor" href="#k8s-pod重启"></a>K8S POD重启</h4>
<ul>
<li>
<p>这里有一个命令： <code>kubectl get events</code>,使用这个命令可以看到<code>POD</code>的事务：</p>
<pre><code>$ kubectl get events
LAST SEEN   TYPE   REASON  OBJECT      MESSAGE
&lt;unknown&gt;   Normal    Scheduled                         pod/xxxxxxx Successfully assigned &lt;namespace&gt;/xxxxxx to node-10-41-82-7
</code></pre>
</li>
<li>
<p>这样可以清晰看到<code>pod</code>由于连不上<code>AKKA</code>服务的<code>2929</code>端口而重启，也就是<code>liveness</code>条件不满足了，所以<code>K8S</code>就欢快地把<code>POD</code>杀掉了。</p>
</li>
<li>
<p>然后还有一个有用的命令是<code>kubectl logs -p &lt;podName&gt;</code>这条命令可以帮助我们看到被杀的前一个pod的日志，毕竟我们看的当时，前一个pod可能已经被干掉了</p>
</li>
</ul>
<h4 id="分析"><a class="header-anchor" href="#分析"></a>分析</h4>
<ul>
<li>
<p>问题有二，<code>2929</code>端口起不来，<code>OSGI bundle</code>起不来，也可能最后都是<code>Cassandra</code>导致的。在解决之后，事实证明后一个问题确实是，前一个并不是。</p>
</li>
<li>
<p>而且两者都和<code>AKKA</code>服务相关，但是<code>AKKA</code>和<code>Cassandra</code>有个毛线相关性。</p>
</li>
<li>
<p>还有个坑爹的是，打开<code>DEBUG</code>级别的日志，可以看到除了<code>AKKA</code>相关的<code>bundle</code>之外，几乎所有的<code>bundle</code>都在报以下的错误。这个错误在<code>bundle</code>之间调用服务时候的就会出现。</p>
</li>
<li>
<p>由于<code>AKKA</code>的<code>bundle</code>是最后一个，在启动时候会check其他所有<code>bundle</code>的状态，所以这家伙就挂了。将<code>check</code>去掉就起来了。所以看起来，这个<code>bundle</code>起不来，更多的是和以下的<code>OSGI</code>错误相关，而不是和<code>AKKA</code>有关联</p>
</li>
<li>
<p>但是在从上回的<code>network Policy</code>问题以来，只有一滴滴helm chart的改动。java代码压根没动过。依赖也没改过。</p>
</li>
<li>
<p><code>OSGI</code>你报什么错啊，吐血了我！</p>
<pre><code> org.osgi.framework.ServiceException: org.apache.felix.scr.impl.manager.SingleComponentManager.getService() returned a null service object
at org.eclipse.osgi.internal.serviceregistry.ServiceUse.getService(ServiceUse.java:163) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:468) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:467) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.getService(BundleContextImpl.java:594) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.apache.felix.scr.impl.helper.BindMethod.getServiceObject(BindMethod.java:572) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.getServiceObject(DependencyManager.java:2012) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager$SingleDynamicCustomizer.prebind(DependencyManager.java:852) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.prebind(DependencyManager.java:1439) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.collectDependencies(AbstractComponentManager.java:1119) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:807) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:777) [na:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse$1.run(ServiceUse.java:141) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at java.security.AccessController.doPrivileged(Native Method) [na:1.8.0_212]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse.getService(ServiceUse.java:139) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:468) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:467) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.getService(BundleContextImpl.java:594) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.apache.felix.scr.impl.helper.BindMethod.getServiceObject(BindMethod.java:572) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.getServiceObject(DependencyManager.java:2012) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager$SingleDynamicCustomizer.prebind(DependencyManager.java:852) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.prebind(DependencyManager.java:1439) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.collectDependencies(AbstractComponentManager.java:1119) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:807) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:777) [na:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse$1.run(ServiceUse.java:141) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at java.security.AccessController.doPrivileged(Native Method) [na:1.8.0_212]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse.getService(ServiceUse.java:139) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:468) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:467) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.getService(BundleContextImpl.java:594) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.apache.felix.scr.impl.helper.BindMethod.getServiceObject(BindMethod.java:572) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.getServiceObject(DependencyManager.java:2012) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager$SingleDynamicCustomizer.prebind(DependencyManager.java:852) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.prebind(DependencyManager.java:1439) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.collectDependencies(AbstractComponentManager.java:1119) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:807) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.activateInternal(AbstractComponentManager.java:850) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.enable(AbstractComponentManager.java:419) [na:na]
at org.apache.felix.scr.impl.config.ConfigurableComponentHolder.enableComponents(ConfigurableComponentHolder.java:376) [na:na]
at org.apache.felix.scr.impl.BundleComponentActivator.initialize(BundleComponentActivator.java:172) [na:na]
at org.apache.felix.scr.impl.BundleComponentActivator.&lt;init&gt;(BundleComponentActivator.java:120) [na:na]
at org.apache.felix.scr.impl.Activator.loadComponents(Activator.java:258) [na:na]
at org.apache.felix.scr.impl.Activator.access$000(Activator.java:45) [na:na]
at org.apache.felix.scr.impl.Activator$ScrExtension.start(Activator.java:185) [na:na]
at org.apache.felix.utils.extender.AbstractExtender.createExtension(AbstractExtender.java:259) [na:na]
at org.apache.felix.utils.extender.AbstractExtender.modifiedBundle(AbstractExtender.java:232) [na:na]
at org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:479) [karaf-org.osgi.core.jar:na]
at org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:414) [karaf-org.osgi.core.jar:na]
at org.osgi.util.tracker.AbstractTracked.track(AbstractTracked.java:232) [karaf-org.osgi.core.jar:na]
at org.osgi.util.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:443) [karaf-org.osgi.core.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.dispatchEvent(BundleContextImpl.java:847) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEventPrivileged(Framework.java:1568) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1504) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1499) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:391) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.AbstractBundle.resume(AbstractBundle.java:390) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.resumeBundle(Framework.java:1176) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:559) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:544) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.incFWSL(StartLevelManager.java:457) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.doSetStartLevel(StartLevelManager.java:243) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.dispatchEvent(StartLevelManager.java:438) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.dispatchEvent(StartLevelManager.java:1) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:340) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
</code></pre>
</li>
</ul>
<h4 id="进展"><a class="header-anchor" href="#进展"></a>进展</h4>
<ul>
<li>在做了<code>workaround</code>： 替换<code>liveness</code>的端口，这样<code>pod</code>不会在不断重启；将<code>bundle</code>的<code>check</code>去掉，这样<code>bundle</code>看着都<code>active</code>了。之后，开始重新<code>debug</code></li>
<li><code>OSGI</code>的错误在打开<code>apache</code>的<code>debug log</code>之后仍旧无从下手，这个错误在3月9号的包中也是没有的，只能回到对比包的老路上面来。</li>
<li>那么第一个仍旧是<code>Cassandra</code>的改动。这回在将这个改动加上之后，<code>OSGI</code>的错误没有了。然鹅，为什么数据库的改动会影响到<code>OSGI</code>的状态，并不知道。这个问题只能到此为止啦。</li>
<li>所以使用<code>karaf</code>仍旧是很<code>heavy</code>的，在最新的版本中已经将之移除了。</li>
</ul>
<h4 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h4>
<ul>
<li>在问题的解决过程中，查询了很多，有一些比较有用的链接如下：
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/51455551" target="_blank" rel="noopener">k8s为何杀死我的Pod</a></li>
<li><a href="https://blog.csdn.net/yzh_1346983557/article/details/89216494?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">CPU分配过少导致POD重启</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/11/15/TLS-Certification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/11/15/TLS-Certification/" itemprop="url">TLS - Certificate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T16:03:26+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail.png" target="_blank" rel="noopener">SSL/TLS for dummies part 3 – Understanding Certificate Authority</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a></li>
<li><a href="https://www.cnblogs.com/lhj588/p/6069873.html" target="_blank" rel="noopener">https SSL主流数字证书都有哪些格式？</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html" target="_blank" rel="noopener">Java Secure Socket Extension</a></li>
</ul>
<h2 id="为啥需要证书"><a class="header-anchor" href="#为啥需要证书"></a>为啥需要证书</h2>
<ul>
<li>我们知道在<code>TLS</code>传输中需要使用不对称加密算法，在其中有公钥，私钥。公钥用来给客户端给自己发消息，私钥用来解密收到的消息。</li>
<li>但是以下场景中即使是不对称加密也是不安全的：
<ul>
<li>小明用浏览器往百度发了个消息，然后百度将自己的公钥返回给小明。</li>
<li>攻击者在中途截住了这个公钥，并且替换为自己的公钥发给了小明。</li>
<li>小明并不清楚，用这个假的公钥加密了自己的私钥，并且发给了百度。</li>
<li>攻击者于是拥有了小明的私钥，接着用上一次截获的百度的公钥加密小明的私钥，返回给百度。</li>
<li>于是百度会认为<code>TLS</code>通道已经建立。接下来小明和百度之间的所有消息都会被攻击者得知。</li>
<li>这时候就需要证书了。证书颁发机构由<code>X.509</code>标准指定，以确保数据的完整性。证书的目的就是保证数据的完整性。啧，听上去好厉害！</li>
</ul>
</li>
</ul>
<h2 id="证书的使用过程"><a class="header-anchor" href="#证书的使用过程"></a>证书的使用过程</h2>
<ol>
<li>首先是百度作为一个服务器，向<code>CA</code>申请签名证书。这里用<code>Digicert</code>作为<code>CA</code>。<code>github</code>就是<code>Digicert</code>做的根认证 😃</li>
<li>那么<code>CA</code>会为百度创建一个证书，里面包含一些信息，比如例如服务器名称，服务器的公钥等。</li>
<li><code>Digicert</code>将创建数据（这里的数据，其实就是证书）的哈希值，并使用自己的私钥对其进行加密</li>
<li>浏览器和操作系统自带<code>Digicert</code>等权威机构的公钥。</li>
<li>当浏览器收到签名证书时，它将使用<code>Digicert</code>的公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列</li>
<li>如果两个哈希值匹配，则签名验证成功并且证书是可信的</li>
<li>现在浏览器可以使用证书中指定的百度的公钥继续进行身份验证过程。</li>
</ol>
<ul>
<li>也就是说在客户端和服务器端交换公钥秘钥的过程中，加入了<code>CA</code>的签名认证，这样保证客户端可以信任收到的公钥确实是服务器端的公钥，而不是攻击者的公钥。</li>
<li>其实就是证书服务器对自己的一份数据，这个数据包含证书服务器的信息和百度的公钥信息，还有其他一些信息。然后先进行hash运算，再用自己的私钥进行加密，然后和数据一起发给浏览器。</li>
<li>这样，浏览器对数据进行hash运算，然后，用证书服务器的公钥解密，再跟算出来的hash值进行对比。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/Certificate.png" alt="来自参考链接1"></p>
<ul>
<li>为了绕过上述机制，攻击者需要使签名来匹配数据，为了做到这点，他需要拥有<code>Digicert</code>的私钥（最初为example.com签发并签署了证书），所以攻击者此时会失败，因为他可以创建的唯一签名来自他的私钥，我们的浏览器并不会信任这一点。浏览器的证书存储区也不会有攻击者的公钥，并且在发生此类攻击时会显示证书异常，如下所示。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_not_safe.png" alt></p>
<h2 id="root-ca-和-中间ca"><a class="header-anchor" href="#root-ca-和-中间ca"></a>Root CA 和 中间CA</h2>
<p><code>CA</code>的一堆看得想吐啊。😦</p>
<h3 id="root-ca"><a class="header-anchor" href="#root-ca"></a>Root CA</h3>
<ul>
<li>参考链接
<ul>
<li><a href="https://support.dnsimple.com/articles/what-is-certificate-authority/" target="_blank" rel="noopener">什么是CA</a></li>
<li><a href="https://support.dnsimple.com/articles/what-is-ssl-root-certificate/" target="_blank" rel="noopener">什么是Root CA</a></li>
</ul>
</li>
<li>有两种解释，一个是被信任的机构，另一个是这个机构颁发出来的证书</li>
<li>比如<code>Digicert</code>就是一个<code>root CA</code></li>
</ul>
<h3 id="中间ca"><a class="header-anchor" href="#中间ca"></a>中间CA</h3>
<ul>
<li>简单地说，将鸡蛋放在一个篮子里面是很危险的， <code>CA</code>也是一样，如果所有的证书都由<code>root CA</code>签发，那么<code>root CA</code>的工作量繁重，而且一旦<code>root CA</code>被攻击了，后果实在不可想象</li>
<li>于是出现了中间的<code>CA</code>服务器，也就是被根<code>CA</code>服务器信任的中间服务器</li>
<li><em><code>intermediate CA</code>是<code>Root CA</code>信任的证书颁发机构。 <code>example.com</code>的证书将由<code>intermediate CA</code>颁发，<code>intermediate CA</code>还将具有将由<code>Root CA</code>签名的证书，并且只有<code>Root CA</code>的详细信息会被存储在浏览器的证书库中。</em></li>
<li>在浏览器里面能看到证书的详细信息。比如以下的这个证书。G2就是一个中间CA。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail.png" alt></p>
<h3 id="证书签名算法"><a class="header-anchor" href="#证书签名算法"></a>证书签名算法</h3>
<ul>
<li>在证书将数据的<code>hash值</code>用自己的私钥进行加密的时候可以选择不同的加密算法.</li>
<li><code>RSA解密加密</code>和<code>RSA签名</code>算法应该有一些差异，这里暂时并不深究。看下图中可以看到，这边签名算法用的是<code>sha256RSA</code>。<code>sha256</code>是哈希算法。</li>
<li>需要知道的是，签名是通过使用<code>intermediate CA</code>的私钥来完成的。并且签名验证由浏览器使用相应的公钥完成的。</li>
<li>数据长度超过其密钥长度，<code>RSA</code>无法加密数据。假设我们使用<code>2048</code>位密钥进行加密，那么证书数据不应超过<code>2048</code>位，也就是<code>255</code>个字节，这并不总是可行的，因为证书包含很多信息。因此，在加密之前，在证书上应用哈希函数（哈希函数又称为散列算法），该函数生成指定长度的唯一随机字符串。下图中就是<code>sha256</code>.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_algorithm.png" alt></p>
<h3 id="证书校验"><a class="header-anchor" href="#证书校验"></a>证书校验</h3>
<ul>
<li>浏览器是有根<code>CA</code>的公钥的，所以浏览器会先用根<code>CA</code>的公钥来验证中间<code>CA</code>的证书</li>
<li>然后就可以信任中间<code>CA</code>的公钥，再用这个公钥来解服务器的证书</li>
<li>然后得到服务器，比如百度的公钥</li>
</ul>
<h3 id="证书格式"><a class="header-anchor" href="#证书格式"></a>证书格式</h3>
<ul>
<li>证书的规范是<code>X.509</code>，有好几个版本。起码到<code>v3</code>,应该也是目前比较常用的一个版本。证书的内容遵循<code>asn.1</code>格式。😂 居然是<code>asn.1</code>的，久违的一个规范了。</li>
<li>最常见的两个工具是<code>Java</code>的<code>Keytool</code>和<code>openssl</code></li>
<li><code>Java</code>的<code>keytool</code>生成的证书格式是<code>JKS</code>格式的证书</li>
<li><code>openssl</code>生成<code>PEM、KEY、CRT</code>格式的证书</li>
<li>还有一些其他格式的证书，比如IBM和微软，都有自己的工具生成的自带证书
<ul>
<li><code>*.DER *.CER Certificate</code> : 这样的证书文件是二进制格式，只含有证书信息，不包含私钥。</li>
<li><code>*.CRT</code>: 这样的文件可以是二进制格式，也可以是文本格式，一般均为文本格式，功能与<code>*.DER/*.CER</code>相同。</li>
<li><code>*.PEM Privacy Enhanced Mail</code>: 一般是文本格式，可以放证书或私钥，或者两者都包含。 <code>*.PEM</code>如果只包含私钥，那一般用<code>*.KEY</code>代替。</li>
<li><code>*.PFX *.P12 Personal Information Exchange</code>是二进制格式，同时含证书和私钥，一般有密码保护</li>
<li><strong>这个博客是不是说得不对啊，证书里面哪里来的私钥，应该都是公钥才对吧</strong></li>
</ul>
</li>
<li><code>—–BEGIN CERTIFICATE—–</code> 用这个开头的，代表这个是证书</li>
<li><code>—–BEGIN RSA PRIVATE KEY—–</code> 这个开头的，说明是一个私钥。</li>
</ul>
<h4 id="证书的详细内容"><a class="header-anchor" href="#证书的详细内容"></a>证书的详细内容</h4>
<ul>
<li>以下是证书规范。看名字能明白其中包含：
<ul>
<li>证书规范的版本信息，比如<code>v3</code></li>
<li>证书序列号，证书序列号在一个<code>CA</code>机构内是唯一的，但不是全局唯一</li>
<li>证书签名算法，这个是上面已经看过了。</li>
<li>证书签发者，是一组<code>DN distributed name</code>，在用<code>openssl</code>等工具输出证书信息的时候，能看到这一栏。</li>
<li>证书有效期</li>
<li>证书里面包含的服务器的名称， 也是一个<code>DN</code>。</li>
<li>证书中包含的服务器的公钥</li>
<li>其他扩展信息：比如证书所携带的域名信息<code>SAN</code></li>
<li>签名：最后是证书签名，这个在上面已经讲过，是有证书服务器使用自己的私钥对数据进行的签名，使用证书内指定的签名算法。格式如下：</li>
</ul>
</li>
</ul>
<pre><code>   Signature = RSA(sha256(Data), IssuerPrivateKey)
</code></pre>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail_content.png" alt="证书的详细信息"></p>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/DN_explaination.jpg" alt="DN详解"></p>
<h4 id="证书查看和格式转换"><a class="header-anchor" href="#证书查看和格式转换"></a>证书查看和格式转换</h4>
<ul>
<li>各个证书的格式之间是可以相互转换的。</li>
<li>以下命令，将<code>JKS</code>格式转换成为<code>PFX</code>格式。事实上，用这条命令可以实现<code>JKS</code>和<code>PFX</code>的相互转换，换一下目标格式和源格式即可。</li>
</ul>
<pre><code>keytool -importkeystore -srckeystore D:\server.jks -destkeystore D:\server.pfx -srcstoretype JKS -deststoretype PKCS12
</code></pre>
<h2 id="java中的实现"><a class="header-anchor" href="#java中的实现"></a>Java中的实现</h2>
<ul>
<li>我们在工作中碰到了错误:</li>
</ul>
<pre><code>javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative names present
</code></pre>
<ul>
<li>
<p>这个错误在现在看来就比较清楚了，是客户端在校验服务器端的证书，并且对证书里面的扩展字段<code>SAN</code>有要求，但是服务器端的证书里面并没有带这个扩展字段，就错了。</p>
</li>
<li>
<p>这部分代码应该在<code>JSSE Java Secure Socket Extension</code>里面。<br>
没有unit test，很难跟代码。先将报错信息记录在这里。报错信息如下：</p>
<pre><code> javax.net.ssl.SSLHandshakeException:  
 java.security.cert.CertificateException: No subject alternative names present
 at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
 at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1964)
 at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:328)
 at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:322)
 at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1614)
 at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
 at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1052)
 at sun.security.ssl.Handshaker.process_record(Handshaker.java:987)
 at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1072)
 at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1385)
 at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1413)
 at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1397)</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/11/15/Maven-Dependency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/11/15/Maven-Dependency/" itemprop="url">Maven Dependency</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T13:43:28+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>maven</code>的<code>dependency</code>咋说呢，项目大了之后就有点复杂，在工作中配到一个由于<code>dependency</code>引入的问题，将一些细节记录在这里。<br>
篇幅不会很长，但是实际问题中应该很有帮助。</p>
<ul>
<li>
<p><code>mvn dependency:tree -Dverbose -Dincludes=&lt;groupID&gt;:&lt;artifiactID&gt;</code><br>
这条命令可以比较相近地打印出需要知道的包的情况。</p>
</li>
<li>
<p>在一个<code>pom</code>文件里面，同层次的排在前面的会被优先采用，而后面的一个会被忽略。<br>
比如， <code>A depend on C 0.1</code>, <code>B depend on C 0.2</code>，在<code>pom</code>里面写的时候，<code>A</code>在<code>B</code>前面，那么最终<code>C 0.1</code>会成为整个项目使用的版本</p>
</li>
<li>
<p>像上面这种情况，如果想使用<code>C 0.2</code>，那么有一个方法是在<code>A</code>的依赖加入的时候，使用<code>exclusions</code>字段将对<code>C</code>的依赖排除掉。</p>
</li>
<li>
<p>有的时候一个项目里面的相对底层的lib库，可能会被各种上层调用，比如打印log的，访问数据库的，那么更容易出现各种版本冲突，事实上，到最后没有办法来理出来，犹如一团乱麻。那么一个简单的方式就是，在顶层项目的<code>pom</code>文件里面，使用<code>dependencymanagement</code>来指定一个范围和版本号。这种实在是一招破万军。</p>
</li>
<li>
<p>使用第一条命令之后打印出来的<code>log</code>里面有</p>
</li>
<li>
<p>以下代表是<code>dependencymanagement</code>在起作用</p>
<pre><code>- version managed from 0.17; omitted for duplicate)
</code></pre>
</li>
<li>
<p>以下代表是版本冲突了</p>
<pre><code>omitted for conflict with 0.17
</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/11/08/TLS相关知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/11/08/TLS相关知识/" itemprop="url">TLS - Operation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T14:47:48+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tls和oauth"><a class="header-anchor" href="#tls和oauth"></a>TLS和OAuth</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/8378664/does-an-oauth-2-client-really-need-tls" target="_blank" rel="noopener">does-an-oauth-2-client-really-need-tls</a>： 我自己有点搞不清楚这些的关系，这边有一个解释很是清晰，看了就明白了
<ul>
<li><em>3.1.2.1.  Endpoint Request Confidentiality If a redirection request will result in the transmission of an authorization code or access token over an open network (between the resource owner’s user-agent and the client), the client SHOULD require the use of a transport-layer security mechanism.</em> 这个是<code>Oauth</code>官方文档里面的一段话。</li>
<li>上面一段的意思应该是这样的：一个第三方认证的请求在传输<code>authorization code</code>或者<code>access token</code>的时候应当在传输层使用安全机制。这里的安全机制就是指<code>TLS</code>协议。</li>
</ul>
</li>
</ul>
<h2 id="tls版本"><a class="header-anchor" href="#tls版本"></a>TLS版本</h2>
<ul>
<li><code>SSL3.0</code> 和 <code>TLS1.0</code> 是一个东西。嗯，微软干的。微软虽然是一个伟大的公司，但是这个干得不好，相当不好，至少我本人觉得不好。实在是除了增加大家的混淆以外，没有任何意义。嘛，我们自己的产品也经常干这种事情。通常呢，是因为自己认为发生了跨时代的改变，希望让别人也明白。</li>
<li>目前最流行的版本是<code>TLS1.2</code>，最新的版本是<code>TLS1.3</code>。</li>
<li><code>java8</code>中默认的是<code>TLS1.2</code>版本。<code>java11</code>里面支持的是<code>TLS1.3</code></li>
<li>各种<code>web</code>应用服务器的配置文件里面都可以配置支持或者不支持的版本。比如<code>tomcat</code>提供了参数:<code>sslEnabledProtocols</code></li>
</ul>
<h3 id="如何发现我的浏览器使用的tls版本"><a class="header-anchor" href="#如何发现我的浏览器使用的tls版本"></a>如何发现我的浏览器使用的TLS版本</h3>
<ul>
<li>因为要测试<code>tomcat</code>里面配置的参数是否生效，所以第一反应就是我咋知道呢。后来经同事提点，其实用<code>openssl</code>就可以了</li>
<li>在浏览器的配置中能看到， 比如IE, <code>File</code>-&gt;<code>Properties</code>, 在<code>Connection</code>一栏就能看到。</li>
<li>参考链接：
<ul>
<li><a href="https://www.thesslstore.com/blog/google-chrome-72-deprecates-support-for-tls-1-0-tls-1-1/" target="_blank" rel="noopener">chrome如何配置和查看</a></li>
<li><a href="https://security.stackexchange.com/questions/19096/how-to-determine-if-a-browser-is-using-an-ssl-or-tls-connection/169418" target="_blank" rel="noopener">如何查看website的TLS版本</a></li>
</ul>
</li>
</ul>
<h3 id="如何测试tls连接"><a class="header-anchor" href="#如何测试tls连接"></a>如何测试TLS连接</h3>
<ul>
<li>这个是刚需啊刚需。使用<code>openssl</code>肯定也是可以的。这回使用的是<code>curl</code>命令。</li>
<li><code>curl help</code>一下可以看到，使用参数就可以指定<code>TLS</code>版本，还是很好用的。<br>
😦 我觉得自己有时候是很奇怪的人啊，下回要把实际使用的命令写在这里。╭(╯^╰)╮</li>
</ul>
<h2 id="tls双向握手"><a class="header-anchor" href="#tls双向握手"></a>TLS双向握手</h2>
<h3 id="keystore和truststore"><a class="header-anchor" href="#keystore和truststore"></a>KeyStore和TrustStore</h3>
<ul>
<li><code>keystore</code>和<code>truststore</code>从其文件格式来看其实是一个东西，都是<code>.jks</code>文件，只是为了方便管理将其分开</li>
<li><code>keystore</code>中一般保存的是服务器端的私钥，用来加解密或者为别人做签名。存储服务器端的公钥和私钥。</li>
<li><code>truststore</code>中保存的是一些可信任的证书，主要是<code>java</code>在代码中访问某个<code>https</code>的时候对被访问者进行认证的，以确保其实可信任的。一般为公钥<br>
<code>truststore</code>里面存储的是服务器的信任密钥存储库，存<code>CA</code>公钥，也会有人在里面存储客户端的证书集合。</li>
<li>应该在不同的协议中都有可能碰到，不仅仅是<code>HTTPS</code>，在网上搜索过程中有<code>LDAP</code>也用到的。</li>
</ul>
<h3 id="jetty-tls-configuration"><a class="header-anchor" href="#jetty-tls-configuration"></a>Jetty TLS Configuration</h3>
<ul>
<li><code>keystore</code> 里面存储的是<code>key-pair</code>和<code>certificate</code></li>
<li>对于<code>Jetty</code>来说，<code>jetty.xml</code>只支持<code>keystore</code>，而不支持<code>*.crt</code>的格式</li>
<li>项目中碰到了只提供<code>*.crt</code>文件的情况，那么需要自己产生<code>keystore</code>，再将证书导入</li>
</ul>
<h3 id="keytool"><a class="header-anchor" href="#keytool"></a>Keytool</h3>
<ul>
<li>
<p><code>keytool</code>是<code>java</code>默认带的工具。通常生成<code>.jks</code>格式的文件。称为<code>keystore</code></p>
</li>
<li>
<p><code>keystore</code>文件里面可以带<code>key-pair</code>，也可以是证书</p>
</li>
<li>
<p>以下命令是生成一个名为<code>keystore.jks</code>的<code>keystore</code>,并将证书<code>jetty.crt</code>导入到这个文件里面。同时指定了密码，并且在过程中不需要屏幕交互。<code>-trustcacerts</code>的含义是信任该证书</p>
<pre><code>/opt/jdk/jre/bin/keytool -import -trustcacerts -file jetty.crt -keystore keystore.jks -alias jetty  -storepass changeit -noprompt
</code></pre>
</li>
<li>
<p>这条命令可以将上一条命令中导入的证书打印输出进行检验</p>
<pre><code>/opt/jdk/jre/bin/keytool -list -v -keystore keystore.jks
</code></pre>
</li>
</ul>
<h3 id="openssl"><a class="header-anchor" href="#openssl"></a>openssl</h3>
<h3 id="交互流程"><a class="header-anchor" href="#交互流程"></a>交互流程</h3>
<ul>
<li>
<p>双向握手的时候客户端实际会发4次<code>client hello</code>消息，如下图<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/3-times%20handshake.PNG" alt="双向握手流程图"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/entire_handshake_senario.png" alt="wireshark里面对应的消息流"></p>
</li>
<li>
<p>主要是按照参考链接里面最后一篇来学习的</p>
</li>
<li>
<p>TLS握手分为以下几个步骤：</p>
<pre><code>客户端发送Hello报文
服务器接收Hello报文
共享证书和服务器密钥交换
更改密码规范
加密握手
</code></pre>
</li>
<li>
<p><code>admin</code>权限打开<code>wireshark</code>，选择对应网卡，然后抓包，就可以看到文章里面的图片上显示的命令了。</p>
</li>
<li>
<p><code>TLS</code>本身是一层协议并且它的底层叫做记录协议(<code>Record protocol</code>)。<code>TLS</code>到底在哪一层，大家理解不一样，但是在<code>TCP</code>和<code>HTTP</code>之间，或者<code>HTTP</code>上比较合适。从<code>dump</code>来看，<code>HTTP</code>链接在TLS握手之前已经是建立好了。</p>
</li>
<li>
<p>记录的格式：</p>
<pre><code>HH V1:V2 L1:L2 data
</code></pre>
<ul>
<li><code>HH</code>是信息分类 change_cipher_spec（20），alert（21），handshake（22）和application_data（23）。所以<code>client hello</code>和<code>server hello</code>都是22</li>
<li><code>V1:V2</code>是协议版本，这个有点不理解。我看<code>TLS1.2</code>就是<code>0x0303</code></li>
<li><code>L1:L2</code>是数据长度。<strong><em>我有点不明白，为啥都要带<code>：</code>，看版本信息，并没有：</em></strong></li>
</ul>
</li>
</ul>
<h4 id="客户端发送hello报文"><a class="header-anchor" href="#客户端发送hello报文"></a>客户端发送Hello报文</h4>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Client_Hello.png" alt="自己截的发往Github的消息"></p>
<ul>
<li>在上面的图片里面我没有<code>follow HTTP Stream</code>，看起来就有点奇怪，客户端Hello都在上面了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Detail_Info_in_Client_Hello.png" alt="详细的helo报文信息"></p>
<ul>
<li>
<p>在<code>secure socket layers</code>里面能看到具体信息，客户端会先说，我要用这个版本的TLS，我支持这些密码套件</p>
</li>
<li>
<p>关于<code>sessionId</code>，中文翻译的文档有点不太对。实际的意思是，如果是第一次访问一个网站，当然是个空， 但是如果不是第一次，并且在expireation的时间里面，就会是有值的。</p>
</li>
<li>
<p>这个在之前看<code>oauth</code>的时候看到过。服务器会存储<code>sessionId</code>以及其他信息。在<code>sessionId</code>存在的情况下，并不会进行一个完整的交互</p>
</li>
<li>
<p>密码套件里面包括使用的协议，交换秘钥时候的加密算法，证书用的加密算法，还有传输数据时候的加密算法。前两者一般是不对称的，最后一个一般是对称加密算法。还是解释一下：</p>
<pre><code>Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
协议_秘钥交换算法_签名验证算法_批量加密算法(AES_128_GCM)_消息验证代码
</code></pre>
</li>
<li>
<p>在<code>TLS1.2</code>里面还可以使用压缩算法。1.3的版本里面已经去除了。因为压缩是有漏洞可以被攻击</p>
</li>
<li>
<p>扩展的部分是附属信息，暂时不多了解</p>
</li>
</ul>
<h4 id="服务端发送hello报文"><a class="header-anchor" href="#服务端发送hello报文"></a>服务端发送Hello报文</h4>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Server_Hello.png" alt="服务端hello消息"></p>
<ul>
<li>这里可以看到<code>TLS</code>里面的记录协议层，还有握手协议层。但是从图片看起来，握手协议在记录协议里面。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Details_Info_Server_Hello.png" alt="服务端hello消息详解"></p>
<ul>
<li>上边的两张图片应该都是第二次时候的，明显比第一次连接时候要少交互。服务器端hello的时候就直接开始使用上几次的证书秘钥进行消息验证了。</li>
<li>服务器端也有随机数，类似的，一共32字节，前面4个字节也是时间，后面的是真正的随机数。</li>
<li><code>session ticket</code>客户端的章节里面已经阐述了<code>session Id</code>的用处。当大访问客户，互联网用户时候，那么在服务器端存储所有的<code>session</code>信息显然是不合理的。所有引入了这个<code>session ticket</code>，将所有的信息用服务器端的私钥加密之后存贮在客户端。客户端hello消息里面可以看到这个字段，在扩展消息里面</li>
</ul>
<h4 id="服务端发送证书和秘钥"><a class="header-anchor" href="#服务端发送证书和秘钥"></a>服务端发送证书和秘钥</h4>
<ul>
<li>接下来服务器会将服务器的证书等信息发给客户端：可以看到里面有两条<code>secure layer</code>的消息。第二条<code>secure layer</code>信息里面又有两条记录信息，一条是秘钥交换，一条是hello done的消息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/server_certificate_key_finished.png" alt="服务器端证书信息概览"></p>
<ul>
<li>在详细信息里面，能看到证书和秘钥的信息<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/server_certificate_key_finished_details.png" alt="服务器端证书信息详细"></li>
</ul>
<h4 id="客户端发送证书和秘钥"><a class="header-anchor" href="#客户端发送证书和秘钥"></a>客户端发送证书和秘钥</h4>
<ul>
<li>
<p><code>Github</code>使用的是D-H算法，客户端必须获取服务器端的公钥才能计算自己的公钥，算法细节后续在算法博客里面学习。</p>
</li>
<li>
<p>客户端计算出自己的公钥，用服务器端的公钥来加密，然后发给服务器端，服务器端会用自己的私钥来解密。</p>
</li>
<li>
<p>客户证书消息里面里面也有三条记录消息。最后一条是测试数据，在测试数据里面包含以下内容</p>
<pre><code>verify_data = PRF(master_secret, &quot;client finished&quot;, MD5(handshake_messages) + SHA-1(handshake_messages) )
</code></pre>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/client_certificate_key_tested_msg.png" alt="客户证书消息"></p>
<h4 id="服务器端发送finish消息"><a class="header-anchor" href="#服务器端发送finish消息"></a>服务器端发送finish消息</h4>
<ul>
<li>服务器端在收到客户端的公钥之后，会发送一条类似的消息，整个握手过程就结束了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/server_answer_verify_msg.png" alt="服务器端加密验证消息"></p>
<h4 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h4>
<ul>
<li>这边的参考链接好多还没有细看，是写这篇博客过程中找到的，后面需要再进一步学习啊</li>
<li><a href="https://www.jianshu.com/p/a3a25c6627ee" target="_blank" rel="noopener">Https详解+wireshark抓包演示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/86304211" target="_blank" rel="noopener">HTTPS抓包了解TLS握手流程</a></li>
<li><a href="https://crypto.stackexchange.com/questions/34754/what-does-the-tls-1-2-client-finished-message-contain/34792" target="_blank" rel="noopener">What does the TLS 1.2 client finished message contain?<br>
</a></li>
<li><a href="https://blog.csdn.net/mrpre/category_9270159.html" target="_blank" rel="noopener">SSL/TLS协议详解<br>
</a></li>
</ul>
<h2 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h2>
<ul>
<li><a href="https://www.cnblogs.com/gsls200808/p/4500246.html" target="_blank" rel="noopener">KeyStore和TrustStore</a></li>
<li><a href="https://xz.aliyun.com/t/2530" target="_blank" rel="noopener">TLS 协议详解</a></li>
<li><a href="https://stackoverflow.com/questions/19236628/jetty-9-setting-up-the-most-basic-ssl-https" target="_blank" rel="noopener">jetty-9-setting-up-the-most-basic-ssl-https</a></li>
<li><a href="https://wiki.eclipse.org/Jetty/Howto/Configure_SSL#Loading_Keys_and_Certificates_via_PKCS12" target="_blank" rel="noopener">Jetty/Howto/Configure SSL</a></li>
<li><a href="https://knowledge.digicert.com/solution/SO15252.html" target="_blank" rel="noopener">Import a certificate into a Jetty Java HTTP Servlet Web Server</a></li>
<li><a href="https://www.eclipse.org/jetty/documentation/current/configuring-ssl.html#loading-keys-and-certificates" target="_blank" rel="noopener">loading-keys-and-certificates</a></li>
<li><a href="https://www.wst.space/ssl-part-4-tls-handshake-protocol/" target="_blank" rel="noopener">tls-handshake-protocol</a></li>
<li><a href="https://xz.aliyun.com/t/2531" target="_blank" rel="noopener">TLS握手，上篇文档的翻译</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/10/11/K8s-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/10/11/K8s-Service/" itemprop="url">K8s Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-11T16:40:09+08:00">
                2019-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Service的概念有点多，内容，单独拎出来做一篇。</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://www.kubernetes.org.cn/kubernetes-services" target="_blank" rel="noopener">名词解释 Services</a></li>
<li><a href="https://segmentfault.com/a/1190000019376912" target="_blank" rel="noopener">Kubernetes Service详解</a></li>
<li><a href="https://segmentfault.com/a/1190000022118019?utm_source=sf-related" target="_blank" rel="noopener">一文了解 Kubernetes 中的服务发现</a></li>
</ul>
<h2 id="为什么需要service"><a class="header-anchor" href="#为什么需要service"></a>为什么需要service</h2>
<p>按照参考链接2里面的解释，倒是很容易理解。<code>POD</code>可以起很多个，是实体，还一会有一会没的。<br>
而<code>service</code>是暴露服务的，这么说，应该只有一个<code>service</code>才对吧。瞅着确实如此啊。</p>
<h2 id="services"><a class="header-anchor" href="#services"></a>Services</h2>
<p><code>service</code>是<code>K8s</code>里面一个非常重要的概念。类型比较多。K8s中文文档里面的名词解释还是比较清楚的，并且给出了为什么需要<code>service</code>，<code>service</code>和<code>pod</code>有什么区别</p>
<ul>
<li>
<p><code>Kubernete Service</code> 是一个定义了一组<code>Pod</code>的策略的抽象，我们也有时候叫做宏观服务。这些被服务标记的<code>Pod</code>都是（一般）通过<code>label Selector</code>决定的（下面我们会讲到我们为什么需要一个没有<code>label selector</code>的服务）</p>
</li>
<li>
<p>A Kubernetes service is a named load balancer that proxies traffic to one or more containers.</p>
</li>
<li>
<p>The proxy works even if the containers are on different nodes. Services proxy communicate within the cluster and rarely expose ports to an outside interface.When you launch a service it looks like you cannot connect using curl or netcat unless you start it as part of Kubernetes. The recommended approach is to have a LoadBalancer service to handle external communications.<br>
<strong>好吧，这段话基本没看懂，暂时就不管它了。service不仅仅是load balancer吧，难道每一种service都是load balancer的一种体现吗？</strong></p>
</li>
<li>
<p>Kubernetes Services are an abstract that defines a policy and approach on how to access a set of Pods. The set of Pods accessed via a Service is based on a Label Selector.</p>
</li>
<li>
<p>Service有很多种，包括<code>targetPort</code>，经常用到的，还有：<code>Cluster IP</code>， <code>NodePort</code> ，<code>External IPs</code>， <code>Load Balancer</code>之类</p>
<ul>
<li>Cluster IP的解释： Cluster IP is the default approach when creating a Kubernetes Service. The service is allocated an internal IP that other components can use to access the pods.</li>
</ul>
<p><strong>cluster IP是默认的service的类型。这种service会暴露一个internal IP，来供给系统中其他的service来访问这堆pod提供的服务，所以通常也会有port的隐射.</strong></p>
<ul>
<li>
<p>Target Port的解释：Target ports allows us to separate the port the service is available on from the port the application is listening on. TargetPort is the Port which the application is configured to listen on. Port is how the application will be accessed from the outside.<br>
<strong>这回比较清楚了，service其实是将POD提供的服务转出来，port是开在service上面，这样其他的service访问这个service的时候就是用这个port，而target port是对应到POD的应用上面的。比如我们自己产品的北向端口的POD，提供的服务开在8080上面，yaml文件里面起的service的port也是8080，其实也可以改成其他的</strong></p>
</li>
<li>
<p>NodePort的解释：the NodePort exposes the service on each Node’s IP via the defined static port. No matter which Node within the cluster is accessed, the service will be reachable based on the port number defined.<br>
<strong>就是<code>get Nodes</code>的命令出来的Node吧。<code>get Nodes</code>命令给出的是<code>hostname</code>，我们自己的环境里面，<code>hostname</code>一般定义格式是<code>node-10-2xx-1xx-xxx</code>,后面这个就是node的IP。这些node实际上是虚拟机。或者是实体机，现在应该都是虚拟的node。比如可以在openstack的node集群上面搭建k8s的服务</strong></p>
</li>
</ul>
<ul>
<li>External IPs的解释：给定master Node的一个IP。然后The service is now bound to the IP address and Port 80 of the master node</li>
<li>Load Balancer的解释：cloud Provider都是有自己的load Balancer的。如果没有的话，可以dynamically allocate IP addresses to LoadBalancer type services.When a service requests a Load Balancer, the provider will allocate one from the 10.10.0.0/26 range defined in the configuration.这个是确定的范围吗</li>
<li>结合上面的，我觉得都需要啊。</li>
</ul>
</li>
</ul>
<h2 id="暴露service的命令"><a class="header-anchor" href="#暴露service的命令"></a>暴露service的命令</h2>
<ul>
<li><code>kubectl expose deployment first-deployment --port=80 --type=NodePort</code>
<ul>
<li>
<p>将资源暴露为新的Kubernetes Service。</p>
</li>
<li>
<p>expose后面的资源有很多种，包括：pod（po），service（svc），replication controller（rc），deployment（deploy），replica set（rs）</p>
</li>
<li>
<p>A Kubernetes service deployment has, at least, two parts. A replication controller and a service. 稍微有点理解了。一个service部署的时候一般有两个yaml文件</p>
</li>
<li>
<p><code>first-deployment</code>是deployment的名字</p>
</li>
<li>
<p>port 是内部的端口</p>
</li>
<li>
<p>–target-port是外部访问的端口</p>
</li>
<li>
<p>完整语法为：</p>
</li>
</ul>
</li>
</ul>
<pre><code>expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type]
</code></pre>
<h3 id="yaml文件"><a class="header-anchor" href="#yaml文件"></a>yaml文件</h3>
<ul>
<li>参考链接二中的yaml文件的例子如下：</li>
</ul>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: gowebsvc
spec:
  selector:
    app: goweb
  ports:
  - name: default
    protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
</code></pre>
<ul>
<li><code>selector</code>指定了是哪个pod，因为pod可能有很多，所以这里用的是pod的tag <code>app: goweb</code>，就是说，这个service是暴露所有这个tag的pod的功能的</li>
</ul>
<h2 id="请求转发"><a class="header-anchor" href="#请求转发"></a>请求转发</h2>
<ul>
<li><code>K8S service</code>其实做到了一定的负载均衡，但是是一个简单的轮询。工作在连接层面，其实就是<code>Iptable</code>里面来实现的。</li>
<li>所以同一个连接里面的请求都会进到同一个<code>POD</code>里面去。因为对于高层的<code>HTTP</code>或者<code>Cookie</code>之类的是无法感知到的。</li>
</ul>
<h3 id="service在iptables"><a class="header-anchor" href="#service在iptables"></a>Service在Iptables</h3>
<p><code>cluster ip</code>类似VIP,从这个名字来说，应该是认为一组pod就是一个<code>cluster</code>，确实也可以如此认为。既然是类似<code>VIP</code>，那么就可以被认为是<code>load banlancer</code>，那么就有策略的问题了。<br>
使用以下命令，可以查看<code>clusterIP 10.106.202.0</code>的转发策略</p>
<pre><code>iptables-save | grep 10.106.202.0
</code></pre>
<p>当一条<code>request</code>发到某个<code>service</code>的<code>cluster ip + port</code>上面时，会经过两次数据链转发（这里的数据链，指的是<code>iptables</code>里面的数据转发规则），第一次数据链转发时候会进行load的分配。<br>
第一条转发链如下.<code>KUBE-SVC-SEG6BTF25PWEPDFT</code>转发链将request均分到4个pod上面。</p>
<pre><code> -A KUBE-SERVICES ! -s 10.100.0.0/16 -d 10.254.52.228/32 -p tcp -m comment --comment &quot;eda2-gear-enixjac02/gowebsvc: cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.25000000000 -j KUBE-SEP-5ZXTVLEM4DKNW7T2
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-EBFXI7VOCPDT2QU5
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-C3PKSXKMO2M43SPF
 -A KUBE-SVC-SEG6BTF25PWEPDFT -j KUBE-SEP-2GQCCNJGO65Z5MFS
</code></pre>
<p>第二次转发的时候，会对目的地做<code>DNAT</code>，反正做了这个<code>DNAT</code>，然后就<code>DNAT</code>到了<code>endpoint</code>上面。</p>
<p><code>KUBE-MARK-MASQ</code>规则如下，<code>MARK</code>会将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则</p>
<pre><code>-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000
</code></pre>
<p><em>比照上面的规则，可以看出<code>KUBE-SEP-5ZXTVLEM4DKNW7T2</code>这条规则对请求的目的地址作了<code>DNAT</code>到<code>10.244.1.15:8000</code>，这正是<code>goweb</code>POD组中<code>goweb-55c487ccd7-5t2l2</code>这个pod的ip地址</em></p>
<pre><code>[root@master-1 ~]# iptables-save | grep  &quot;A KUBE-SEP-5ZXTVLEM4DKNW7T2&quot; 
-A KUBE-SEP-5ZXTVLEM4DKNW7T2 -s 10.244.1.15/32 -j KUBE-MARK-MASQ
-A KUBE-SEP-5ZXTVLEM4DKNW7T2 -p tcp -m tcp -j DNAT --to-destination 10.244.1.15:8000
</code></pre>
<p><code>NodePort</code>类型的服务会比<code>clusterIp</code>多两条，如下：</p>
<pre><code>-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;eda2-gear-enixjac02/gowebsvc:&quot; -m tcp --dport 31827 -j KUBE-MARK-MASQ
-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;eda2-gear-enixjac02/gowebsvc:&quot; -m tcp --dport 31827 -j KUBE-SVC-7NDHFS7EDAQWBVTB
</code></pre>
<p>相对应的，<code>LoadBalancer</code>类型的服务会再多出两条来</p>
<h3 id="endpoint"><a class="header-anchor" href="#endpoint"></a>endpoint</h3>
<ul>
<li>
<p>在<code>service</code>创建的时候，<code>kube-proxy</code>组件（每个k8s服务器都会有的组件）会自动创建同名的<code>endpoint</code>对象。</p>
</li>
<li>
<p>动态地跟踪匹配<code>selector</code>的一组<code>pod</code>当前<code>ip</code>（<code>pod</code>的<code>ip</code>在<code>pod</code>的<code>yaml</code>文件里面可以知道，名字就是<code>podIP</code>）及端口，并生成相应的<code>iptables KUBE-SVC-xxx</code>规则</p>
</li>
<li>
<p><code>service</code>是用了<code>endpoint</code>来对pod进行动态的跟踪的。一个<code>pod</code>的IP发生变化的时候，<code>endpoint</code>和<code>KUBE-SVC-XXX</code>规则会相应变化</p>
</li>
<li>
<p><code>endpoint</code>是<code>k8s</code>的另一个对象，生成一个<code>service</code>的时候，会相对应生成一个<code>endpoint</code>.</p>
<pre><code>$ kubectl get ep -n sallyslove xxxxxxx-mml
NAME         ENDPOINTS                           AGE
xxxxxx-mml  192.168.15.102:8111,192.168.15.102:8010   1h
</code></pre>
</li>
</ul>
<h3 id="请求代理的三种方式"><a class="header-anchor" href="#请求代理的三种方式"></a>请求代理的三种方式</h3>
<p>全文参考链接二里面有三种方式。由于网络基础较差，先记录在这里：</p>
<ul>
<li><code>Userspace</code>模式：这种模式完全依靠<code>kube-proxy</code>来，<em><code>Userspace</code>模式的代理转发主要依靠<code>kube-proxy</code>实现，工作在用户态。所以，转发效率不高</em></li>
<li><code>iptables</code>模式: 也就是上面稍加解释的方法，是目前的默认模式。</li>
</ul>
<p><em>与userspace模式最大的不同点在于，kube-proxy只动态地维护iptables，而转发完全靠iptables实现。由于iptables工作在内核态，不用在用户态与内核态切换，所以相比userspace模式更高效也更可靠。但是每个服务都会生成若干条iptables规则，大型集群iptables规则数会非常多，造成性能下降也不易排查问题。</em></p>
<ul>
<li><code>ipvs</code>模式: 在<code>v1.9</code>版本以后，服务新增了<code>ipvs</code>转发方式.</li>
</ul>
<p><em><code>ipvs</code>同样工作在内核态，而且底层转发是依靠<code>hash表</code>实现，所以性能比<code>iptables</code>还要好的多，同步新规则也比<code>iptables</code>快。同时，负载均衡的方式除了简单rr还有多种选择，所以很适合在大型集群使用。而缺点就是带来了额外的配置维护操作。</em></p>
<h3 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/u011563903/article/details/86692694" target="_blank" rel="noopener">K8S kube-proxy iptables 原理分析</a></li>
</ul>
</li>
</ul>
<h2 id="服务发现"><a class="header-anchor" href="#服务发现"></a>服务发现</h2>
<p>先区分一下上面的请求转发和这里的服务发现。<br>
请求的话通常是端口号+地址就行啦。服务发现要能够发现这个service才行。就是如何让另一个service知道这个service的ip或者hostname，或者让k8s外的客户知道某个service的ip和端口</p>
<h3 id="内部服务发现"><a class="header-anchor" href="#内部服务发现"></a>内部服务发现</h3>
<p>内部服务发现有两种方式：环境变量和DNS</p>
<h4 id="dns方式"><a class="header-anchor" href="#dns方式"></a>DNS方式</h4>
<ul>
<li>
<p>在<code>k8s</code>系统有个<code>namespace</code>为<code>kube-system</code></p>
<pre><code>$ kubectl get svc --namespace=kube-system
NAME TYPE CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE
kube-dns                        ClusterIP   10.254.0.10      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   32d
</code></pre>
</li>
<li>
<p><code>Core DNS</code>是<code>K8S</code>的原生应用，<code>Core DNS</code>会监测服务的创建，每当有新的服务创建，这个服务就会给新的服务创建<code>hostname</code>和<code>IP</code>的对应关系</p>
</li>
<li>
<p><code>clusterIp</code>处于一个叫做<code>K8S</code>的<code>service network</code>的虚拟网络里面，但是这个虚拟网络非常奇怪，因为它没有路由，所以发到<code>clusterIP</code>的请求会被转发到默认的路由上面，然后再发到节点上面，节点的网关上面也没有这个<code>IP</code>的信息，只能将它转发到自己的默认网关上， 在这个过程中，经过了节点的内核</p>
</li>
<li>
<p>而正是经过内核的时候，触发了内核框架<code>netfilter</code>的<code>hook</code>，也就是触发了<code>Iptable</code>的规则，上述的规则开始生效，将请求转发到了目标的<code>POD IP</code>上面。</p>
</li>
<li>
<p>下图也是网络上面的，但是一时找不到出处了。非常清晰</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Docker/from_clusterIp_to_podIp.png" alt="from_clusterIp_to_podIp"></p>
<h3 id="外部服务发现"><a class="header-anchor" href="#外部服务发现"></a>外部服务发现</h3>
<p>外部服务发现，顾名思义，就是k8s服务器以外来发现某个service提供的服务</p>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/chris-cp/p/6724057.html" target="_blank" rel="noopener">k8s实战之Service</a></li>
</ul>
</li>
</ul>
<h4 id="nodeport"><a class="header-anchor" href="#nodeport"></a>NodePort</h4>
<ul>
<li><code>nodePort</code> 和 <code>node</code>是一对，首先要理解一下<code>node</code>的概念。这边的<code>node</code>相当于是<code>VM</code>。</li>
<li>就是这样的，我有一套硬件，然后我在上边搭虚拟环境，比如<code>openstack</code>，<code>openstack</code>会先搭出一堆<code>node</code>来，然后再在这堆<code>node</code>上边装<code>k8s</code>,建<code>namespace</code>，每个<code>namespace</code>里面再建<code>pod</code>啊之类的。</li>
<li>所以可以理解成<code>VM</code>，那么这个<code>IP</code>是可以访问到的。</li>
<li><em><code>NodePort</code>是类型为<code>NodePort</code>的<code>Service</code>，<code>k8s</code>除了会分配给<code>NodePort</code>一个内部的虚拟<code>IP</code>，另外会在每一个<code>Node</code>上暴露端口<code>NodePort</code>，外部网络可以通过[NodeIP]:[NodePort]访问到服务。</em></li>
<li>需要注意的是，<code>NodePort</code>会在每个<code>node</code>上面注册自己。所以这个<code>NodeIP</code>可以是<code>cluster</code>的每个<code>node</code>。<em>该方式把服务暴露在每个<code>Node</code>主机<code>IP</code>的特定端口上,同一个服务在所有<code>Node</code>上端口是相同的，并自动生成相应的路由转发到<code>ClusterIP</code></em>。所以<code>NodePort</code>的<code>service</code>也是有<code>cluster IP</code>的。</li>
</ul>
<h4 id="loadbalancer"><a class="header-anchor" href="#loadbalancer"></a>LoadBalancer</h4>
<ul>
<li><code>LoadBalancer</code>是类型为<code>LoadBalancer</code>的<code>Service</code>，它是建立在<code>NodePort Service</code>集群基础上的，<code>k8s</code>会分配给<code>LoadBalancer Service</code>一个内部的<code>虚拟IP</code>，并且暴露<code>NodePort</code>。除此之外，<code>k8s</code>请求底层云平台创建一个负载均衡器，将每个<code>Node</code>作为后端，负载均衡器将转发请求到<code>[NodeIP]:[NodePort]</code></li>
</ul>
<h3 id="debug"><a class="header-anchor" href="#debug"></a>Debug</h3>
<ul>
<li>
<p>参考链接：</p>
<ol>
<li><a href="https://www.dazhuanlan.com/2019/10/22/5daee17b80349/?__cf_chl_jschl_tk__=16d0ed9e8a1801a665c5cdb4282507c30bcd27ab-1600843391-0-ASKK6HvcorRj55xKYNub3llJlynYT3Ck6rsxc9p0BGVng5Z6DYb6gVnF8uOlab94C_NFIteNMJTp1hSirK9JU3ni1KKQ9vuAEyn0u1nF-pZfx9l00TNt5THYNhcHGra5DcBwL5A0zHqsgDP9_xTvXWYgbW-9WzAzEiORNZ0Celtm1eYp_bZQZb6fXC0IxcVVacuNjkyQFYb6-llsgW00Lc_z0uWBJN43uoxONoZjDX7A1Yysc49r2PvArVKdYkuuw6u_sv7_VFv64dhBYw6XEG0l66FKwmdaArkp67FHPae-6wXyCSYV0WJYrk1xJk_ttw" target="_blank" rel="noopener">k8s iptables 规则查看</a></li>
<li><a href="https://myf5.net/post/2343.htm" target="_blank" rel="noopener">nodeport下访问请求未被分发到所有node的排错</a></li>
<li><a href="https://www.opensourcerers.org/2016/05/27/how-to-trace-iptables-in-rhel7-centos7/" target="_blank" rel="noopener">How to trace IPTables in RHEL7 / CENTOS7</a></li>
</ol>
</li>
<li>
<p>持久化 <code>Iptable</code>的规则，需要在<code>/ete/system/</code>下面修改文件</p>
</li>
<li>
<p>命令：</p>
<pre><code>Load the (IPv4) netfilter log kernel module
modprobe nf_log_ipv4

Enable logging for the IPv4 (AF Family 2)
sysctl net.netfilter.nf_log.2=nf_log_ipv4

restart rsyslogd
systemctl restart rsyslog

follow 32741 port
iptables -t raw -j TRACE -p tcp --dport 32741 -I PREROUTING 1
iptables -t raw -j TRACE -p tcp --dport 32741 -I OUTPUT 1
</code></pre>
</li>
<li>
<p>查看 <code>/var/log/messages</code> 中的追踪记录</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/hexo_blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/hexo_blog/page/4/">4</a><a class="extend next" rel="next" href="/hexo_blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lynn Shen</p>
              <p class="site-description motion-element" itemprop="description">35岁开始的博客，有点晚哦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/hexo_blog/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/hexo_blog/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/hexo_blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/hexo_blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/hexo_blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
        <script src="https://billts.site/js/gitment.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
