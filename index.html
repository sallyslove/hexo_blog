<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/hexo_blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/hexo_blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/hexo_blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/hexo_blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="35岁开始的博客，有点晚哦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo_blog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sallyslove.github.io/hexo_blog/">





  <title>跬步</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo_blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo_blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/hexo_blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo_blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2020/01/09/Linux-Command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2020/01/09/Linux-Command/" itemprop="url">Linux Command</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-09T09:43:08+08:00">
                2020-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工作多年，<code>Linux</code>命令是时不时要用到的。每次都是百度之（虽然不是真的用的百度:P），记录在这里，省得每次还得去找</p>
<h2 id="awk"><a class="header-anchor" href="#awk"></a>AWK</h2>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<p>-<a href="https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html" target="_blank" rel="noopener">linux awk命令详解</a></p>
<ul>
<li><a href="https://www.cnblogs.com/dakewei/p/9848176.html" target="_blank" rel="noopener">使用awk分割字符串并且获取分割后的最后一个字符串</a></li>
</ul>
<h3 id="实例"><a class="header-anchor" href="#实例"></a>实例</h3>
<p><code>awk</code> 其实是读入一行，进行查找，再进行操作。可以集合<code>SED</code>和<code>GREP</code>的作用。下面用例子来说明问题</p>
<ul>
<li><code>awk -F'-' '{print $1}'</code>
<ul>
<li>用<code>-</code>做分隔符，然后将<code>-</code>分隔之后的第一列数据输出出来。</li>
<li>如果有版本，比如<code>2.0.1-SNAPSHOT</code>,这个语句就可以得到`2.0.``</li>
</ul>
</li>
<li><code>echo &quot;you-me-he&quot; |awk -F '[-]' '{print $NF}'</code>
<ul>
<li>这条命令是用<code>-</code>分隔之后，打印分隔后的最后一个字符，所以输出<code>he</code></li>
</ul>
</li>
</ul>
<h2 id="sed"><a class="header-anchor" href="#sed"></a>SED</h2>
<h3 id="实例-v2"><a class="header-anchor" href="#实例-v2"></a>实例</h3>
<h2 id="截取字符串的方法"><a class="header-anchor" href="#截取字符串的方法"></a>截取字符串的方法</h2>
<h3 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h3>
<p>-<a href="https://www.jb51.net/article/56563.htm" target="_blank" rel="noopener">Shell脚本8种字符串截取方法总结</a></p>
<h3 id="实例-v3"><a class="header-anchor" href="#实例-v3"></a>实例</h3>
<ul>
<li><code>var=http://www.aaa.com/123.htm</code></li>
<li><code>echo ${var#*//}</code>
<ul>
<li><code>#</code> 号是运算符，<code>*//</code> 表示从左边开始删除第一个 <code>//</code> 号及左边的所有字符</li>
<li>所以这样的话会将<code>http://</code>都给删除掉</li>
</ul>
</li>
<li><code>echo ${var##*/}</code>
<ul>
<li><code>##</code>是运算符指最后一个，<code>*/</code>表示<code>/</code>和<code>/</code>左边的所有字符。所以一个<code>#</code>是第一个，两个是最后一个。</li>
<li>这句话会删除最后一个<code>/</code>以及左边的字符， 结果只留下了<code>123.htm</code></li>
</ul>
</li>
</ul>
<h2 id="判断文件"><a class="header-anchor" href="#判断文件"></a>判断文件</h2>
<h3 id="参考链接-v3"><a class="header-anchor" href="#参考链接-v3"></a>参考链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/37yan/p/6962563.html" target="_blank" rel="noopener">shell判断文件存在</a></li>
</ul>
<h3 id="实例-v4"><a class="header-anchor" href="#实例-v4"></a>实例</h3>
<ul>
<li>
<p>判断文件存在与否</p>
<p>if [ ! -f “/data/filename” ];then<br>
echo &quot;文件不存在&quot;<br>
else<br>
rm -f /data/filename<br>
fi</p>
</li>
<li>
<p>判断目录存在与否：将<code>-f</code>换成<code>-d</code></p>
</li>
</ul>
<pre><code>if [ -d &quot;/data/&quot; ];then
echo &quot;文件夹存在&quot;
else
echo &quot;文件夹不存在&quot;
fi
</code></pre>
<h2 id="字符串操作"><a class="header-anchor" href="#字符串操作"></a>字符串操作</h2>
<h3 id="字符串连接"><a class="header-anchor" href="#字符串连接"></a>字符串连接</h3>
<ul>
<li>直接写在一起就可以了</li>
</ul>
<h2 id="生成随机密码"><a class="header-anchor" href="#生成随机密码"></a>生成随机密码</h2>
<h3 id="参考链接-v4"><a class="header-anchor" href="#参考链接-v4"></a>参考链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/EasonJim/p/9041957.html" target="_blank" rel="noopener">Linux下生成随机密码</a></li>
</ul>
<h3 id="实例-v5"><a class="header-anchor" href="#实例-v5"></a>实例</h3>
<ul>
<li><code>date +%s |sha256sum |base64 |head -c 32 ;echo</code> 这样的话说是根据当前时间来算的。所以安全性其实很高啊</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/11/15/TLS-Certification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/11/15/TLS-Certification/" itemprop="url">TLS - Certification</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T16:03:26+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail.png" target="_blank" rel="noopener">SSL/TLS for dummies part 3 – Understanding Certificate Authority</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a></li>
<li><a href="https://www.cnblogs.com/lhj588/p/6069873.html" target="_blank" rel="noopener">https SSL主流数字证书都有哪些格式？</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html" target="_blank" rel="noopener">Java Secure Socket Extension</a></li>
</ul>
<h2 id="为啥需要证书"><a class="header-anchor" href="#为啥需要证书"></a>为啥需要证书</h2>
<ul>
<li>我们知道在<code>TLS</code>传输中需要使用不对称加密算法，在其中有公钥，私钥。公钥用来给客户端给自己发消息，私钥用来解密收到的消息。</li>
<li>但是以下场景中即使是不对称加密也是不安全的：
<ul>
<li>小明用浏览器往百度发了个消息，然后百度将自己的公钥返回给小明。</li>
<li>攻击者在中途截住了这个公钥，并且替换为自己的公钥发给了小明。</li>
<li>小明并不清楚，用这个假的公钥加密了自己的私钥，并且发给了百度。</li>
<li>攻击者于是拥有了小明的私钥，接着用上一次截获的百度的公钥加密小明的私钥，返回给百度。</li>
<li>于是百度会认为<code>TLS</code>通道已经建立。接下来小明和百度之间的所有消息都会被攻击者得知。</li>
<li>这时候就需要证书了。证书颁发机构由<code>X.509</code>标准指定，以确保数据的完整性。证书的目的就是保证数据的完整性。啧，听上去好厉害！</li>
</ul>
</li>
</ul>
<h2 id="证书的使用过程"><a class="header-anchor" href="#证书的使用过程"></a>证书的使用过程</h2>
<ol>
<li>首先是百度作为一个服务器，向<code>CA</code>申请签名证书。这里用<code>Digicert</code>作为<code>CA</code>。<code>github</code>就是<code>Digicert</code>做的根认证 😃</li>
<li>那么<code>CA</code>会为百度创建一个证书，里面包含一些信息，比如例如服务器名称，服务器的公钥等。</li>
<li><code>Digicert</code>将创建数据（这里的数据，其实就是证书）的哈希值，并使用自己的私钥对其进行加密</li>
<li>浏览器和操作系统自带<code>Digicert</code>等权威机构的公钥。</li>
<li>当浏览器收到签名证书时，它将使用<code>Digicert</code>的公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列</li>
<li>如果两个哈希值匹配，则签名验证成功并且证书是可信的</li>
<li>现在浏览器可以使用证书中指定的百度的公钥继续进行身份验证过程。</li>
</ol>
<ul>
<li>也就是说在客户端和服务器端交换公钥秘钥的过程中，加入了<code>CA</code>的签名认证，这样保证客户端可以信任收到的公钥确实是服务器端的公钥，而不是攻击者的公钥。</li>
<li>其实就是证书服务器对自己的一份数据，这个数据包含证书服务器的信息和百度的公钥信息，还有其他一些信息。然后先进行hash运算，再用自己的私钥进行加密，然后和数据一起发给浏览器。</li>
<li>这样，浏览器对数据进行hash运算，然后，用证书服务器的公钥解密，再跟算出来的hash值进行对比。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/Certificate.png" alt="来自参考链接1"></p>
<ul>
<li>为了绕过上述机制，攻击者需要使签名来匹配数据，为了做到这点，他需要拥有<code>Digicert</code>的私钥（最初为example.com签发并签署了证书），所以攻击者此时会失败，因为他可以创建的唯一签名来自他的私钥，我们的浏览器并不会信任这一点。浏览器的证书存储区也不会有攻击者的公钥，并且在发生此类攻击时会显示证书异常，如下所示。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_not_safe.png" alt></p>
<h2 id="root-ca-和-中间ca"><a class="header-anchor" href="#root-ca-和-中间ca"></a>Root CA 和 中间CA</h2>
<p><code>CA</code>的一堆看得想吐啊。😦</p>
<h3 id="root-ca"><a class="header-anchor" href="#root-ca"></a>Root CA</h3>
<ul>
<li>参考链接
<ul>
<li><a href="https://support.dnsimple.com/articles/what-is-certificate-authority/" target="_blank" rel="noopener">什么是CA</a></li>
<li><a href="https://support.dnsimple.com/articles/what-is-ssl-root-certificate/" target="_blank" rel="noopener">什么是Root CA</a></li>
</ul>
</li>
<li>有两种解释，一个是被信任的机构，另一个是这个机构颁发出来的证书</li>
<li>比如<code>Digicert</code>就是一个<code>root CA</code></li>
</ul>
<h3 id="中间ca"><a class="header-anchor" href="#中间ca"></a>中间CA</h3>
<ul>
<li>简单地说，将鸡蛋放在一个篮子里面是很危险的， <code>CA</code>也是一样，如果所有的证书都由<code>root CA</code>签发，那么<code>root CA</code>的工作量繁重，而且一旦<code>root CA</code>被攻击了，后果实在不可想象</li>
<li>于是出现了中间的<code>CA</code>服务器，也就是被根<code>CA</code>服务器信任的中间服务器</li>
<li><em><code>intermediate CA</code>是<code>Root CA</code>信任的证书颁发机构。 <code>example.com</code>的证书将由<code>intermediate CA</code>颁发，<code>intermediate CA</code>还将具有将由<code>Root CA</code>签名的证书，并且只有<code>Root CA</code>的详细信息会被存储在浏览器的证书库中。</em></li>
<li>在浏览器里面能看到证书的详细信息。比如以下的这个证书。G2就是一个中间CA。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail.png" alt></p>
<h3 id="证书签名算法"><a class="header-anchor" href="#证书签名算法"></a>证书签名算法</h3>
<ul>
<li>在证书将数据的<code>hash值</code>用自己的私钥进行加密的时候可以选择不同的加密算法.</li>
<li><code>RSA解密加密</code>和<code>RSA签名</code>算法应该有一些差异，这里暂时并不深究。看下图中可以看到，这边签名算法用的是<code>sha256RSA</code>。<code>sha256</code>是哈希算法。</li>
<li>需要知道的是，签名是通过使用<code>intermediate CA</code>的私钥来完成的。并且签名验证由浏览器使用相应的公钥完成的。</li>
<li>数据长度超过其密钥长度，<code>RSA</code>无法加密数据。假设我们使用<code>2048</code>位密钥进行加密，那么证书数据不应超过<code>2048</code>位，也就是<code>255</code>个字节，这并不总是可行的，因为证书包含很多信息。因此，在加密之前，在证书上应用哈希函数（哈希函数又称为散列算法），该函数生成指定长度的唯一随机字符串。下图中就是<code>sha256</code>.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_algorithm.png" alt></p>
<h3 id="证书校验"><a class="header-anchor" href="#证书校验"></a>证书校验</h3>
<ul>
<li>浏览器是有根<code>CA</code>的公钥的，所以浏览器会先用根<code>CA</code>的公钥来验证中间<code>CA</code>的证书</li>
<li>然后就可以信任中间<code>CA</code>的公钥，再用这个公钥来解服务器的证书</li>
<li>然后得到服务器，比如百度的公钥</li>
</ul>
<h3 id="证书格式"><a class="header-anchor" href="#证书格式"></a>证书格式</h3>
<ul>
<li>证书的规范是<code>X.509</code>，有好几个版本。起码到<code>v3</code>,应该也是目前比较常用的一个版本。证书的内容遵循<code>asn.1</code>格式。😂 居然是<code>asn.1</code>的，久违的一个规范了。</li>
<li>最常见的两个工具是<code>Java</code>的<code>Keytool</code>和<code>openssl</code></li>
<li><code>Java</code>的<code>keytool</code>生成的证书格式是<code>JKS</code>格式的证书</li>
<li><code>openssl</code>生成<code>PEM、KEY、CRT</code>格式的证书</li>
<li>还有一些其他格式的证书，比如IBM和微软，都有自己的工具生成的自带证书
<ul>
<li><code>*.DER *.CER Certificate</code> : 这样的证书文件是二进制格式，只含有证书信息，不包含私钥。</li>
<li><code>*.CRT</code>: 这样的文件可以是二进制格式，也可以是文本格式，一般均为文本格式，功能与<code>*.DER/*.CER</code>相同。</li>
<li><code>*.PEM Privacy Enhanced Mail</code>: 一般是文本格式，可以放证书或私钥，或者两者都包含。 <code>*.PEM</code>如果只包含私钥，那一般用<code>*.KEY</code>代替。</li>
<li><code>*.PFX *.P12 Personal Information Exchange</code>是二进制格式，同时含证书和私钥，一般有密码保护</li>
<li><strong>这个博客是不是说得不对啊，证书里面哪里来的私钥，应该都是公钥才对吧</strong></li>
</ul>
</li>
<li><code>—–BEGIN CERTIFICATE—–</code> 用这个开头的，代表这个是证书</li>
<li><code>—–BEGIN RSA PRIVATE KEY—–</code> 这个开头的，说明是一个私钥。</li>
</ul>
<h4 id="证书的详细内容"><a class="header-anchor" href="#证书的详细内容"></a>证书的详细内容</h4>
<ul>
<li>以下是证书规范。看名字能明白其中包含：
<ul>
<li>证书规范的版本信息，比如<code>v3</code></li>
<li>证书序列号，证书序列号在一个<code>CA</code>机构内是唯一的，但不是全局唯一</li>
<li>证书签名算法，这个是上面已经看过了。</li>
<li>证书签发者，是一组<code>DN distributed name</code>，在用<code>openssl</code>等工具输出证书信息的时候，能看到这一栏。</li>
<li>证书有效期</li>
<li>证书里面包含的服务器的名称， 也是一个<code>DN</code>。</li>
<li>证书中包含的服务器的公钥</li>
<li>其他扩展信息：比如证书所携带的域名信息<code>SAN</code></li>
<li>签名：最后是证书签名，这个在上面已经讲过，是有证书服务器使用自己的私钥对数据进行的签名，使用证书内指定的签名算法。格式如下：</li>
</ul>
</li>
</ul>
<pre><code>   Signature = RSA(sha256(Data), IssuerPrivateKey)
</code></pre>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail_content.png" alt="证书的详细信息"></p>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/DN_explaination.jpg" alt="DN详解"></p>
<h4 id="证书查看和格式转换"><a class="header-anchor" href="#证书查看和格式转换"></a>证书查看和格式转换</h4>
<ul>
<li>各个证书的格式之间是可以相互转换的。</li>
<li>以下命令，将<code>JKS</code>格式转换成为<code>PFX</code>格式。事实上，用这条命令可以实现<code>JKS</code>和<code>PFX</code>的相互转换，换一下目标格式和源格式即可。</li>
</ul>
<pre><code>keytool -importkeystore -srckeystore D:\server.jks -destkeystore D:\server.pfx -srcstoretype JKS -deststoretype PKCS12
</code></pre>
<h2 id="java中的实现"><a class="header-anchor" href="#java中的实现"></a>Java中的实现</h2>
<ul>
<li>我们在工作中碰到了错误:</li>
</ul>
<pre><code>javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative names present
</code></pre>
<ul>
<li>
<p>这个错误在现在看来就比较清楚了，是客户端在校验服务器端的证书，并且对证书里面的扩展字段<code>SAN</code>有要求，但是服务器端的证书里面并没有带这个扩展字段，就错了。</p>
</li>
<li>
<p>这部分代码应该在<code>JSSE Java Secure Socket Extension</code>里面。<br>
没有unit test，很难跟代码。先将报错信息记录在这里。报错信息如下：</p>
<pre><code> javax.net.ssl.SSLHandshakeException:  
 java.security.cert.CertificateException: No subject alternative names present
 at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
 at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1964)
 at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:328)
 at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:322)
 at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1614)
 at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
 at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1052)
 at sun.security.ssl.Handshaker.process_record(Handshaker.java:987)
 at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1072)
 at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1385)
 at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1413)
 at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1397)</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/11/15/Maven-Dependency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/11/15/Maven-Dependency/" itemprop="url">Maven Dependency</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T13:43:28+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>maven</code>的<code>dependency</code>咋说呢，项目大了之后就有点复杂，在工作中配到一个由于<code>dependency</code>引入的问题，将一些细节记录在这里。<br>
篇幅不会很长，但是实际问题中应该很有帮助。</p>
<ul>
<li>
<p><code>mvn dependency:tree -Dverbose -Dincludes=&lt;groupID&gt;:&lt;artifiactID&gt;</code><br>
这条命令可以比较相近地打印出需要知道的包的情况。</p>
</li>
<li>
<p>在一个<code>pom</code>文件里面，同层次的排在前面的会被优先采用，而后面的一个会被忽略。<br>
比如， <code>A depend on C 0.1</code>, <code>B depend on C 0.2</code>，在<code>pom</code>里面写的时候，<code>A</code>在<code>B</code>前面，那么最终<code>C 0.1</code>会成为整个项目使用的版本</p>
</li>
<li>
<p>像上面这种情况，如果想使用<code>C 0.2</code>，那么有一个方法是在<code>A</code>的依赖加入的时候，使用<code>exclusions</code>字段将对<code>C</code>的依赖排除掉。</p>
</li>
<li>
<p>有的时候一个项目里面的相对底层的lib库，可能会被各种上层调用，比如打印log的，访问数据库的，那么更容易出现各种版本冲突，事实上，到最后没有办法来理出来，犹如一团乱麻。那么一个简单的方式就是，在顶层项目的<code>pom</code>文件里面，使用<code>dependencymanagement</code>来指定一个范围和版本号。这种实在是一招破万军。</p>
</li>
<li>
<p>使用第一条命令之后打印出来的<code>log</code>里面有</p>
</li>
<li>
<p>以下代表是<code>dependencymanagement</code>在起作用</p>
<pre><code>- version managed from 0.17; omitted for duplicate)
</code></pre>
</li>
<li>
<p>以下代表是版本冲突了</p>
<pre><code>omitted for conflict with 0.17
</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/11/08/TLS相关知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/11/08/TLS相关知识/" itemprop="url">TLS相关知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T14:47:48+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tls和oauth"><a class="header-anchor" href="#tls和oauth"></a>TLS和OAuth</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/8378664/does-an-oauth-2-client-really-need-tls" target="_blank" rel="noopener">does-an-oauth-2-client-really-need-tls</a>： 我自己有点搞不清楚这些的关系，这边有一个解释很是清晰，看了就明白了
<ul>
<li><em>3.1.2.1.  Endpoint Request Confidentiality If a redirection request will result in the transmission of an authorization code or access token over an open network (between the resource owner’s user-agent and the client), the client SHOULD require the use of a transport-layer security mechanism.</em> 这个是<code>Oauth</code>官方文档里面的一段话。</li>
<li>上面一段的意思应该是这样的：一个第三方认证的请求在传输<code>authorization code</code>或者<code>access token</code>的时候应当在传输层使用安全机制。这里的安全机制就是指<code>TLS</code>协议。</li>
</ul>
</li>
</ul>
<h2 id="tls版本"><a class="header-anchor" href="#tls版本"></a>TLS版本</h2>
<ul>
<li><code>SSL3.0</code> 和 <code>TLS1.0</code> 是一个东西。嗯，微软干的。微软虽然是一个伟大的公司，但是这个干得不好，相当不好，至少我本人觉得不好。实在是除了增加大家的混淆以外，没有任何意义。嘛，我们自己的产品也经常干这种事情。通常呢，是因为自己认为发生了跨时代的改变，希望让别人也明白。</li>
<li>目前最流行的版本是<code>TLS1.2</code>，最新的版本是<code>TLS1.3</code>。</li>
<li><code>java8</code>中默认的是<code>TLS1.2</code>版本。<code>java11</code>里面支持的是<code>TLS1.3</code></li>
<li>各种<code>web</code>应用服务器的配置文件里面都可以配置支持或者不支持的版本。比如<code>tomcat</code>提供了参数:<code>sslEnabledProtocols</code></li>
</ul>
<h3 id="如何发现我的浏览器使用的tls版本"><a class="header-anchor" href="#如何发现我的浏览器使用的tls版本"></a>如何发现我的浏览器使用的TLS版本</h3>
<ul>
<li>因为要测试<code>tomcat</code>里面配置的参数是否生效，所以第一反应就是我咋知道呢。后来经同事提点，其实用<code>openssl</code>就可以了</li>
<li>在浏览器的配置中能看到， 比如IE, <code>File</code>-&gt;<code>Properties</code>, 在<code>Connection</code>一栏就能看到。</li>
<li>参考链接：
<ul>
<li><a href="https://www.thesslstore.com/blog/google-chrome-72-deprecates-support-for-tls-1-0-tls-1-1/" target="_blank" rel="noopener">chrome如何配置和查看</a></li>
<li><a href="https://security.stackexchange.com/questions/19096/how-to-determine-if-a-browser-is-using-an-ssl-or-tls-connection/169418" target="_blank" rel="noopener">如何查看website的TLS版本</a></li>
</ul>
</li>
</ul>
<h3 id="如何测试tls连接"><a class="header-anchor" href="#如何测试tls连接"></a>如何测试TLS连接</h3>
<ul>
<li>这个是刚需啊刚需。使用<code>openssl</code>肯定也是可以的。这回使用的是<code>curl</code>命令。</li>
<li><code>curl help</code>一下可以看到，使用参数就可以指定<code>TLS</code>版本，还是很好用的。<br>
😦 我觉得自己有时候是很奇怪的人啊，下回要把实际使用的命令写在这里。╭(╯^╰)╮</li>
</ul>
<h2 id="tls双向握手"><a class="header-anchor" href="#tls双向握手"></a>TLS双向握手</h2>
<h3 id="keystore和truststore"><a class="header-anchor" href="#keystore和truststore"></a>KeyStore和TrustStore</h3>
<ul>
<li><code>keystore</code>和<code>truststore</code>从其文件格式来看其实是一个东西，都是<code>.jks</code>文件，只是为了方便管理将其分开</li>
<li><code>keystore</code>中一般保存的是服务器端的私钥，用来加解密或者为别人做签名。存储服务器端的公钥和私钥。</li>
<li><code>truststore</code>中保存的是一些可信任的证书，主要是<code>java</code>在代码中访问某个<code>https</code>的时候对被访问者进行认证的，以确保其实可信任的。一般为公钥<br>
<code>truststore</code>里面存储的是服务器的信任密钥存储库，存<code>CA</code>公钥，也会有人在里面存储客户端的证书集合。</li>
<li>应该在不同的协议中都有可能碰到，不仅仅是<code>HTTPS</code>，在网上搜索过程中有<code>LDAP</code>也用到的。</li>
<li>参考链接
<ol>
<li><a href="https://www.cnblogs.com/gsls200808/p/4500246.html" target="_blank" rel="noopener">KeyStore和TrustStore</a></li>
</ol>
</li>
</ul>
<h3 id="keytool"><a class="header-anchor" href="#keytool"></a>Keytool</h3>
<h3 id="openssl"><a class="header-anchor" href="#openssl"></a>openssl</h3>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://xz.aliyun.com/t/2530" target="_blank" rel="noopener">TLS 协议详解</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/10/11/K8s-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/10/11/K8s-Service/" itemprop="url">K8s Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-11T16:40:09+08:00">
                2019-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Service的概念有点多，内容，单独拎出来做一篇。</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://www.kubernetes.org.cn/kubernetes-services" target="_blank" rel="noopener">名词解释 Services</a></li>
<li><a href="https://segmentfault.com/a/1190000019376912" target="_blank" rel="noopener">Kubernetes Service详解</a></li>
</ul>
<h2 id="为什么需要service"><a class="header-anchor" href="#为什么需要service"></a>为什么需要service</h2>
<p>按照参考链接2里面的解释，倒是很容易理解。POD可以起很多个，是实体，还一会有一会没的。<br>
而service是暴露服务的，这么说，应该只有一个service才对吧。瞅着确实如此啊。</p>
<h2 id="services"><a class="header-anchor" href="#services"></a>Services</h2>
<p>service是K8s里面一个非常重要的概念。类型比较多。K8s中文文档里面的名词解释还是比较清楚的，并且给出了为什么需要service，service和pod有什么区别</p>
<ul>
<li>
<p>Kubernete Service 是一个定义了一组Pod的策略的抽象，我们也有时候叫做宏观服务。这些被服务标记的Pod都是（一般）通过label Selector决定的（下面我们会讲到我们为什么需要一个没有label selector的服务）</p>
</li>
<li>
<p>A Kubernetes service is a named load balancer that proxies traffic to one or more containers.</p>
</li>
<li>
<p>The proxy works even if the containers are on different nodes. Services proxy communicate within the cluster and rarely expose ports to an outside interface.When you launch a service it looks like you cannot connect using curl or netcat unless you start it as part of Kubernetes. The recommended approach is to have a LoadBalancer service to handle external communications.<br>
<strong>好吧，这段话基本没看懂，暂时就不管它了。service不仅仅是load balancer吧，难道每一种service都是load balancer的一种体现吗？</strong></p>
</li>
<li>
<p>Kubernetes Services are an abstract that defines a policy and approach on how to access a set of Pods. The set of Pods accessed via a Service is based on a Label Selector.</p>
</li>
<li>
<p>Service有很多种，包括<code>targetPort</code>，经常用到的，还有：<code>Cluster IP</code>， <code>NodePort</code> ，<code>External IPs</code>， <code>Load Balancer</code>之类</p>
<ul>
<li>Cluster IP的解释： Cluster IP is the default approach when creating a Kubernetes Service. The service is allocated an internal IP that other components can use to access the pods.</li>
</ul>
<p><strong>cluster IP是默认的service的类型。这种service会暴露一个internal IP，来供给系统中其他的service来访问这堆pod提供的服务，所以通常也会有port的隐射.</strong></p>
<ul>
<li>
<p>Target Port的解释：Target ports allows us to separate the port the service is available on from the port the application is listening on. TargetPort is the Port which the application is configured to listen on. Port is how the application will be accessed from the outside.<br>
<strong>这回比较清楚了，service其实是将POD提供的服务转出来，port是开在service上面，这样其他的service访问这个service的时候就是用这个port，而target port是对应到POD的应用上面的。比如我们自己产品的北向端口的POD，提供的服务开在8080上面，yaml文件里面起的service的port也是8080，其实也可以改成其他的</strong></p>
</li>
<li>
<p>NodePort的解释：the NodePort exposes the service on each Node’s IP via the defined static port. No matter which Node within the cluster is accessed, the service will be reachable based on the port number defined.<br>
<strong>就是<code>get Nodes</code>的命令出来的Node吧。<code>get Nodes</code>命令给出的是<code>hostname</code>，我们自己的环境里面，<code>hostname</code>一般定义格式是<code>node-10-210-154-52</code>,后面这个就是node的IP。这些node实际上是虚拟机。或者是实体机，现在应该都是虚拟的node。比如可以在openstack的node集群上面搭建k8s的服务</strong></p>
</li>
</ul>
<ul>
<li>External IPs的解释：给定master Node的一个IP。然后The service is now bound to the IP address and Port 80 of the master node</li>
<li>Load Balancer的解释：cloud Provider都是有自己的load Balancer的。如果没有的话，可以dynamically allocate IP addresses to LoadBalancer type services.When a service requests a Load Balancer, the provider will allocate one from the 10.10.0.0/26 range defined in the configuration.这个是确定的范围吗</li>
<li>结合上面的，我觉得都需要啊。</li>
</ul>
</li>
</ul>
<h2 id="暴露service的命令"><a class="header-anchor" href="#暴露service的命令"></a>暴露service的命令</h2>
<ul>
<li><code>kubectl expose deployment first-deployment --port=80 --type=NodePort</code>
<ul>
<li>
<p>将资源暴露为新的Kubernetes Service。</p>
</li>
<li>
<p>expose后面的资源有很多种，包括：pod（po），service（svc），replication controller（rc），deployment（deploy），replica set（rs）</p>
</li>
<li>
<p>A Kubernetes service deployment has, at least, two parts. A replication controller and a service. 稍微有点理解了。一个service部署的时候一般有两个yaml文件</p>
</li>
<li>
<p><code>first-deployment</code>是deployment的名字</p>
</li>
<li>
<p>port 是内部的端口</p>
</li>
<li>
<p>–target-port是外部访问的端口</p>
</li>
<li>
<p>完整语法为：</p>
</li>
</ul>
</li>
</ul>
<pre><code>expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type]
</code></pre>
<h3 id="yaml文件"><a class="header-anchor" href="#yaml文件"></a>yaml文件</h3>
<ul>
<li>参考链接二中的yaml文件的例子如下：</li>
</ul>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: gowebsvc
spec:
  selector:
    app: goweb
  ports:
  - name: default
    protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
</code></pre>
<ul>
<li><code>selector</code>指定了是哪个pod，因为pod可能有很多，所以这里用的是pod的tag <code>app: goweb</code>，就是说，这个service是暴露所有这个tag的pod的功能的</li>
</ul>
<h2 id="请求转发"><a class="header-anchor" href="#请求转发"></a>请求转发</h2>
<p><code>cluster ip</code>类似VIP,从这个名字来说，应该是认为一组pod就是一个<code>cluster</code>，确实也可以如此认为。既然是类似<code>VIP</code>，那么就可以被认为是<code>load banlancer</code>，那么就有策略的问题了。<br>
使用以下命令，可以查看<code>clusterIP 10.106.202.0</code>的转发策略</p>
<pre><code>iptables-save | grep 10.106.202.0
</code></pre>
<p>需要实际操作，暂时没时间，跳过这一段的细节。目前先简单理解一下：当一条<code>request</code>发到某个<code>service</code>的<code>cluster ip + port</code>上面时，会经过两次数据链转发（这里的数据链，指的是<code>iptables</code>里面的数据转发规则），第一次数据链转发时候会进行load的分配。<br>
第一条转发链如下.<code>KUBE-SVC-SEG6BTF25PWEPDFT</code>转发链将request均分到4个pod上面。</p>
<pre><code> -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.25000000000 -j KUBE-SEP-5ZXTVLEM4DKNW7T2
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-EBFXI7VOCPDT2QU5
 -A KUBE-SVC-SEG6BTF25PWEPDFT -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-C3PKSXKMO2M43SPF
 -A KUBE-SVC-SEG6BTF25PWEPDFT -j KUBE-SEP-2GQCCNJGO65Z5MFS
</code></pre>
<p>第二次转发的时候，会对目的地做<code>DNAT</code>（😦 完全不知道这是啥），反正做了这个<code>DNAT</code>，然后就<code>DNAT</code>到了<code>endpoint</code>上面。</p>
<p><em>比照上面的规则，可以看出<code>KUBE-SEP-5ZXTVLEM4DKNW7T2</code>这条规则对请求的目的地址作了<code>DNAT</code>到<code>10.244.1.15:8000</code>，这正是<code>goweb</code>POD组中<code>goweb-55c487ccd7-5t2l2</code>这个pod的ip地址</em></p>
<pre><code>[root@master-1 ~]# iptables-save | grep  &quot;A KUBE-SEP-5ZXTVLEM4DKNW7T2&quot; 
-A KUBE-SEP-5ZXTVLEM4DKNW7T2 -s 10.244.1.15/32 -j KUBE-MARK-MASQ
-A KUBE-SEP-5ZXTVLEM4DKNW7T2 -p tcp -m tcp -j DNAT --to-destination 10.244.1.15:8000
</code></pre>
<h3 id="endpoint"><a class="header-anchor" href="#endpoint"></a>endpoint</h3>
<ul>
<li>
<p>在service创建的时候，kube-proxy组件（每个k8s服务器都会有的组件）会自动创建同名的endpoint对象。</p>
</li>
<li>
<p>动态地跟踪匹配selector的一组pod当前ip（pod的ip在pod的yaml文件里面可以知道，名字就是podIP）及端口，并生成相应的iptables KUBE-SVC-xxx规则</p>
</li>
<li>
<p><code>service</code>是用了endpoint来对pod进行动态的跟踪的。一个pod的IP发生变化的时候，endpoint和KUBE-SVC-XXX规则会相应变化</p>
</li>
<li>
<p><code>endpoint</code>是k8s的另一个对象，生成一个<code>service</code>的时候，会相对应生成一个<code>endpoint</code>.</p>
<p>$ kubectl get ep -n sheild-1 eric-act-activation-mml<br>
NAME         ENDPOINTS                           AGE<br>
eric-act-activation-mml  192.168.15.102:8111,192.168.15.102:8010   1h</p>
</li>
</ul>
<h3 id="请求代理的三种方式"><a class="header-anchor" href="#请求代理的三种方式"></a>请求代理的三种方式</h3>
<p>全文参考链接二里面有三种方式。由于网络基础较差，先记录在这里：</p>
<ul>
<li>Userspace 模式：这种模式完全依靠<code>kube-proxy</code>来，<em>Userspace模式的代理转发主要依靠kube-proxy实现，工作在用户态。所以，转发效率不高</em></li>
<li>iptables 模式: 也就是上面稍加解释的方法，是目前的默认模式。</li>
</ul>
<p><em>与userspace模式最大的不同点在于，kube-proxy只动态地维护iptables，而转发完全靠iptables实现。由于iptables工作在内核态，不用在用户态与内核态切换，所以相比userspace模式更高效也更可靠。但是每个服务都会生成若干条iptables规则，大型集群iptables规则数会非常多，造成性能下降也不易排查问题。</em></p>
<ul>
<li>ipvs 模式: 在v1.9版本以后，服务新增了ipvs转发方式.</li>
</ul>
<p><em>ipvs同样工作在内核态，而且底层转发是依靠hash表实现，所以性能比iptables还要好的多，同步新规则也比iptables快。同时，负载均衡的方式除了简单rr还有多种选择，所以很适合在大型集群使用。而缺点就是带来了额外的配置维护操作。</em></p>
<h3 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/u011563903/article/details/86692694" target="_blank" rel="noopener">K8S kube-proxy iptables 原理分析</a></li>
</ul>
</li>
</ul>
<h2 id="服务发现"><a class="header-anchor" href="#服务发现"></a>服务发现</h2>
<p>先区分一下上面的请求转发和这里的服务发现。<br>
请求的话通常是端口号+地址就行啦。服务发现要能够发现这个service才行。就是如何让另一个service知道这个service的ip或者hostname，或者让k8s外的客户知道某个service的ip和端口</p>
<h3 id="内部服务发现"><a class="header-anchor" href="#内部服务发现"></a>内部服务发现</h3>
<p>内部服务发现有两种方式：环境变量和DNS</p>
<h3 id="外部服务发现"><a class="header-anchor" href="#外部服务发现"></a>外部服务发现</h3>
<p>外部服务发现，顾名思义，就是k8s服务器以外来发现某个service提供的服务</p>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/chris-cp/p/6724057.html" target="_blank" rel="noopener">k8s实战之Service</a></li>
</ul>
</li>
</ul>
<h4 id="nodeport"><a class="header-anchor" href="#nodeport"></a>NodePort</h4>
<p>nodePort 和 node是一对，首先要理解一下node的概念。这边的node相当于是VM。<br>
就是这样的，我有一套硬件，然后我在上边搭k8s，k8s会先搭出一堆node来，然后再在这堆node上边建namespace，每个namespace里面再建pod啊之类的。<br>
所以可以理解成VM，那么这个IP是可以访问到的。<br>
这样NodePort就容易理解了。</p>
<p><em>NodePort Service是类型为NodePort的Service， k8s除了会分配给NodePort Service一个内部的虚拟IP，另外会在每一个Node上暴露端口NodePort，外部网络可以通过[NodeIP]:[NodePort]访问到Service。</em></p>
<p>需要注意的是，NodePort service会在每个node上面注册自己。所以如果一套namespace是搭在好几个node上面的，应该都能访问到</p>
<p><em>该方式把服务暴露在每个Node主机IP的特定端口上,同一个服务在所有Node上端口是相同的，并自动生成相应的路由转发到ClusterIP</em></p>
<p>所以NodePort的service也是有cluster IP的。</p>
<h4 id="loadbalancer"><a class="header-anchor" href="#loadbalancer"></a>LoadBalancer</h4>
<h4 id="ingress"><a class="header-anchor" href="#ingress"></a>Ingress</h4>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/08/22/5G/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/08/22/5G/" itemprop="url">5G</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T14:04:36+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为通信行业的一名软件开发人员，我要开始学习5G啦。😃</p>
<p>里面有非常多的新网元引入。各种缩写漫天飞舞 😢</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://medium.com/5g-nr/5g-service-based-architecture-sba-47900b0ded0a" target="_blank" rel="noopener">5G Service-Based Architecture (SBA)</a></li>
<li><a href="https://www.grandmetric.com/2018/03/02/5g-core-network-functions/" target="_blank" rel="noopener">5G Core Network Functions</a></li>
</ul>
<h2 id="5gc-概述"><a class="header-anchor" href="#5gc-概述"></a>5GC 概述</h2>
<ul>
<li><code>5G</code>里面的新的<code>core network</code>一般叫做<code>NR</code>，但是也有的地方，比如霓虹国，称为<code>next generation</code></li>
<li><code>SA</code>和<code>NSA</code>：<code>SA</code>就是<code>standalone</code>,<code>NSA</code>就是<code>non standslone</code>。这边的<code>SA</code>其实就是说只有<code>5G</code>，后面就是<code>4G</code>和<code>5G</code>并存。不同的运营商会有不同的网络状况。
<ul>
<li>现在正处于一个过渡期间，也可能会长期存在，出现了一些在4G的网元上面开发5G的功能，然后作为5G的网元来用的情况。</li>
</ul>
</li>
<li>通常我们关心的<code>5GC</code>是<code>5G corenetwork</code>的缩写。然后<code>5G</code>的核心有三大类: <code>SBA - service based architecture</code>, <code>CUPS - Control and User Plane Separation</code> 和 网络切片<br>
<strong>所以5GC和NR是一个东西?</strong></li>
<li>配置还是和4G一样的。统一来配置的。<code>E&amp;M</code>统一来做，因为现在平台软件是一致，所以RAN和core都一样，都用一个来做配置</li>
<li><code>UDC</code>换了个名字叫<code>UDR</code></li>
</ul>
<h3 id="sba"><a class="header-anchor" href="#sba"></a>SBA</h3>
<ul>
<li>
<p><code>SBA</code> 感觉和软件架构上面的微服务有点异曲同工的感觉。<code>4G</code>时代是各种各样的协议，每两个网元之间就可能有一种协议，并且还各不相同。但是到了<code>5G</code>的时候就是大家统一都是用<code>HTTP</code>协议了。然后各个网元只是提供<code>service</code></p>
</li>
<li>
<p>所以SBA是一种架构</p>
<p><img src="https://www.grandmetric.com/wp-content/uploads/2018/03/5G_Core_Network.png" alt></p>
</li>
</ul>
<h2 id="5g-nr"><a class="header-anchor" href="#5g-nr"></a>5G NR</h2>
<p><code>NR</code>指的是<code>new Radio</code>。在<code>5G</code>里面分为了<code>NE - Network Element</code>和<code>NF - Network Function</code>两个概念。顾名思义，<code>NF</code>是往外提供服务的</p>
<ul>
<li><code>NF</code>是一个功能，3GPP里面定义的，NE是一个实际的网元。一个NE可能会实现多个NF。</li>
</ul>
<h3 id="amf"><a class="header-anchor" href="#amf"></a>AMF</h3>
<p>与接入网相关</p>
<h4 id="smf"><a class="header-anchor" href="#smf"></a>SMF</h4>
<p>可能有一些与provision相关的</p>
<h3 id="nef-network-exposure-function"><a class="header-anchor" href="#nef-network-exposure-function"></a>NEF - Network Exposure Function</h3>
<h4 id="scef-和-mtc-iwf"><a class="header-anchor" href="#scef-和-mtc-iwf"></a>SCEF 和 MTC - IWF</h4>
<ul>
<li><code>(MTC - IWF) Machine Type Communications - Interwording Function</code>,</li>
</ul>
<h4 id="nef是什么"><a class="header-anchor" href="#nef是什么"></a>NEF是什么</h4>
<ul>
<li>NEF provides a mechanism for securely exposing services and features of the 5G core.</li>
<li><code>NEF</code>是和<code>SMF</code>连接在一起的。将<code>core</code>里面的功能暴露给外界的应用</li>
</ul>
<h3 id="nrf"><a class="header-anchor" href="#nrf"></a>NRF</h3>
<h4 id="nrf是什么"><a class="header-anchor" href="#nrf是什么"></a>NRF是什么</h4>
<ul>
<li><code>NF Repository function (NRF)</code> supports: service discovery function, maintains NF profile and available NF instances. (not present in EPC world)。</li>
<li>替换了原来<code>4G</code>里面的<code>ENUM</code>和<code>AAA</code></li>
<li><code>NRF</code>的功能看起来比较简单，有以下：
<ul>
<li>Service registration and discovery function so that Network Functions can discover each other.</li>
<li>Maintains NF profile and available NF instances</li>
<li>嗯，就是以上说的，<code>NR</code>会将自己注册到<code>NRF</code>里面，注册时候会带上不少信息，比如能提供的服务，自己认可的能访问服务的<code>NR</code>之类，同时会将自己的名字告诉给<code>NRF</code>。还有订阅功能。就是在<code>NRF</code>订阅自己关注哪些<code>NF</code>的哪些service</li>
<li><code>NR</code>可以通过<code>NRF</code>来访问其他<code>NR</code>。过程如下图所示。</li>
<li><code>NRF</code>在告诉同时会颁发一个<code>token</code>，做一些初步的验证。</li>
</ul>
</li>
</ul>
<p><img src="https://miro.medium.com/max/1008/1*VfK1R5ie3DRElDFHjrI-kw.png" alt></p>
<p><em>Network Repository Function service registration and discovery</em> (Credit: <a href="http://www.3gpp.org/ftp/information/presentations/Presentations_2017/webinar-ct-status-11-2017.pdf" target="_blank" rel="noopener">3GPP</a>)</p>
<ul>
<li>实际的部署和功能可能会更加复杂，例如，
<ul>
<li>每个网络切片可以有自己的<code>NRF</code></li>
<li>我大中华地域广阔，还会有地域的概念，一个不够。</li>
<li>那么一个上海人漫游到北京，联上了北京的<code>NRF</code>,北京的<code>NRF</code>得和上海的进行通信。如果漫游到了境外， 就更加复杂了。</li>
<li><code>NRF</code>也可以监控各个网元的状态，或者提供更加复杂的功能</li>
</ul>
</li>
<li>在<code>R16</code>里面提出了一个proxy的概念，<code>SCP - service Communication proxy</code>，因为<code>NRF</code>的网络通信过于繁杂，造成了很大的负担，所以引入的。</li>
</ul>
<h4 id="scp"><a class="header-anchor" href="#scp"></a>SCP</h4>
<h3 id="nssf"><a class="header-anchor" href="#nssf"></a>NSSF</h3>
<ul>
<li><code>NSSF</code>的数据分为<code>static</code>和<code>synamic</code>的数据。前者存在<code>UDM</code>里面，后者在<code>NSSF</code>里面。</li>
<li><code>UE</code>连入的时候会申请使用某种<code>slice</code>，然后网络会返回许可，存储的时候可以存在<code>UDM</code>里面</li>
<li>切片分为接入网，<code>RAN</code>和核心网，接入网是频段等的切片，目前没有合适的solution，而核心网的切片实际上就是拉一套小型的核心网起来，虚拟的，里面可能<code>AMF</code>是独立的，而<code>PCF</code>就是共用的。</li>
</ul>
<h3 id="pcf-policy-control-function"><a class="header-anchor" href="#pcf-policy-control-function"></a>PCF -  Policy Control Function</h3>
<ul>
<li><code>PCF</code>其实就是<code>4G</code>里面的<code>PCRF</code>。都是做<code>policy control</code>的</li>
<li><code>PCF</code>可以支持<code>AMF</code>的<code>policy control</code>和网络切片的<code>policy control</code></li>
<li><code>PCF</code>理解<code>UE</code>级别的，就是这个<code>UE</code>可以使用哪些<code>AMF</code>和<code>NSSF</code>。</li>
</ul>
<h2 id="5g基站和接入网的演进"><a class="header-anchor" href="#5g基站和接入网的演进"></a>5G基站和接入网的演进</h2>
<p>由于工作缘故，接触到的基本是核心网，话说刚刚入行的时候，我是做接入网的来着。<br>
但是其实，5G虽然是核心网变化最大，接入网也是有改变的</p>
<h3 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h3>
<ul>
<li><a href="https://blog.csdn.net/ityouknow/article/details/81351317" target="_blank" rel="noopener">第一次有人把5G讲的这么简单明了</a></li>
<li><a href="https://blog.csdn.xn--ne5Gt-vq5hmb652jn0tuwkpp6bfuycjqfvo0b/cf2SudS8x8F0v/article/details/78778384" target="_blank" rel="noopener">详解5G的六大关键技术</a></li>
</ul>
<h3 id="5g的改变"><a class="header-anchor" href="#5g的改变"></a>5G的改变</h3>
<ul>
<li>高频段传输：频率越高，能使用的频率资源越丰富。频率资源越丰富，能实现的传输速率就越高。</li>
<li>微基站：这个老早就有了。嗯，基站越小越好，覆盖好，而且能搞一大堆。高频段传输，距离短，正好用一大堆小基站</li>
<li>Ｍassive MIMO（大规模多天线技术）</li>
<li>D2D： 这个技术还是不错的，就是说如果靠得近，手机之间直接进行连接，不需要走基站了。但是后面技术如何支持的，并没有提到</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/08/16/OAuth2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/08/16/OAuth2-0/" itemprop="url">OAuth2.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T10:22:26+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index">
                    <span itemprop="name">security</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个Oauth吧，我感觉我几年前就听到了，可惜还是没弄明白。必须承认那些传来传去啊，容易搞混淆和忘。<br>
嗯，写完了也还是有半懂不懂的感觉，不过好歹是个半懂了 😂</p>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://coolshell.cn/articles/19395.html" target="_blank" rel="noopener">HTTP API 认证授权术</a>：来自酷壳，写得很清楚，一步一步。感觉看这篇就能了解前世今生了。挺好。<br>
所以这篇博客就是以酷壳这篇为基础来学习的</li>
</ul>
<h3 id="http-basic"><a class="header-anchor" href="#http-basic"></a>HTTP Basic</h3>
<ul>
<li>上述参考链接里面说得很清楚。其实就是<code>user:password</code>用<code>Base64</code>编码协议进行编码，然后传输</li>
<li>但是可以看到这里仅仅是加密协议，所以通常会和HTTPS配合起来，用<code>TLS/SSL</code>的安全加密方式来传输</li>
<li>就是将编码后的字符放在HTTP协议的<code>Authenticate: Basic</code>里面。</li>
<li>需要注意的点是：
<ul>
<li>编码协议和加密协议不一样, <code>Base64</code>就是个编码，<code>RSA/AES</code>才是加密，<code>MD5</code>就只是取摘要的</li>
<li><code>HTTP Basic</code>方式将密码和用户名放在公网上面传输，存在风险</li>
</ul>
</li>
</ul>
<h3 id="digital-access"><a class="header-anchor" href="#digital-access"></a>Digital Access</h3>
<ul>
<li>参考链接：
<ul>
<li><a href="https://www.cnblogs.com/huey/p/5490759.html" target="_blank" rel="noopener">HTTP - 摘要认证</a></li>
<li><a href="https://www.cnblogs.com/xzwblog/p/6834663.html" target="_blank" rel="noopener">HTTP认证与https简介</a></li>
<li><a href="https://en.wikipedia.org/wiki/Digest_access_authentication" target="_blank" rel="noopener">维基百科HTTP摘要认证</a></li>
</ul>
</li>
<li>摘要认证与基础认证是兼容的，但是进行了如下修改：
<ul>
<li>永远不会以明文方式在网络上发送密码。</li>
<li>可以防止恶意用户捕获并重放认证的握手过程。</li>
<li>可以有选择地防止对报文内容的篡改。</li>
<li>防范其他几种常见的攻击方式。</li>
</ul>
</li>
<li>还是维基百科比较清楚。摘要认证会使用MD5的方式来加密用户名和密码。相对来说，基础认证仅仅是使用了编码方式，而不是加密方式。</li>
<li>同时，摘要认证使用了<code>nonce values</code>来阻止<code>replay attacks</code><strong><em>不知道翻译成什么，重演攻击？</em></strong></li>
<li>但是整个过程其实关键是用户的password，这个password如果不够复杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击。 <strong><em>这点我还没理解</em></strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/OAuth2.0/http_digital_access_nonce.png" alt><br>
<strong>nonce 说明图</strong></p>
<ul>
<li>以下是自己画的简明的流程图，还是比较清楚的。
<ul>
<li>[]代表里面的数值</li>
<li><code>nonce</code>是服务器端生成的随机数。 <code>cnonce</code>是客户端生成的</li>
<li>如果多了<code>auth</code>，那么还要发送<code>HA2</code>，里面的<code>method</code>就是指<code>GET</code>操作， <code>entity body</code>指的是<code>HTTP request</code>的数据</li>
<li><code>opaque</code>看起来也是一个随机数，不知道是啥。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/OAuth2.0/http_digital_access.png.png" alt></p>
<h3 id="jwt-json-web-tokens"><a class="header-anchor" href="#jwt-json-web-tokens"></a>JWT – JSON Web Tokens</h3>
<p>本来想跳过其中几个，直接学习2.0的，貌似不可行。学习时候还是一步步来，不然就看不明白了。<br>
查博客的时候，又看到阮大神的博客了。不知道有没有人能看到我的博客，😇<br>
话说看到评论里有人抨击阮大神说没质量的，嗯，我的还是留着自己看吧。😂</p>
<h4 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h4>
<ul>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">什么是 JWT – JSON WEB TOKEN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JWT – JSON Web Tokens</a>: 阮大神的文章，还比较新，去年的。嘛，这技术不新。话说酷壳的是今年的。</li>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">官方文档</a>： 第一篇博客只是翻译，总的来说，JWT不是很复杂的，看了感觉蛮简单。比摘要还简单一点。</li>
</ul>
<h4 id="session-认证方式"><a class="header-anchor" href="#session-认证方式"></a>session 认证方式</h4>
<ul>
<li>
<p>基于<code>session</code>的认证方式，其实很好理解的。跟我们产品里面的某种协议类似，第一次登陆时候，客户端通过用户名和密码访问，然后服务器端返回一个<code>sessionId</code>。</p>
</li>
<li>
<p>后续访问的时候，就用这个<code>sessionId</code>来访问，服务器端再通过这个<code>sessionId</code>来查询到这个用户的所有信息。包括用户名啊，密码啊，访问权限啊，登录时长啊，我猜的，应该有这些信息。</p>
</li>
<li>
<p>互联网时代，这个<code>sessionId</code>会被浏览器端写入到自己的<code>cookie</code>里面。<strong>现在还有吗，我咋没看到<code>sessionId</code>字样</strong></p>
</li>
<li>
<p>这种方式的问题看起来有两个比较不好(瞅着这么简单，肯定不行啊，我今天脑内小剧场比较多啊)：</p>
<ul>
<li>一个安全问题，基于<code>cookie</code>来做的，想也知道不安全，<code>cookie</code>被读取之后就不成了。</li>
<li>扩展性不好，这个就比较复杂，有各种扩展性，比如<code>sessionId</code>存在服务器端的内存里面，那么内存客户端数量涨了，服务器就撑不住了；再比如，同一个客户，各种用微信登录，这个<code>session</code>没法在不同服务器之间进行共享，除非再引入中转，但是中转一挂就完蛋。</li>
</ul>
</li>
<li>
<p>然后对于上述的问题，就想了一个办法来解决，就是服务器端不再存储客户信息，而是所有信息都放在客户端，服务器端只是加一个签名。客户端后面每次访问都带上自己所有信息。</p>
<ul>
<li>话说，这不是比带<code>sessionId</code>要带的东西多嘛。每次都带，多麻烦呐。好处是服务器就不需要存储信息，无状态了。</li>
<li>这个签名我理解就是嗯，这个客户我老人家认证过了这样的。问题是认证过了就不认证了？应该是不认证了。<strong><em>问题在于这个签名怎么做的，服务器端如何知道这个用户是认证过的，合法的呢？比如我微信登录了一个，我再登录另一个服务器，第二个服务器怎么信任我呢。我想这里理解有点问题，不同的服务器，应该是相同的应用和功能。所以软件上是一套。</em></strong></li>
</ul>
</li>
</ul>
<h4 id="jwt-header"><a class="header-anchor" href="#jwt-header"></a>JWT Header</h4>
<ul>
<li>JWT其实就三个部分，header，payload和签名，在同一行。如下：</li>
</ul>
<pre><code>Header.Payload.Signature
</code></pre>
<ul>
<li>Header是JSON格式，里面有算法和令牌(token)类型，<strong><em>第一次知道<code>token</code>原来中文翻译成令牌，这是个多么熟悉的词组啊，N年前学网络时候没少听到。令牌令牌令牌的，原来是token，瞬间感觉很多东西更明白了，果然看大神的博客有无限好处</em></strong></li>
<li>下面是阮大神博客里面的例子，默认是<code>HMAC SHA256</code>（写成 HS256）。令牌类型就是<code>JWT</code>。这样服务器可以知道这次客户端发来的信息是接受过<code>JWT</code>认证的。</li>
<li>话说认证方式其实也是一种协议啊。特殊的协议。只是之前的<code>HTTP Basic</code>和<code>Digital Access</code>时候不知道服务器端是否存储用户信息。前者我想应该是存储的，后者应该也是存储的，否则无法进行校验。</li>
</ul>
<pre><code>{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<ul>
<li><em>将上面的JSON对象使用Base64URL算法转成字符串</em> 阮大神的实在清楚，我感觉我在加读书笔记。</li>
<li><strong><em>之前说过Base64只是编码算法，算不得加密算法，所以其实JWT的这部分并不十分安全</em></strong></li>
</ul>
<h4 id="jwt-payload"><a class="header-anchor" href="#jwt-payload"></a>JWT payload</h4>
<ul>
<li>payload的话，官方定了几个字段。几篇博客里面貌似没有说到如何实现的。</li>
</ul>
<pre><code>iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre>
<ul>
<li>也可以定义自己的字段。同样是<code>Base64</code>编码，所以不是加密的。</li>
</ul>
<h4 id="jwt-signiture"><a class="header-anchor" href="#jwt-signiture"></a>JWT Signiture</h4>
<ul>
<li>
<p>签名格式如下：</p>
<pre><code>HMACSHA256(
   base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret)
</code></pre>
</li>
<li>
<p>感觉安全性完全就在这个服务器端的秘钥，<code>secret</code>啊。算法就是header里面指定的加密算法。</p>
</li>
</ul>
<h4 id="流程图"><a class="header-anchor" href="#流程图"></a>流程图</h4>
<p><img src="https://upload-images.jianshu.io/upload_images/1821058-2e28fe6c997a60c9.png?imageMogr2/auto-orient/" alt></p>
<p><em>来自上面的参考链接1里面</em></p>
<h4 id="扩展和小结"><a class="header-anchor" href="#扩展和小结"></a>扩展和小结</h4>
<h5 id="扩展"><a class="header-anchor" href="#扩展"></a>扩展</h5>
<ul>
<li>在酷壳文章里面提到了验证服务器。通常实现中，我想服务器应该也会将信息发送到验证服务器来进行<code>secret</code>的加密和签名的解密</li>
<li>同时还提到了使用<code>RSA</code>加密算法来替代<code>HMAC-SHA256</code>算法，可以看一下。</li>
</ul>
<h5 id="小结"><a class="header-anchor" href="#小结"></a>小结</h5>
<ul>
<li>看起来JWT还是比较流行的技术，讨论很多，以下：
<ul>
<li><em>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</em> 看评论解释，也就是说我手机登录了我的微信， ipad也登录了。那么这两个是彼此独立的，ipad登录没法把手机登录的踢出来。</li>
<li>JWT不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li>
</ul>
</li>
</ul>
<h3 id="oauth2-0"><a class="header-anchor" href="#oauth2-0"></a>OAuth2.0</h3>
<h4 id="参考链接-v3"><a class="header-anchor" href="#参考链接-v3"></a>参考链接</h4>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">OAuth 2.0 的一个简单解释</a>: 阮大神的博客，简单清晰明了，确实大有裨益，这个小区快递员啥的，感觉我妈都能明白</li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">OAuth 2.0 的四种方式</a>阮大神的博客，系列作品</li>
</ul>
<h4 id="简介"><a class="header-anchor" href="#简介"></a>简介</h4>
<ul>
<li>
<p><code>OAuth 2.0</code>依赖于<code>TLS/SSL</code>的链路加密技术<code>HTTPS</code>。</p>
</li>
<li>
<p>完全放弃了签名的方式，认证服务器再也不返回什么<code>token</code>,<code>secret</code>的密钥了。</p>
</li>
<li>
<p><code>Auth 2.0</code>是完全不同于1.0 的，也是不兼容的.</p>
</li>
<li>
<p><code>Facebook</code>的<code>Graph API</code>只支持<code>OAuth 2.0</code>协议，<code>Google</code>和 <code>Microsoft Azure</code>也支持<code>Auth 2.0</code>，国内的微信和支付宝也支持使用<code>OAuth 2.0</code>。</p>
</li>
<li>
<p><code>OAuth2.0</code>一共有4个flow。在酷壳上面阐述了其中主要的两个flow。</p>
<pre><code>授权码（authorization-code）
隐藏式（implicit）
密码式（password）：
客户端凭证（client credentials）
</code></pre>
</li>
<li>
<p><code>OAuth</code> 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌，用来代替密码，供第三方应用使用。</p>
<ul>
<li>我们有<code>client</code>,<code>Authorization server</code>,<code>Resource owner</code>和<code>Resource server</code>。那么，对照起来，<code>client</code>是第三方应用，<code>Authorization server</code>是验证服务器， <code>Resource server</code>是资源服务器，也就是被访问的资源保存的地方。<code>Resource Owner</code>是终端用户。</li>
<li>比如说，我访问微信，微信要求登录，会将我的请求转到验证服务器上面，我通过验证，那么微信这个应用会从资源服务器上面获取资源，我作为终端用户就可以使用微信了。这里我就是<code>Resource Owner</code>, 微信是<code>client</code>。</li>
</ul>
</li>
</ul>
<h4 id="oauth2-0-详解"><a class="header-anchor" href="#oauth2-0-详解"></a>OAuth2.0 详解</h4>
<h5 id="authorization-code"><a class="header-anchor" href="#authorization-code"></a>Authorization Code</h5>
<ul>
<li>流程如下。感觉没啥好说的，整个流程挺清楚的。
<ul>
<li><em>不管哪种流程， 第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。应用自阮大神的博客</em></li>
<li><code>code</code>就是代表<code>authorization code</code>。</li>
<li><code>redirect_uri</code>意思是我跳转回第三方应用的地址</li>
<li><code>scope</code>是相关的权限</li>
<li><code>state</code> 是一个随机的字符串，主要用于防<code>CSRF</code>攻击。<code>CSRF - Cross-site request forgery</code>攻击，中文翻译是跨站请求伪造。</li>
<li><code>authorization server</code>返回<code>authorization code</code>时候，其实是带在<code>url</code>里面的。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/OAuth2.0/oauth2.0_authorization_code.png" alt="自己画的流程图"></p>
<ul>
<li>
<p><code>authorization code</code>的格式如下。里面的<code>state</code>和第一步里面的一样。</p>
<pre><code>  https://example-client.com/callback?
  code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
  &amp;state=xcoiv98CoolShell3kch
</code></pre>
</li>
<li>
<p><code>token</code>令牌的样式如下：</p>
</li>
</ul>
<ul>
<li>
<p><code>access_token</code>就是访问请求令牌了</p>
</li>
<li>
<p><code>refresh_token</code>用于刷新<code>access_token</code></p>
</li>
<li>
<p><code>id_token</code>是<code>JWT</code>的<code>token</code>，其中一般会包含用户的<code>OpenID</code></p>
<pre><code>{
    &quot;access_token&quot;: &quot;iJKV1QiLCJhbGciOiJSUzI1NiI&quot;,
    &quot;refresh_token&quot;: &quot;1KaPlrEqdFSBzjqfTGAMxZGU&quot;,
    &quot;token_type&quot;: &quot;bearer&quot;,
    &quot;expires&quot;: 3600,
    &quot;id_token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM...&quot;
}
</code></pre>
</li>
</ul>
<h5 id="client-credential-flow"><a class="header-anchor" href="#client-credential-flow"></a>Client Credential Flow</h5>
<ul>
<li>感觉这个不需要多写了。其实就是上面的流程中没有用户，就是没有<code>Resource Owner</code>。<code>client</code>直接拿自己的<code>clientId</code>和<code>client-secret</code>去做校验和授权了。</li>
</ul>
<h5 id="一些疑问"><a class="header-anchor" href="#一些疑问"></a>一些疑问</h5>
<p>OAuth2.0我还是有些疑问啊：</p>
<ul>
<li>为啥要在<code>token</code>里面带上<code>id_token</code>呢， 这不是暴露了嘛</li>
<li>如何使用<code>refresh_token</code>来刷新<code>access_token</code>呢。虽然很明显这个是一个可选项</li>
</ul>
<h4 id="实现"><a class="header-anchor" href="#实现"></a>实现</h4>
<ul>
<li>阮大神的博客里面还有一部分实现。我很惊讶的发现，哎哟喂，原来我在加博客的评论时候用了呀，<code>Oauth2.0</code> 😊 ,但是我当时URL乱填一气了。</li>
<li><em>所谓第三方登录，实质就是 OAuth 授权</em></li>
<li>参考链接：
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/github-oauth.html" target="_blank" rel="noopener">GitHub OAuth 第三方登录示例教程</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/08/13/Micro-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/08/13/Micro-Service/" itemprop="url">Micro Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T13:41:09+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习一些<code>micro service</code>相关，记录在这里。<br>
现在都是说<code>micro service</code>，但是什么是<code>micro service</code>，可能不同的人有不同的定义，但是单纯地只是将软件部署到<code>docker</code>或者<code>k8s</code>上面去，可能并不完全符合<code>micro service</code>，所以学习一下。<br>
将一些学习到的tips和理念记录下来，最后形成自己的理解。<br>
学习了一阵，感觉还是不一样的，有一套架构体系的，记录在这里。</p>
<h3 id="什么是micro-service"><a class="header-anchor" href="#什么是micro-service"></a>什么是micro service</h3>
<ul>
<li>只占用需要的内存和处理器处理能力</li>
<li>如果是处理数据的，假设我们有一个处理inventory data的<code>micro service</code>，那么这个<code>micro service</code>仅仅需要在意inventory data。而不需要考虑其他数据的影响。</li>
<li><code>micro service</code>不受语言限制，不同语言的<code>micro service</code>仍旧可以联合起来的完成一个solution的</li>
</ul>
<h4 id="aws的理解"><a class="header-anchor" href="#aws的理解"></a>AWS的理解</h4>
<ul>
<li>
<p>参考链接：<a href="https://aws.amazon.com/microservices/" target="_blank" rel="noopener">AWS微服务理解</a></p>
</li>
<li>
<p>每个服务都是独立提供服务的模块，可以独立的开发、升级、部署和扩展</p>
</li>
<li>
<p>每个服务不应该和任何其他服务共享代码</p>
</li>
<li>
<p>服务间的任何交互都应该通过<code>API</code>来进行</p>
</li>
<li>
<p>每个服务都是</p>
</li>
</ul>
<h4 id="微软的理解"><a class="header-anchor" href="#微软的理解"></a>微软的理解</h4>
<ul>
<li>参考链接：<a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices" target="_blank" rel="noopener">微软文章</a></li>
</ul>
<h3 id="micro-service-combination"><a class="header-anchor" href="#micro-service-combination"></a>micro service combination</h3>
<ul>
<li><code>micro service</code>本身是一个<code>complete application</code>，它独立完成某个功能，可以有interface或者没有，可以访问数据库，也可以不访问。</li>
<li>很多<code>micro service</code>联合起来，成为一个solution。</li>
<li>默认只需要知道对方的<code>endpoint</code>就可以进行通信。其实不一定是<code>http</code>协议的，也有一些其他的很流行的总线方式。</li>
<li><strong><em>each micro service has to offer an API endpoint! 通常都是REST的endpoint，但是也可以是<code>wisdom endpoint</code></em></strong></li>
</ul>
<h3 id="micro-service特点"><a class="header-anchor" href="#micro-service特点"></a>micro service特点</h3>
<ul>
<li>增加了scalability。话说这个吧，其实很复杂。看我另外一篇博客。而且未必多加pod，能力就一定上升啊</li>
<li>从下面杂谈里面的几篇文章里面看起来，大家都认为<code>micro service</code>之后，模块之间基本是完全解耦的，大家都开开心心的全栈式就关心自己的模块，从需求到后期客户维护，完全自主，不用管其他模块。<em>A benefit of microservices is that each team can be responsible for releasing their services independently and without coordination with other teams.</em>
<ul>
<li>但是，这怎么可能啊。就我们自己的产品来说，尤其是那些<code>lib</code>库一样的模块，一升级，所有的都得动。没明白。没有明白呀。</li>
<li>除非所有的小模块都像个产品一样运营。比如提供安全管理功能的模块，剩下调用它的模块按照自己的需求进行升级。</li>
<li><strong><em>嗯，确实也是有产品这么做的，但是这样就会有很多资源消耗吧。这点在大牛的分享中也提及过，O&amp;M的功能是公用的，但是会占用资源。</em></strong></li>
<li><strong><em>但是如果大家都用同一份，谈什么微服务哦。那么<code>lib</code>库就不应该占用资源。或者占用资源的就不应该做成<code>lib</code>库？</em></strong></li>
<li><code>google</code>怎么做的？应该也是有不同的产品吧。</li>
</ul>
</li>
</ul>
<h4 id="优势"><a class="header-anchor" href="#优势"></a>优势</h4>
<ul>
<li>
<p>改动：一个微小的改动需要很多工作去做，一个微小的改动会影响很多部分，增加一个需要资源的模块，需要增加整个系统的资源，而不是只增加需要增加的部分</p>
</li>
<li>
<p>扩展：基本上就是指<code>load scalability</code>,在monolithich时代，扩展是扩展所有的模块，就是复制出新的一份系统来。而微服务时候，是扩展需要扩展的部分，这点很有优势</p>
<ul>
<li>所以从以上两点来说，一个微服务在部署和扩展上面，从业务角度来说，就是service角度来说，应该是独立的。<strong><em>那么反过来成立吗？就是说一个pod或者service，可以独立部署，独立扩展，但是并不能提供独立的服务，那么是不是边界定义得不对呢</em></strong></li>
<li><em>We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call.</em></li>
</ul>
</li>
<li>
<p>方便CI和CD</p>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices Architecture</a>:</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjEwNTEzOQ==&amp;mid=401500724&amp;idx=1&amp;sn=4e42fa2ffcd5732ae044fe6a387a1cc3#rd" target="_blank" rel="noopener">上一篇的中文翻译</a></li>
</ul>
</li>
</ul>
<h4 id="逆势"><a class="header-anchor" href="#逆势"></a>逆势</h4>
<p>微服务也是会有一些问题和难点的，比如：</p>
<ul>
<li>进程间通信会比进程内通信代价大很多，所以应该谨慎设计边界。<em>remote APIs need to be coarser-grained, which is often more awkward to use.</em> 不是很理解这句话</li>
<li>Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management. 所以嘛，我就说对技术人员的要求越发高了。虽说是team，但是这种team也很不好搭配的好不好。</li>
<li>并且这种方式，将团队和自己开发的产品绑在了一起。感觉回到了以模块来组织team的年代。实在是有利有弊。还有一个问题，按照现在推荐的，将一部分support的事务归到了技术团队里面，那么有向前延伸吗？话说薪水呢，得涨薪啊</li>
</ul>
<h3 id="微服务架构"><a class="header-anchor" href="#微服务架构"></a>微服务架构</h3>
<p>关于微服务架构的文章真是多如牛毛。一搜一大把。看了陈晧推荐的一篇据说入门级英文文章，确实清晰明了。话说很多中文翻译简直是惨不忍睹啊。真心惨不忍睹！</p>
<p>看了总觉得有有点心惊啊，从<code>warterful</code>到<code>agile</code>，从<code>monolithic</code>到<code>micro service</code>，对开发人员的要求是越来越高了啊。😦</p>
<p>还能不能愉快地做开发了啊？<br>
<em>The microservice approach to division is different, splitting up into services organized around business capability</em></p>
<p>还得有<code>business capability</code>，话说技术人员理解的<code>business capability</code>正确吗</p>
<h3 id="杂谈"><a class="header-anchor" href="#杂谈"></a>杂谈</h3>
<ul>
<li>
<p>早上无心工作，摸鱼酱油，看了几篇文章，觉得还不错。 😅 话说<code>InfoQ</code>就是做翻译工作的嘛，咋云计算那边全是翻译啊。</p>
</li>
<li>
<p><a href="https://medium.com/better-programming/how-microservices-architecture-impacted-the-culture-of-software-development-6bba363ecdf1" target="_blank" rel="noopener">How Microservices Architecture Impacted the Culture of Software Development</a>:</p>
<ul>
<li>这篇文章的观点很是不错，含义就是说写代码很有趣啊，想干嘛就干嘛，把自己脑子里面的想法实现出来。可是工作以后就郁闷了，全是些模糊的责任，规定好了的框架，规定好了的数据库，规定好了的语言。确实如此，一天天消磨了意志和能力</li>
<li>现在有了<code>micro service</code>，瞅着大家都挺开心的，有了这个鼓动，似乎乐趣又回来了一点，可以分为很小的<code>repo</code>，可以自行选择各种不同的语言和技术，然后一起做成为一个产品。甚至可以有产品和售后的职责。</li>
<li>嘛，文章最后还说，这个并不关<code>micro service</code>的关系，所谓的<code>monolithic</code>也应该可以做到。</li>
</ul>
</li>
<li>
<p><a href="https://medium.com/@steven.lemon182/why-our-team-cancelled-our-move-to-microservices-8fd87898d952" target="_blank" rel="noopener">Why our team cancelled our move to microservices</a></p>
<ul>
<li>原文很长，下面的评论也十分之多，实在不算一把头能看完的</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/08/02/Java-Socket中的port/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/08/02/Java-Socket中的port/" itemprop="url">TCP & UDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-02T15:42:25+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/protocal/" itemprop="url" rel="index">
                    <span itemprop="name">protocal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工作中碰到DNS的local 端口的问题，就是client段的port，不是DNS server的端口。这个是默认开在53上面的。<br>
然后就研究了一下，写在这里。</p>
<h3 id="port-0"><a class="header-anchor" href="#port-0"></a>port 0</h3>
<ul>
<li>可用端口是<code>0 ~ 65535</code>。<code>0</code>在这里说啦，是分配一个随机的未被占用的端口。而<code>65535</code> 事实上是会报错的，也是用不了的。</li>
<li>事实上，确实是可能有race condition存在的。并且很难避免。仔细看了一遍，好像并没有很好的提议。</li>
<li>Spring里面的<code>SocketUtil</code>的源码可以参考</li>
<li><code>ServerSocket</code>里面初始化时候其实是有两部的，第二部是bind，如果传0给构造函数，第二部时候才真正是分配的时候。</li>
<li>参考链接：
<ul>
<li><a href="https://blog.csdn.net/qq_36592572/article/details/82323100" target="_blank" rel="noopener">关于端口最大值65535的问题</a></li>
<li><a href="https://stackoverflow.com/questions/12889702/allowed-port-range-for-tcp" target="_blank" rel="noopener">Allowed Port Range for TCP</a></li>
<li><a href="https://stackoverflow.com/questions/115500/how-do-you-specify-a-port-range-for-java-sockets" target="_blank" rel="noopener">how-do-you-specify-a-port-range-for-java-sockets</a></li>
<li><a href="https://stackoverflow.com/questions/2675362/how-to-find-an-available-port" target="_blank" rel="noopener">how-to-find-an-available-port</a>: 这篇链接里面有大量讨论和实现。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/SocketUtils.html" target="_blank" rel="noopener">Class SocketUtils</a></li>
<li><a href="https://stackoverflow.com/questions/51099027/find-free-port-in-java" target="_blank" rel="noopener">find-free-port-in-java</a></li>
</ul>
</li>
</ul>
<h3 id="tcp-udp"><a class="header-anchor" href="#tcp-udp"></a>TCP &amp; UDP</h3>
<ul>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://stackoverflow.com/questions/12737293/how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind?rq=1" target="_blank" rel="noopener">how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind</a>: 里面有很多如何查找是哪个应用在占用端口的方法</li>
<li><a href="https://stackoverflow.com/questions/27730330/java-what-is-the-difference-between-serversocket-and-datagramsocket" target="_blank" rel="noopener">java-what-is-the-difference-between-serversocket-and-datagramsocket</a></li>
<li><a href="https://www.javaworld.com/article/2077322/core-java-sockets-programming-in-java-a-tutorial.html" target="_blank" rel="noopener">Sockets programming in Java</a></li>
</ul>
</li>
<li>
<p>这回犯一个低级错误。但是也是必然的，毕竟底层网络不够了解。</p>
</li>
<li>
<p>这次犯的错误是这样的，需要发现一个free的port来建立UDP连接，于是就使用了<code>serverSocket</code> 来check 端口，参考以上链接。</p>
</li>
<li>
<p>实际是，<code>TCP</code>和 <code>UDP</code> 需要使用不同的结构。ORZ。可见我的java基础和网络基础都很有点薄弱啊。对<code>socket</code>的理解也着实不灵啊。</p>
</li>
<li>
<p><code>UDP</code> 应当使用<code>DatagramSocket</code>结构来建。</p>
</li>
</ul>
<h4 id="udp"><a class="header-anchor" href="#udp"></a>UDP</h4>
<ul>
<li><code>UDP</code>的全称：<code>user datagram protocol</code>。</li>
<li>each time you send datagrams, you also need to send the local socket descriptor and the receiving socket’s address. As you can tell, additional data must be sent each time a communication is made.</li>
</ul>
<h4 id="tcp"><a class="header-anchor" href="#tcp"></a>TCP</h4>
<ul>
<li><code>TCP</code>的全称： <code>transfer control protocol</code></li>
<li>Once two sockets have been connected, they can be used to transmit data in both (or either one of the) directions.</li>
</ul>
<h4 id="when-is-udp-when-is-tcp"><a class="header-anchor" href="#when-is-udp-when-is-tcp"></a>When is UDP &amp; when is TCP</h4>
<ul>
<li><code>UDP</code>有数据大小限制，每次发的时候都要带上信息，不可靠，但是速度高。</li>
<li><code>TCP</code>是面向连接的，所有有建立连接时间。<strong><em>UDP也要建连接呀</em></strong> TCP的数据更像流，而不是一个个数据包，没有大小限制，可靠，但是速度慢很多。</li>
<li>TCP is useful for implementing network services – such as remote login (rlogin, telnet) and file transfer (FTP)</li>
<li>UDP is often used in implementing client/server applications in distributed systems built over local area networks.</li>
<li>一出杯具： 杯具的是，作为一个bug 处理，在学习了一堆，并且记录了一堆之后，自我感觉良好的本人还是犯错了。因为，我们的产品里面不仅仅使用了<code>UDP</code>，还使用了<code>TCP</code>。嘿，我给漏掉了。所以，就算协议学会了，明白了，也得清楚，实现不一定按规矩来的。毕竟都是人来做的。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/hexo_blog/2019/07/26/K8s端口映射命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo_blog/2019/07/26/K8s端口映射命令/" itemprop="url">K8s常用命令集2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T11:17:05+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>K8s的前两篇文档大而乱啊。所以的话，还是小而精更好吧。</p>
<p>接着记录命令，最好相关命令放在一起。</p>
<ul>
<li>kubectl port-forward
<ul>
<li>
<p>Forward one or more local ports to a pod. This command requires the node to have ‘socat’ installed. <strong><em>socat是什么?</em></strong></p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://imti.co/kubernetes-port-forwarding/" target="_blank" rel="noopener">Kubernetes Port Forwarding for Local Development</a></li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward" target="_blank" rel="noopener">官方文档</a></li>
</ul>
</li>
<li>
<p>用例：</p>
<ul>
<li>以下命令的含义是：将本地端口8080和8081，映射到k8s服务<code>ok</code>的8080和80端口上面。<code>-n</code>代表的namespace</li>
<li>默认地址是localhost</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  kubectl port-forward service/ok 8080:8080 8081:80 -n the-project
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/hexo_blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/hexo_blog/page/4/">4</a><a class="extend next" rel="next" href="/hexo_blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lynn Shen</p>
              <p class="site-description motion-element" itemprop="description">35岁开始的博客，有点晚哦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/hexo_blog/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/hexo_blog/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexo_blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/hexo_blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/hexo_blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexo_blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/hexo_blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
        <script src="https://billts.site/js/gitment.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
