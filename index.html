<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo_blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo_blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo_blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo_blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo_blog/css/main.css">


<link rel="stylesheet" href="/hexo_blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sallyslove.github.io","root":"/hexo_blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="35岁开始的博客，有点晚哦">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="https://sallyslove.github.io/hexo_blog/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="35岁开始的博客，有点晚哦">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lynn Shen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sallyslove.github.io/hexo_blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>跬步</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo_blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">跬步</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不积跬步，无以至千里</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo_blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo_blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2021/02/24/Hexo-Related/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2021/02/24/Hexo-Related/" class="post-title-link" itemprop="url">Hexo Related</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 15:38:00" itemprop="dateCreated datePublished" datetime="2021-02-24T15:38:00+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-25 10:21:14" itemprop="dateModified" datetime="2021-02-25T10:21:14+08:00">2021-02-25</time>
              </span>

          
            <span id="/hexo_blog/2021/02/24/Hexo-Related/" class="post-meta-item leancloud_visitors" data-flag-title="Hexo Related" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客搭建在<code>Hexo</code>和<code>NextT</code>上面，七七八八花在上面的时间着实不少，但是并没有记录下来。这里开一个博客来记录一下。</p>
<p>目前的版本如下：</p>
<pre><code>$ hexo --version
    (node:16940) ExperimentalWarning: The fs.promises API is experimental
     (node:16940) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.
      hexo: 4.2.1
      hexo-cli: 4.2.0
</code></pre>
<p>昨天刚刚升级哒，(づ￣ 3￣)づ，开心，我觉得新版本还是不错的</p>
<h2 id="升级的过程"><a class="header-anchor" href="#升级的过程"></a>升级的过程</h2>
<ul>
<li>
<p>参考了<a href="https://lanvnal.com/2020/02/16/hexo-ban-ben-sheng-ji/" target="_blank" rel="noopener">Hexo版本升级指南</a></p>
</li>
<li>
<p>里面的一些命令执行不起来，大约是我的<code>npm</code>环境有些问题</p>
</li>
<li>
<p>执行<code>npm</code>命令时候带上了参数<code>--loglevel verbose</code>，不然屏幕上面啥输出都没有</p>
</li>
<li>
<p>成功执行的命令有：</p>
<pre><code>npm i hexo-cli -g  #这条命令之后hexo-cli就升级好了
  npm install -g npm-upgrade  #安装了npm-upgrade
  npm update -g
  npm update --save
</code></pre>
</li>
<li>
<p><code>NextT</code>的升级简单直接多了，直接进行<code>git clone</code>就好了。</p>
</li>
</ul>
<h2 id="功能配置"><a class="header-anchor" href="#功能配置"></a>功能配置</h2>
<h3 id="评论功能"><a class="header-anchor" href="#评论功能"></a>评论功能</h3>
<ul>
<li>
<p><a href="https://xfqwdsj.github.io/blog/2020/03/20/hexo-comments/" target="_blank" rel="noopener">Hexo Next主题的评论功能</a></p>
</li>
<li>
<p>虽然参考了这篇文档，但是其实并不需要，在<code>NextT</code>的配置文件里面都写得非常清晰，比如用来必力：</p>
<pre><code># LiveRe comments system
  # You can get your uid from https://livere.com/insight/myCode (General web site)
livere_uid: # &lt;your_uid&gt;
</code></pre>
</li>
<li>
<p>按照参考的链接里面几个评论插件的优缺点相比较，来必力是比较好的一款。然鹅，我登录不进去啊。OMG</p>
</li>
</ul>
<h3 id="阅读数量"><a class="header-anchor" href="#阅读数量"></a>阅读数量</h3>
<ul>
<li>作为一个孤独地默默地写着博客的人，对于“我的博客有人看吗？”这种疑问，绝对是好奇的，所以阅读数量也很关键啊</li>
<li></li>
</ul>
<h2 id="问题的解决"><a class="header-anchor" href="#问题的解决"></a>问题的解决</h2>
<h3 id="奇怪的文字"><a class="header-anchor" href="#奇怪的文字"></a>奇怪的文字</h3>
<ul>
<li>
<p>升级之后页面出现了这样奇怪的文字：<code>الأرشيفات</code>，天书啊，这是。谷歌了一下，貌似是世界语</p>
</li>
<li>
<p>在<code>Hexo</code>里面的配置文件<code>_config.yml</code>的<code>language</code>为：</p>
<pre><code>language: zh-CN</code></pre>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2021/02/24/Scala-Code-Example/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2021/02/24/Scala-Code-Example/" class="post-title-link" itemprop="url">Scala Code Example</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-24 10:18:27 / 修改时间：13:21:29" itemprop="dateCreated datePublished" datetime="2021-02-24T10:18:27+08:00">2021-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2021/02/24/Scala-Code-Example/" class="post-meta-item leancloud_visitors" data-flag-title="Scala Code Example" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为一个写代码不咋地样的开发，咳，这是多年想掩饰的缺点啊。虽说天下文章一大抄，总归，即使是基础的写法也是得学习的。写在这篇文档里面。<br>
所以，应该有大量的代码例子吧 ୧(๑•̀◡•́๑)૭</p>
<h2 id="map"><a class="header-anchor" href="#map"></a>Map</h2>
<h3 id="map-foreach"><a class="header-anchor" href="#map-foreach"></a>Map.foreach</h3>
<ul>
<li>
<p><code>map</code>里面的元素在<code>foreach</code>的用法时候，都是二元组。<code>_1</code>是键值，<code>_2</code>是赋值</p>
<pre><code>val m1 = Map(3 -&gt; &quot;geeks&quot;, 1 -&gt; &quot;for&quot;, 2 -&gt; &quot;cs&quot;, 6 -&gt; &quot;geeks&quot;) 

val result = m1.foreach(x =&gt; println(&quot;key=&quot; + x._1 + &quot;, value=&quot; + x._2)) 
</code></pre>
</li>
</ul>
<h2 id="how-to-call-shell-command-in-scala"><a class="header-anchor" href="#how-to-call-shell-command-in-scala"></a>how to call shell command in Scala</h2>
<ul>
<li>
<p>在<code>scala</code>里面调用<code>shell</code>命令是非常方便的，只需要引入<code>import scala.sys.process._</code>包就可以了</p>
<p>val path = “pwd”.!!.trim<br>
println(path)</p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/52967383/how-to-execute-shell-script-sh-file-in-scala-program" target="_blank" rel="noopener">How to execute shell script in scala</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/40129780/execute-shell-script-from-scala-application" target="_blank" rel="noopener">Execute shell script from scala application</a></p>
</li>
</ul>
<h2 id="scala中处理json"><a class="header-anchor" href="#scala中处理json"></a>Scala中处理Json</h2>
<ul>
<li>工作过程中需要判断字符串是不是<code>JSON</code>格式，所以去学习了这个。<code>JSON</code>也是现在常用的数据结构。呃，因为<code>REST</code>里面是<code>JSON</code>的缘故嘛，反正越来越多，没觉得比<code>XML</code>好</li>
<li>有一堆的<code>3pp</code>可以用，我们自己的产品里面也有好几个<code>3pp</code>,包括<code>playjson</code>和<code>gJson</code>，还有<code>GSON</code>。暂时的话，应该学习<code>jackson</code>和<code>GSON</code>就足够了吧</li>
<li>这个链接里面列出了多种库：<a href="https://stackoverflow.com/questions/8054018/what-json-library-to-use-in-scala" target="_blank" rel="noopener">What JSON library to use in Scala?</a></li>
<li>最后我使用的是<code>playjson</code>，这回的代码其实<code>JAVA</code>工程，但是架构在一个<code>SBT</code>项目里面。而<code>playjson</code>是基于<code>jackson</code>的（很多库都是基于<code>jsckson</code>的就是了），所以在<code>SBT</code>里面引入<code>playjson</code>，也就可以在我需要修改的<code>JAVA</code>代码里面调用<code>jackson</code>了。</li>
<li>上面的理解应该有的不对，<code>play</code>是一个框架，<code>playjson</code>是其中的一个项目，是依赖<code>jackson</code>的，并且可以不依赖<code>play</code>框架</li>
<li>参考<a href="https://github.com/playframework/play-json" target="_blank" rel="noopener">playframework/play-json</a>来在<code>SBT</code>，<code>Maven</code>里面引入</li>
</ul>
<h3 id="如何判断一个字符串是不是json格式"><a class="header-anchor" href="#如何判断一个字符串是不是json格式"></a>如何判断一个字符串是不是JSON格式</h3>
<ul>
<li>事实上，不管是<code>java</code>还是<code>scala</code>,都不存在这样的一个现成的接口。</li>
<li>现在通用的方法就是将字符串进行转换，转换成功就说明是，报错就不是，我呵呵一下。</li>
<li>这个参考链接里面是<code>JAVA</code>的，但是<code>scala</code>是一样的。也是调用库函数<br>
<a href="https://stackoverflow.com/questions/10174898/how-to-check-whether-a-given-string-is-valid-json-in-java" target="_blank" rel="noopener">how-to-check-whether-a-given-string-is-valid-json-in-java</a></li>
</ul>
<h3 id="如何得到一个json节点"><a class="header-anchor" href="#如何得到一个json节点"></a>如何得到一个Json节点</h3>
<ul>
<li></li>
</ul>
<h3 id="如何修改一个json节点的值"><a class="header-anchor" href="#如何修改一个json节点的值"></a>如何修改一个Json节点的值</h3>
<h3 id="如何判断某个json节点是不是一个jsonlist或者jsonobject"><a class="header-anchor" href="#如何判断某个json节点是不是一个jsonlist或者jsonobject"></a>如何判断某个Json节点是不是一个JsonList或者JSONObject</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2020/12/10/Scala-Env-Related/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2020/12/10/Scala-Env-Related/" class="post-title-link" itemprop="url">Scala Env Related</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-10 10:22:10" itemprop="dateCreated datePublished" datetime="2020-12-10T10:22:10+08:00">2020-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 10:19:43" itemprop="dateModified" datetime="2021-02-24T10:19:43+08:00">2021-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2020/12/10/Scala-Env-Related/" class="post-meta-item leancloud_visitors" data-flag-title="Scala Env Related" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原来的<code>Scala</code>博客越来越大了。将里面的环境的部分抽出来成为这篇博客。话说对比于<code>Java</code>的<code>Maven</code>，<code>Sbt</code>也太不好用了。</p>
<h2 id="itellij"><a class="header-anchor" href="#itellij"></a>ItelliJ</h2>
<ul>
<li><a href="https://blog.csdn.net/high2011/article/details/76541233" target="_blank" rel="noopener">基本scala环境在IJ里面的搭建</a></li>
</ul>
<h3 id="sbt工程already-exist"><a class="header-anchor" href="#sbt工程already-exist"></a>SBT工程already exist</h3>
<ul>
<li>把一个scala的工程导入，又删除之后， 就再也导不到IJ里面了。</li>
<li>IJ会报错。解决方法在下面的链接里面。</li>
<li><a href="https://stackoverflow.com/questions/24937328/intellij-idea-cannot-import-sbt-project" target="_blank" rel="noopener">scala重复导入</a></li>
</ul>
<h3 id="skipping-scala-files-without-a-scala-sdk"><a class="header-anchor" href="#skipping-scala-files-without-a-scala-sdk"></a>skipping Scala files without a Scala SDK</h3>
<ul>
<li>这个问题是因为没有<code>scala</code>的<code>SDK</code>导致的</li>
<li><a href="https://stackoverflow.com/questions/34798160/problems-importing-scala-libraries-in-intellij" target="_blank" rel="noopener">没有scala SDK</a></li>
<li><a href="https://www.jetbrains.com/help/idea/2016.2/adding-frameworks-support.html" target="_blank" rel="noopener">IJ配置framework support</a></li>
</ul>
<h3 id="depencensy-scala-ij-sbt-not-found-type-moduleid"><a class="header-anchor" href="#depencensy-scala-ij-sbt-not-found-type-moduleid"></a>depencensy.scala IJ SBT not found: type ModuleID</h3>
<ul>
<li>同时也会有&quot;dump project structure from sbt shell&quot;</li>
<li>项目的依赖也无法更新</li>
<li>解决的办法是在导入项目的时候，将<code>Use sbt shell</code>和<code>Download</code>里面的项目都勾上。这样就可以解决一堆问题</li>
</ul>
<h2 id="sbt"><a class="header-anchor" href="#sbt"></a>SBT</h2>
<ul>
<li>安装<code>SBT</code>, <a href="https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html" target="_blank" rel="noopener">SBT下载</a></li>
</ul>
<h3 id="常用命令"><a class="header-anchor" href="#常用命令"></a>常用命令</h3>
<ul>
<li><code>show name</code>: 当前项目名字</li>
<li><code>show libraryDependencies</code>： 常看依赖</li>
<li><code>compile</code>：编译</li>
<li><code>package</code>:打包，如果有<code>Dockfile</code>，会将镜像也做出来</li>
<li><code>sbt evicted</code>: 查看依赖</li>
</ul>
<h3 id="sbt-配置"><a class="header-anchor" href="#sbt-配置"></a>SBT 配置</h3>
<h4 id="仓库配置"><a class="header-anchor" href="#仓库配置"></a>仓库配置</h4>
<ul>
<li><a href="https://www.jianshu.com/p/6db9bac848bd" target="_blank" rel="noopener">sbt仓库设置</a></li>
<li><code>sbt</code>的仓库可以分两层配置
<ul>
<li>
<p>每个项目可以配置自己的仓库，在<code>project</code>目录下面的<code>plugin.sbt</code>里面可以如下配置：</p>
<pre><code>resolvers += &quot;SBT repository&quot; at &quot;https://xxx.xxx.xxx.xxx/&lt;repo&gt;&quot;
</code></pre>
</li>
<li>
<p>在<code>~/.sbt</code>目录下面有一个<code>repository</code>的文件，可以配置仓库。按照上面的链接就可以了。这样配置，就是<code>sbt</code>全局的了</p>
</li>
</ul>
</li>
</ul>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://www.scala-sbt.org/1.x/docs/zh-cn/Directories.html" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://blog.csdn.net/zrc199021/article/details/51776256" target="_blank" rel="noopener">CSDN博客一篇</a></li>
</ul>
<h3 id="could-not-access-type-localtime-in-value-org-joda-time"><a class="header-anchor" href="#could-not-access-type-localtime-in-value-org-joda-time"></a>Could not access type LocalTime in value org.joda.time</h3>
<ul>
<li>在用<code>SBT compile</code>时候报以下的错误：</li>
</ul>
<pre><code>[error] missing or invalid dependency detected while loading class file 'DefaultReads.class'.
[error] Could not access type LocalTime in value org.joda.time,
[error] because it (or its dependencies) are missing. Check your build definition for
[error] missing or conflicting dependencies. (Re-run with `-Ylog-classpath` to see the problematic classpath.)
[error] A full rebuild may help if 'DefaultReads.class' was compiled against an incompatible version of org.joda.time.
</code></pre>
<ul>
<li>
<p><code>google</code>了一堆，在Stack Overflow上面有一堆类似的问题</p>
<ul>
<li><a href="https://stackoverflow.com/questions/8619348/why-is-scala-saying-it-can-t-see-members-of-org-joda-time-period" target="_blank" rel="noopener">joda-time-period</a></li>
<li><a href="https://stackoverflow.com/questions/38218926/cant-compile-scala-sbt-project" target="_blank" rel="noopener">cant-compile-scala-sbt-project</a></li>
</ul>
</li>
<li>
<p>实际解决的方式是：在<code>Dependency.scala</code>里面加入:</p>
<pre><code>val jodaTime: ModuleID = &quot;joda-time&quot; % &quot;joda-time&quot; % &quot;2.10.6&quot;
</code></pre>
<p>val joda: ModuleID = “org.joda”  % “joda-convert” % “1.6”</p>
</li>
<li>
<p>搜索<code>org.joda.time.LocalTime</code>,这个类是在<code>2.10.6</code>版本里面的。</p>
</li>
<li>
<p>奇怪的是这个版本的包没有<code>download</code>下来，手动下载放在<code>repo</code>里面，问题就解决了。</p>
</li>
<li>
<p>看到有的解释是说，如果只装了<code>java</code>，没有装<code>scala</code>的话就需要这两个依赖包，很有可能就是这个原因。因为我并没有额外安装<code>scala</code></p>
</li>
</ul>
<h3 id="object-play-not-found"><a class="header-anchor" href="#object-play-not-found"></a>object play not found</h3>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/36658125/object-play-not-found-in-scala-application" target="_blank" rel="noopener">object-play-not-found-in-scala-application</a></p>
</li>
<li>
<p>在解决这个问题的时候，发现几个有趣的地方：</p>
<ul>
<li>
<p>如果用<code>docker</code>的<code>plugin</code>去做<code>image</code>，和<code>sbt</code>直接<code>package</code>命令做<code>image</code>，前者支持换行时候<code>&amp;&amp;</code>，后者不支持</p>
</li>
<li>
<p><code>dependency</code>文件里面，在<code>java</code>的<code>maven</code>结构下面写成</p>
<pre><code>libraryDependencies += &quot;com.typesafe.play&quot; % &quot;play-json&quot; % &quot;2.5.2&quot;
</code></pre>
</li>
</ul>
<p>就可以了，在scala里面必须带上版本，写成</p>
<pre><code>  libraryDependencies += &quot;com.typesafe.play&quot; % &quot;play-json_2.11&quot; % &quot;2.5.2&quot;
</code></pre>
<p>否则会报错的</p>
</li>
</ul>
<h3 id="conflicting-cross-version-suffix"><a class="header-anchor" href="#conflicting-cross-version-suffix"></a>conflicting cross-version suffix</h3>
<ul>
<li>编译时候报错，这个也是上一个章节中<code>playjson</code>报的错误，其实就是在<code>build</code>文件里面指定了<code>scala</code>的版本是2.12，但是加进去依赖是2.11.就报错了。</li>
<li>将<code>playjson</code>的版本改为<code>play-json_2.12 % 2.7.2</code>也就好了。</li>
<li><a href="https://stackoverflow.com/questions/23617920/why-is-the-error-conflicting-cross-version-suffixes" target="_blank" rel="noopener">why-is-the-error-conflicting-cross-version-suffixes</a></li>
</ul>
<h3 id="not-found-type-moduleid"><a class="header-anchor" href="#not-found-type-moduleid"></a>not found: type ModuleID</h3>
<ul>
<li>这个错误真是狗血，让我很是郁闷了一会。<code>google</code>都没找到啥。在<code>git status</code>之后发现<code>repo</code>里面被改了一堆东西</li>
<li>再<code>git checkout</code>之后就正常了。<code>sbt</code>正常启动起来。</li>
<li>这一堆改动应当是<code>IDE</code>，就是<code>IJ</code>改的。<code>IJ</code>吧，感觉还是<code>maven</code>好用一点。</li>
</ul>
<h3 id="wrong-checksum"><a class="header-anchor" href="#wrong-checksum"></a>wrong checksum</h3>
<ul>
<li>这个错误只要将本地的包删除掉重新编译，不知道为啥会产生这种错误</li>
<li><a href="https://www.cnblogs.com/duchaoqun/p/12703935.html" target="_blank" rel="noopener">sbt wrong checksum</a></li>
</ul>
<h3 id="unsupported-platform-protoc-3-7-0-windows-x86-32-exe"><a class="header-anchor" href="#unsupported-platform-protoc-3-7-0-windows-x86-32-exe"></a>Unsupported platform: protoc-3.7.0-windows-x86_32.exe</h3>
<pre><code>[error] stack trace is suppressed; run 'last synchronizer / Compile / protocGenerate' for the full output
[error] (synchronizer / Compile / protocGenerate) error occurred while compiling protobuf files: Unsupported platform: protoc-3.7.0-windows-x86_32.exe
</code></pre>
<h4 id="问题和解决"><a class="header-anchor" href="#问题和解决"></a>问题和解决</h4>
<ul>
<li>这是个奇怪的问题，问题本身很直白，在<code>gitbash</code>里面调用<code>protoc</code>时候将平台认成了<code>X32</code>，但是本身<code>protoc</code>不支持<code>X32</code>，就报错了。</li>
<li>最后这个问题也没解决，花了一周时间，也没用。应该是因为之前我的笔记本是32位的，后期是64位的，所以认错了。</li>
<li>如果将<code>os.name</code>，<code>os.version</code>，<code>arch</code>这些在其他代码里面打印出来，<code>gitbash</code>里面也是正确是。不知道为啥通过<code>proto</code>调用的就是错误的</li>
<li><code>IJ</code>里面认的是对的，也就没有再纠结了。</li>
</ul>
<h4 id="protobuf"><a class="header-anchor" href="#protobuf"></a>protobuf</h4>
<ul>
<li><code>protoc</code>目前的理解是一种数据模型构建方式，类似<code>XML</code>，<code>JSON</code>。</li>
<li>这个<code>protoc</code>需要一个生成器，就是<code>JAR</code>包里面在找的。</li>
<li>原生来说，这个<code>3pp</code>是支持<code>JAVA</code>的，为了在<code>SCALA</code>里面运用的话，需要额外下载一个<code>plugin</code>：<a href="https://scalapb.github.io/docs/json" target="_blank" rel="noopener">scalapb</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2020/10/19/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2020/10/19/Kafka/" class="post-title-link" itemprop="url">Kafka</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-19 16:07:33" itemprop="dateCreated datePublished" datetime="2020-10-19T16:07:33+08:00">2020-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-21 15:01:40" itemprop="dateModified" datetime="2020-10-21T15:01:40+08:00">2020-10-21</time>
              </span>

          
            <span id="/hexo_blog/2020/10/19/Kafka/" class="post-meta-item leancloud_visitors" data-flag-title="Kafka" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始学习卡夫卡，工作需要，开始得有点晚了。毕竟周围很多同事已经会了。嘛，人比人气死人，进步就好 (๑•̀ㅂ•́)و✧</p>
<h2 id="消息队列"><a class="header-anchor" href="#消息队列"></a>消息队列</h2>
<ul>
<li>看到一篇还不错的博客，作者层层深入，所以我觉得我也需要学习一下。</li>
<li><a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">这位作者的系列文章，貌似已经开公众号了，所以点击会跑到微信上面去。汗一个</a></li>
<li>五分钟时间看了一下，果然是好文章啊。</li>
<li>简单来说，使用消息队列可以解耦生产者和消费者；可以实现异步，提高效率</li>
<li>那么为什么在JAVA中已经有了很多现成的消费队列，还需要自己去写一些中间件呢？</li>
<li>这里面的原因挺多的，但是都很好理解，比如固化，JAVA的队列都是内存里面的，一下就没了，对于产品来说，肯定不能接受；再比如数据的处理，不能重复，或者排序。基于各种需求，自然就产生了各种各样的队列</li>
</ul>
<h2 id="zookeeper"><a class="header-anchor" href="#zookeeper"></a>Zookeeper</h2>
<ul>
<li>这位博客作者真是很有意思，深入浅出而且比较搞笑。口水话和我相似啊。所为光头就能变强，自宫就能成功嘛。(≧∇≦)ﾉ</li>
<li>仍旧参考其系列文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485115&amp;idx=1&amp;sn=5d269f40f820c82b460993669ca6242e&amp;chksm=ebd747badca0ceac9953f82e08b1d1a49498ebd4af77ec5d628a0682bb9f0ac5ab347411f654&amp;token=1741918942&amp;lang=zh_CN#rd" target="_blank" rel="noopener">微信的IP也太长了吧，什么是zookeeper</a></li>
<li><code>zookeeper</code>的功能包括：统一配置管理、统一命名服务、分布式锁、集群管理。这些功能听上去都超超超高大上啊~</li>
<li><code>Zookeeper</code>通过感知节点的变化，已经节点数据的变化来实现以上这些高大上的功能点</li>
<li>集群管理大致有点感觉，既然可以感知节点的变化，那么可以建立相应的临时节点，在有新的集群机器加入的时候。</li>
<li>分布式锁的功能就是说某个带锁的<code>zNode</code>，各个集群机器在访问这个<code>zNode</code>时候，会创建一个临时<code>node</code>，这个临时的节点上面有个带个号码，比如<code>0000001</code>，谁的最小，谁就获得访问这个特殊的<code>znode</code>的权利</li>
<li>统一命名服务有点没看明白，后面再研究吧</li>
</ul>
<h2 id="kafka"><a class="header-anchor" href="#kafka"></a>Kafka</h2>
<p><code>kafka</code>是一个消息队列，这个一句话解释感觉好拉风，一句话就说清楚了</p>
<h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3>
<ul>
<li><code>kafka</code>有以下几个基本概念：
<ul>
<li><code>topic</code>: 作为一个产品，<code>kafka</code>可以有多个消息队列，一个消息队列就是一个<code>topic</code>，有点类似数据库的表。对于一个<code>topic</code>，可以有多个生产者，也可以有多个消费者，这点很好理解。</li>
<li><code>partition</code>：因为一个<code>topic</code>上面会有多个消费者和生产者，所以分成了多个<code>partition</code>，每个生产者往不同的<code>partition</code>上面丢数据。<strong>这边有个问题，为什么要新引入这个概念呢？ 多个<code>topic</code>不行吗？</strong></li>
<li><code>broker</code>：那么<code>kafka</code>是支持分布式的，当然如此，也就是集群。那么集群里面可能就不止一个机器上安装了<code>kafka</code>，每个安装了<code>kafka</code>的机器就称为一个<code>broker</code>。需要注意的是，同一个<code>topic</code>的不同<code>partition</code>可能分布在不同的<code>broker</code>上面</li>
<li><code>replica</code>:大概分布式都要复制吧，不然宕机咋整呢 😉。但是这里需要注意的是，读写都只会对主的<code>partition</code>进行，备份就是备份，老老实实做备份的含义。当主<code>partition</code>在的<code>broker</code>宕机了，会重新选一个主的出来</li>
</ul>
</li>
</ul>
<h3 id="生产者"><a class="header-anchor" href="#生产者"></a>生产者</h3>
<ul>
<li><code>Kafka</code>和<code>Cassandra</code>一样，也是先写到缓存里面，然后再写到磁盘里面。不过<code>Kafka</code>只允许追加写入(顺序访问)，避免缓慢的随机 <code>I/O</code>操作。<strong>这句有点不明白，啥叫追加写入</strong></li>
</ul>
<h3 id="消费者"><a class="header-anchor" href="#消费者"></a>消费者</h3>
<ul>
<li>多个消费者消费同一个<code>topic</code>的可以组成一个消费者组，消费者组里面的消费者可以每个去消费一个<code>partition</code>，这样就提高了吞吐量</li>
<li>正常的读磁盘数据是需要将内核态数据拷贝到用户态的，而<code>Kafka</code> 通过调用<code>sendfile()</code>直接从内核空间（DMA的）到内核空间（Socket的），少做了一步拷贝的操作。昨天有同事部分分享时候说是省略了从磁盘读取。感觉这个说法不对，如果数据已经存储到了磁盘上面，是无法省略从磁盘读取的。这个需要进一步的学习</li>
<li>当消费者组里面一个消费者宕机之后，剩下的消费者需要重新分配，将空缺没有人消费的<code>partition</code>给安排出去。这个过程叫做<code>rebalancing</code>。从<code>kafka</code>的日志里面也能看到这句话</li>
<li>因为需要继续消费没消费完的<code>partition</code>，那么就需要知道之前的消费者消费到哪里了，就引入了偏移量这个概念。</li>
<li>偏移量：<code>offset</code>在<code>broker</code>以内部<code>topic(__consumer_offsets)</code>的方式存储，早期的版本可能存在<code>zookeeper</code>里面</li>
</ul>
<h3 id="kafka和zookeeper"><a class="header-anchor" href="#kafka和zookeeper"></a>Kafka和Zookeeper</h3>
<ul>
<li><code>Zookeeper</code>是<code>Kafka</code>一个重要的依赖。</li>
<li>探测<code>broker</code>和<code>consumer</code>的添加或移除。</li>
<li>负责维护所有<code>partition</code>的领导者/从属者关系（主分区和备份分区），如果主分区挂了，需要选举出备份分区作为主分区。</li>
<li>维护<code>topic、partition</code>等元配置信息</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2020/09/15/how-endpoint-be-connected-into-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2020/09/15/how-endpoint-be-connected-into-network/" class="post-title-link" itemprop="url">how endpoint be connected into network</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-15 17:14:05" itemprop="dateCreated datePublished" datetime="2020-09-15T17:14:05+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-10 16:38:09" itemprop="dateModified" datetime="2020-10-10T16:38:09+08:00">2020-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2020/09/15/how-endpoint-be-connected-into-network/" class="post-meta-item leancloud_visitors" data-flag-title="how endpoint be connected into network" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>这篇博客用来记录运行时的过程，包括：
<ul>
<li>网卡接入网络</li>
</ul>
</li>
</ul>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<p>1）<a href="https://www.cnblogs.com/wade-luffy/p/8548519.html" target="_blank" rel="noopener">局域网的路由器&amp;网卡</a></p>
<h2 id="消息层次"><a class="header-anchor" href="#消息层次"></a>消息层次</h2>
<ul>
<li>从以下的两张图片可以清晰地看到网络的分层，以及对应关系。</li>
<li><code>Ethernet II, Src: HewlettP_2f:87:8f (b0:0c:d1:2f:87:8f), Dst: Broadcast (ff:ff:ff:ff:ff:ff)</code>是数据链路层，以太网，从中能看到<code>MAC地址</code>，并且是一个广播消息</li>
<li><code>Internet Protocol Version 4, Src: 0.0.0.0, Dst: 255.255.255.255</code>, IP数据，能看到源和目的地的IP地址</li>
<li><code>User Datagram Protocol, Src Port: 68, Dst Port: 67</code>, UDP协议，能看到进出端口</li>
<li><code>Bootstrap Protocol (Discover)</code> 最终的协议是<code>DHCP</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_package_wireshark.png" alt="DHCP_package_wireshark"></p>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_package.png" alt="DHCP_package"></p>
<h2 id="设备接入网络"><a class="header-anchor" href="#设备接入网络"></a>设备接入网络</h2>
<ul>
<li>以网卡为例，网卡在出厂时候应该是有<code>MAC地址</code>的，在接入网络时，会按照<code>DHCP</code>协议获取<code>IP</code>地址</li>
</ul>
<h3 id="动态主机配置协议-dhcp-dynamic-host-configuration-protocol"><a class="header-anchor" href="#动态主机配置协议-dhcp-dynamic-host-configuration-protocol"></a>动态主机配置协议 DHCP(Dynamic Host Configuration Protocol)</h3>
<ul>
<li><code>IP</code>地址可以有两种分配方式，一种是静态手动分配一个<code>IP</code>，另外一种就是依赖<code>DHCP 动态主机配置协议</code> 进行动态<code>IP分配</code>。前者称为<code>静态IP地址</code>,后者称为<code>动态IP地址</code></li>
<li><code>DHCP</code>的前身是<code>BOOTP协议 Bootstrap Protocol</code>, <code>wireshark</code>里面过滤时候得用<code>BOOTP</code>来过滤</li>
<li><code>DHCP</code>是应用层的协议，和<code>HTTP</code>,<code>DNS</code>在一层。话说这个层不层的，有点无聊啊，好吧，确实数据是包了一层又一层。</li>
<li><code>DHCP</code>和<code>DNS</code>一样，是架在<code>UDP</code>（<code>UDP</code>是传输层协议）上面的,<code>DHCP</code>协议是工作在端口67和68上面</li>
<li>一次IP分配的交互流程如下图，这是按照第一个参考链接，使用<code>ipconfig /release</code>和<code>ipconfig /renew</code>命令后抓到的包，很是有趣啊。<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP.png" alt="DHCP握手"></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_wireshark.png" alt="DHCP_wireshark"></p>
<ul>
<li>
<p>在第一条<code>discover</code>信息里面，可以看到客户端从<code>0.0.0.0</code>的端口<code>68</code>往服务器端的<code>255.255.255.255</code>的端口<code>67</code>发了一条<code>Boot request</code>信息，同时也可以看出来，这条消息在传输层是<code>UDP</code>协议<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_discovery.png" alt="DHCP_discovery"></p>
</li>
<li>
<p>第二条消息是<code>offer</code>消息：</p>
<ul>
<li>里面带了客户端的<code>IP地址</code>，用<code>ipconfig</code>命令来看，也确实是当前我的<code>laptop</code>的<code>IP地址</code>。</li>
<li>这点和第一个参考链接里面的不一样，我自己抓的<code>offer</code>信息，是直接发往当前的<code>client IP</code>地址的，而链接里面的，仍旧是一个广播消息，是发往<code>0.0.0.0</code>的。似乎后者更为合理，毕竟这个时候，有可能有多个客户端在请求。</li>
<li>同时，在<code>(54)</code>消息里面告诉对方自己是个<code>DHCP</code>服务器，毕竟一个局域网中可以存在多个<code>DHCP</code>服务器</li>
<li>在这条消息中，同时包含了子网掩码和<code>DNS</code>服务器<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_offer.png" alt="DHCP_offer"></li>
</ul>
</li>
<li>
<p>第三条消息仍旧是一条广播消息，客户端并没有在此时就使用分配的<code>IP</code>地址，而是在这条消息里面告诉服务器端，它要开始使用这个地址了<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_request.png" alt="DHCP_request"></p>
</li>
<li>
<p>最后一条服务器<code>ACK</code>消息里面，有<code>IP租用时间</code>，<strong><em>为啥我的这个值只有一小时啊</em></strong></p>
<ul>
<li>通常租借期应该是一天，然后在时间到了一半的时候，客户端会给服务器端发续接消息<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/DHCP_ACK.png" alt="DHCP_ACK"></li>
</ul>
</li>
<li>
<p><code>DHCP starvation attack</code>：这应该是网络安全范畴了，假设用许多假的客户端给服务器发消息，可以占用满所有<code>IP地址</code>，然后可以冒充服务器，给客户端回消息</p>
</li>
<li>
<p><code>DHCP中继</code>： <code>DHCP</code>是一个局域网的协议，当客户端和服务器端不在一个局域网中，就需要用到<code>DHCP中继</code>，在参考链接<code>4和5</code>里面，有描述细节</p>
</li>
<li>
<p>参考链接<br>
1） <a href="https://blog.csdn.net/u012359618/article/details/51872678" target="_blank" rel="noopener">DHCP详解</a><br>
2） <a href="https://zhuanlan.zhihu.com/p/89446304" target="_blank" rel="noopener">DHCP详解2</a><br>
3） <a href="https://zhuanlan.zhihu.com/netops" target="_blank" rel="noopener">知乎找到一个很好的专栏，确实需要系列文章，但是怎么系列，有点难度啊：计算机网络学习笔记</a><br>
4） <a href="https://zhuanlan.zhihu.com/p/152330355" target="_blank" rel="noopener">简述DHCP和DNS</a><br>
5） <a href="https://zhuanlan.zhihu.com/p/109846848" target="_blank" rel="noopener">详解什么是DHCP，DHCP的工作原理</a></p>
</li>
</ul>
<h2 id="设备发消息"><a class="header-anchor" href="#设备发消息"></a>设备发消息</h2>
<h3 id="arp-address-resolution-protocol-地址解析协议"><a class="header-anchor" href="#arp-address-resolution-protocol-地址解析协议"></a>ARP（Address Resolution Protocol）地址解析协议</h3>
<ul>
<li>一个网络设备在分配到<code>IP地址</code>之后，就算是加入到网络里面了。</li>
<li>这时候它要发消息给另一个设备，比如百度，那么需要<code>DNS</code>服务器，将这个域名转换为<code>IP地址</code></li>
<li>假设<code>DNS</code>域名服务器并不在同一个局域网里面，那么就需要路由器将这条消息转发到另一个局域网中。</li>
<li>那么，如何找到路由器呢？ 我们在<code>DHCP</code>协议接入时候,确实是有<code>DNS</code>的<code>IP</code>地址，但是知道<code>IP</code>地址，并没有办法进行直接通信</li>
<li>所以,<code>ARP</code>协议的第一步是广播找到路由器或者无线路由器。</li>
<li>用<code>wireshark</code>抓包，很有意思的是，我自己的笔记本隔一阵就会寻找一个特定的<code>IP</code>，发出广播消息，这个包没抓下来。</li>
<li>抓了一个包,呃，<code>MAC</code>全网唯一，就涂掉了</li>
<li>在广播之后就是简单的问答<br>
<img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/ARP_wireshark.png" alt="ARP_wireshark"></li>
<li>参考链接：
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/28771785" target="_blank" rel="noopener">知乎专栏，图解ARP协议</a></li>
</ol>
</li>
</ul>
<h3 id="nat-network-address-translation-协议"><a class="header-anchor" href="#nat-network-address-translation-协议"></a>NAT（Network Address Translation）协议</h3>
<ul>
<li>通过将内部网络的私有IP地址翻译成全球唯一的公网IP地址，使内部网络可以连接到互联网等外部网络上。</li>
<li><code>NAT</code>可以分为以下几种：
<ul>
<li>静态转换（Static Translation）：一个公网IP对应一个私有IP，并且只有<code>IP</code>转换，不涉及端口</li>
<li>动态转换（Dynamic Translation）：这个介绍得比较少，实际就是说局域网有多个公有IP地址，并不和局域网内部私有IP地址进行一一绑定。而是动态分配</li>
<li>端口多路复用（Port Address Translation,PAT），网络地址端口转换NAPT（Port-Level NAT），<strong><em>这个和上面的是一个吗？应该是一个</em></strong> NAPT不但要转换IP地址，还要进行传输层的端口转换，对外只有一个公网IP，通过端口来区别不同私有IP主机的数据。这种才是最常用的一种</li>
</ul>
</li>
<li>会看到内部局部地址、外部局部地址、内部全局地址、外部全局地址的说法，其实就是源的私有IP地址，目标的私有IP地址，源的公有IP地址和目标的公有IP地址</li>
<li><code>NAT</code>有个映射记录表，对没有相应记录的数据包进行拒绝，提高了网络安全性。这就是说为什么<code>NAT</code>有安全性；对于<code>NAPT</code>来说，<code>NAT</code>转换表里面是“某个网卡私有IP：端口 -&gt; 网关路由器的公有IP：端口”，相当于局域网的设备都共享一个公有IP地址，然后订住网关路由器的一个端口。</li>
<li><code>NAT</code>的弊端是很明显的，降低效率是肯定的，有一些协议不支持<code>NAT</code>。 <strong><em>这一点需要后续持续学习</em></strong></li>
<li>参考链接：
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35548780" target="_blank" rel="noopener">网络地址转换NAT:包含配置命令，看这一篇可能就可以了</a></li>
<li><a href="https://www.zhihu.com/question/31332694" target="_blank" rel="noopener">NAT转换是怎么工作的？知乎问答</a></li>
<li><a href="https://blog.csdn.net/hzhsan/article/details/45038265" target="_blank" rel="noopener">网络地址转换NAT原理</a></li>
<li><a href="https://www.cnblogs.com/syfwhu/p/5229020.html" target="_blank" rel="noopener">网络协议之NAT穿透</a></li>
</ul>
</li>
</ul>
<h3 id="iptables"><a class="header-anchor" href="#iptables"></a>Iptables</h3>
<h4 id="iptables-简述"><a class="header-anchor" href="#iptables-简述"></a>Iptables 简述</h4>
<ul>
<li><code>Iptables</code>的实质是一种防火墙，是基于<code>Netfilter</code>实现的。</li>
<li><code>Netfilter</code>，在<code>Linux</code>內核中的一個軟體框架，用於管理網路封包。不僅具有網路位址轉換（<code>NAT</code>）的功能，也具備封包內容修改、以及封包過濾等防火牆功能。<a href="https://zh.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter维基百科</a>
<ul>
<li><code>Netfilter</code> 框架提供了一些内核的<code>hook</code>，这些协议栈内有包过滤功能的<code>hook</code>，<code>hook</code>也就构成了<code>netfilter</code>框架</li>
<li>程序可以通过注册<code>hook</code>函数来在封装包的关键路径上面进行处理，实现各种规则</li>
<li><code>netfilter</code>组件也称为内核空间（<code>kernelspace</code>），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</li>
<li><code>iptables</code>组件是一种工具，也称为用户空间（<code>userspace</code>），它使插入、修改和除去信息包过滤表中的规则变得容易。<a href="https://www.cnblogs.com/Dicky-Zhang/p/5904429.html" target="_blank" rel="noopener">超级详细的iptable教程文档</a></li>
</ul>
</li>
<li>所以，其实<code>Iptables</code>只是定义了各种规则，是各种规则的集合。真正在干活的其实是<code>netfilter</code>的<code>hook</code></li>
<li><code>Iptables</code>按照功能分为多个Table， 每个Table里面的每一条规则称为<code>Chain</code>。
<ul>
<li>内置的<code>chain</code>是由内置的<code>hook</code>触发的</li>
<li>所以<code>Chain</code>基本和<code>Hook</code>是一一对应的</li>
<li><code>PREROUTING</code>: 由<code>NF_IP_PRE_ROUTING hook</code>触发，负责刚刚到的包，包经过<code>PRETOUTING chain</code>之后，将进行路由判断。</li>
<li><code>INPUT</code>: 由<code>NF_IP_LOCAL_IN hook</code>触发</li>
<li><code>FORWARD</code>: 由<code>NF_IP_FORWARD hook</code>触发</li>
<li><code>OUTPUT</code>: 由<code>NF_IP_LOCAL_OUT hook</code>触发</li>
<li><code>POSTROUTING</code>: 由<code>NF_IP_POST_ROUTING hook</code>触发</li>
</ul>
</li>
</ul>
<h4 id="iptables-tables"><a class="header-anchor" href="#iptables-tables"></a>Iptables Tables</h4>
<ul>
<li><code>Iptables</code>将它的规则组织在表里面，常见的有这几种：<code>NAT, FILTER, MANGLE , RAW &amp; SECURITY</code></li>
<li><code>filter</code>这是最常见的，就是过滤包，起到防火墙的作用</li>
<li><code>NAT</code>就是何修改包的源/目的地址，这里和协议感觉还有一些不一样</li>
<li><code>MANGLE</code>可以修改包的<code>IP头</code>。包括很多参数。</li>
<li><code>RAW</code>这种包，有点类似匿名功能啊，就是不被<code>Iptables</code>知道这个包有通过过.一但使用了<code>RAW</code>表,在某个链上,<code>RAW</code>表处理完后,将跳过<code>NAT</code>表和<code>ip_conntrack</code>处理,即不再做地址转换和数据包的链接跟踪处理了。</li>
<li><code>Security</code>给包打上<code>SELinux</code>标记，没有仔细了解，和<code>Linux</code>的安全机制有关</li>
</ul>
<h4 id="iptables-chain"><a class="header-anchor" href="#iptables-chain"></a>Iptables Chain</h4>
<ul>
<li>并不是每个表里面有每种链，这点很好理解，因为链和表功能不搭，肯定就放不进去了</li>
<li>画表格貌似失败了，只能截屏一张图片，来自参考链接1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/Iptables_table_chain.png" alt="Tables &amp;amp; Chains"></p>
<h4 id="how-packages-be-routed"><a class="header-anchor" href="#how-packages-be-routed"></a>How Packages be routed</h4>
<ul>
<li>
<p>中文文档这里翻译得不是太好。表格还换了个格式，明显原始的更清楚啊</p>
</li>
<li>
<p>一个包会不会触发<code>netfilter</code>里面的<code>hook</code>，取决于好些因素，假设没有被filter表过滤掉的话，那么会按照以下规则触发：</p>
<ul>
<li>收到的、目的是本机的包：<code>PRETOUTING -&gt; INPUT</code></li>
<li>收到的、目的是其他主机的包：<code>PRETOUTING -&gt; FORWARD -&gt; POSTROUTING</code></li>
<li>本地产生的包：<code>OUTPUT -&gt; POSTROUTING</code>,同样会经过<code>PRETOUTING</code> 和 <code>INPUT</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/network/Iptables_process.png" alt="Iptable"></p>
</li>
<li>
<p>今天做分享时候这块说得不清楚，几张图片结合起来，其实是很清晰的。</p>
</li>
</ul>
<h4 id="iptables-操作"><a class="header-anchor" href="#iptables-操作"></a>Iptables 操作</h4>
<ul>
<li>
<p>netfilter 框架会对设置的每条一条（出向或入向）规则，自动设置它的反向规则，因此我们只需要设 置一个方向的规则即可。</p>
</li>
<li>
<p>命令格式：</p>
<pre><code># Abstract structure of an iptables instruction:
iptables [-t table] command [match pattern] [action]
</code></pre>
</li>
<li>
<p>选项:</p>
<pre><code>-P  --policy        &lt;链名&gt;  定义默认策略
-L  --list          &lt;链名&gt;  查看iptables规则列表 
-A  --append        &lt;链名&gt;  在规则列表的最后增加1条规则 
-I  --insert        &lt;链名&gt;  在指定的位置插入1条规则
-D  --delete        &lt;链名&gt;  从规则列表中删除1条规则
-R  --replace       &lt;链名&gt;  替换规则列表中的某条规则 
-F  --flush         &lt;链名&gt;  删除表中所有规则 
-Z  --zero          &lt;链名&gt;  将表中数据包计数器和流量计数器归零 
-X  --delete-chain  &lt;链名&gt;  删除自定义链 
-v  --verbose       &lt;链名&gt;  与-L他命令一起使用显示更多更详细的信息
</code></pre>
</li>
<li>
<p>执行指令有：<code>ACCEPT、REJECT、DROP、REDIRECT 、MASQUERADE</code>以外，还多出<code>LOG、ULOG、DNAT、RETURN、TOS、SNAT、MIRROR、QUEUE、TTL、MARK</code>等</p>
<pre><code>SNAT - 修改源IP为固定新IP（静态）, SNAT只对离开路由器的包有意义，因此它只用在POSTROUTING chain中

MASQUERADE - 修改源IP为动态新IP（动态获取网络接口 IP）和SNAT一样，MASQUERADE只对POSTROUTING chain有意义，伪装数据包，例如将 源地址修改为路由器地址。因此如果接口的IP地址发送了变化，MASQUERADE规则不受影响，可以正常工作；而对于SNAT就必须重新调整规则。

DNAT - 修改目的IP，必须在做路由决策之前，因此DNAT 适用于PRETOUTING和OUTPUT（本地生成的包）

REDIRECT - DNAT的一个特殊场景将包重定向到本机另一个端口,重定向到路由器的另一个本地端口，适用于PRETOUTING和OUTPUT chain
</code></pre>
</li>
</ul>
<h4 id="参考链接-v2"><a class="header-anchor" href="#参考链接-v2"></a>参考链接</h4>
<ol>
<li><a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">深入理解IpTables和Netfilter： 这篇比较好，这回的主要参考，里面也有Netfilter几种hook的介绍</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">上一篇参考链接的英文原文</a><br>
3） <a href="http://arthurchiao.art/blog/nat-zh/" target="_blank" rel="noopener">NAT - 网络地址转换</a></li>
</ol>
<h4 id="实际操作配置"><a class="header-anchor" href="#实际操作配置"></a>实际操作配置</h4>
<ul>
<li>实际操作暂时没时间，也有点兴趣缺缺<br>
参考链接：
<ol>
<li><a href="http://www.ttlsa.com/linux/iptables-router-acl/" target="_blank" rel="noopener">iptables作为路由器实现上网和访问控制</a></li>
<li><a href="https://www.cnblogs.com/linuxws/p/10924817.html" target="_blank" rel="noopener">Iptables-linux服务器做路由转发</a></li>
<li><a href="https://blog.csdn.net/beanewself/article/details/77435208?utm_medium=distribute.pc_relevant.none-task-blog-title-3&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">Linux下搭建路由器</a></li>
</ol>
</li>
</ul>
<h3 id="虚拟网络"><a class="header-anchor" href="#虚拟网络"></a>虚拟网络</h3>
<ul>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2020/02/11/K8s-Ingress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2020/02/11/K8s-Ingress/" class="post-title-link" itemprop="url">K8s Ingress</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-11 10:42:55" itemprop="dateCreated datePublished" datetime="2020-02-11T10:42:55+08:00">2020-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-23 13:22:05" itemprop="dateModified" datetime="2020-10-23T13:22:05+08:00">2020-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2020/02/11/K8s-Ingress/" class="post-meta-item leancloud_visitors" data-flag-title="K8s Ingress" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ingress"><a class="header-anchor" href="#ingress"></a>Ingress</h2>
<ul>
<li><em>Ingress enables externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting for a Kubernetes cluster.</em></li>
<li>通常情况下，<code>service</code>和<code>pod</code>的<code>IP</code>仅可在集群内部访问。集群外部的请求需要通过负载均衡转发到<code>service</code>在<code>Node</code>上暴露的<code>NodePort</code>上，然后再由<code>kube-proxy</code>将其转发给相关的<code>Pod</code>。而<code>Ingress</code>就是为进入集群的请求提供路由规则的集合</li>
<li>用<code>NodePort</code>来暴露服务的时候， <code>IP</code>可能会漂移，并且，如果服务太多的话，会有混乱，为此引入了<code>ingress</code>，使用<code>hostname</code>来避免这个问题。</li>
<li>可以认为<code>Ingress</code>包含两个组件：<code>ingress controller</code>和<code>ingress</code></li>
<li>参考链接：
<ul>
<li><a href="https://www.kubernetes.org.cn/ingress" target="_blank" rel="noopener">官方文档 名词解释：Ingress</a></li>
</ul>
</li>
</ul>
<h3 id="ingress-controller"><a class="header-anchor" href="#ingress-controller"></a>Ingress Controller</h3>
<ul>
<li>
<p><code>ingress controller</code>目前主要有两种：基于<code>nginx</code>服务的<code>ingress controller</code>和基于<code>traefik</code>的<code>ingress controller</code>。</p>
<ul>
<li><code>traefik</code>的<code>ingress controller</code>，目前支持<code>http</code>和<code>https</code>协议。</li>
<li>而<code>nginx</code>可以支持<code>TCP</code>负载,但是目前<code>k8s</code>仅仅支持<code>HTTP</code>和<code>HTTPS</code></li>
<li>我们产品里面目前使用的也是<code>nginx</code>。</li>
</ul>
</li>
<li>
<p><code>ingress controller</code>会将新加入的<code>Ingress</code>转化成<code>Nginx</code>的配置文件并使之生效</p>
</li>
<li>
<p>通常会单独安装在一个<code>namespace</code>里面，比如<code>nginx-inigress</code>里面。</p>
</li>
<li>
<p>配套会有一些部署，解释如下：</p>
<ul>
<li><code>Deployment</code>:<code>default-http-backend</code>,对应有同名的<code>service</code>.如果外界访问的域名不存在的话，则默认转发到<code>default-http-backend</code>这个<code>service</code>，会返回404</li>
</ul>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.jianshu.com/p/feeea0bbd73e" target="_blank" rel="noopener">从零开始搭建K8s</a></li>
<li><a href="https://www.ilanni.com/?p=14501" target="_blank" rel="noopener">k8s安装与配置ingress(一)</a>: 文档写得真心不错，格式实在太烂了，看得眼睛疼</li>
<li><a href="https://www.cnblogs.com/justmine/p/8991379.html" target="_blank" rel="noopener">详解k8s组件Ingress边缘路由器并落地到微服务 - kubernetes</a></li>
</ul>
</li>
</ul>
<h3 id="ingress-yaml-file"><a class="header-anchor" href="#ingress-yaml-file"></a>Ingress YAML FILE</h3>
<ul>
<li><code>Ingress.yaml</code>里面的信息不可能完全列这里，有以下一些元素和类型</li>
</ul>
<h3 id="ingress-rule"><a class="header-anchor" href="#ingress-rule"></a>Ingress Rule</h3>
<ul>
<li>还有个<code>ingress-rules</code>的yaml文件。里面的内容如下：
<ul>
<li><code>Kind</code>: <code>Ingress</code> 这个<code>rule</code>规则，哪个<code>endPoint</code>进哪个<code>deployment</code></li>
<li>每个<code>Ingress</code>都需要配置<code>rules</code>，目前<code>Kubernetes</code>仅支持<code>http</code>规则。所以最关键的就是<code>rule</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2020/01/09/Linux-Command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2020/01/09/Linux-Command/" class="post-title-link" itemprop="url">Linux Command</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-09 09:43:08" itemprop="dateCreated datePublished" datetime="2020-01-09T09:43:08+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-30 14:46:33" itemprop="dateModified" datetime="2020-10-30T14:46:33+08:00">2020-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2020/01/09/Linux-Command/" class="post-meta-item leancloud_visitors" data-flag-title="Linux Command" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作多年，<code>Linux</code>命令是时不时要用到的。每次都是百度之（虽然不是真的用的百度:P），记录在这里，省得每次还得去找</p>
<h2 id="awk"><a class="header-anchor" href="#awk"></a>AWK</h2>
<ul>
<li><a href="https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html" target="_blank" rel="noopener">linux awk命令详解</a></li>
<li><a href="https://www.cnblogs.com/dakewei/p/9848176.html" target="_blank" rel="noopener">使用awk分割字符串并且获取分割后的最后一个字符串</a></li>
</ul>
<h3 id="example"><a class="header-anchor" href="#example"></a>Example</h3>
<p><code>awk</code> 其实是读入一行，进行查找，再进行操作。可以集合<code>SED</code>和<code>GREP</code>的作用。下面用例子来说明问题</p>
<ul>
<li><code>awk -F'-' '{print $1}'</code>
<ul>
<li>用<code>-</code>做分隔符，然后将<code>-</code>分隔之后的第一列数据输出出来。</li>
<li>如果有版本，比如<code>2.0.1-SNAPSHOT</code>,这个语句就可以得到`2.0.``</li>
</ul>
</li>
<li><code>echo &quot;you-me-he&quot; |awk -F '[-]' '{print $NF}'</code>
<ul>
<li>这条命令是用<code>-</code>分隔之后，打印分隔后的最后一个字符，所以输出<code>he</code></li>
</ul>
</li>
</ul>
<h2 id="curl"><a class="header-anchor" href="#curl"></a>CURL</h2>
<ul>
<li>
<p><a href="https://www.cnblogs.com/duhuo/p/5695256.html" target="_blank" rel="noopener">Linux curl命令详解</a></p>
</li>
<li>
<p><code>curl</code>命令作用广泛，可以作为传输工具使用，我们在产品中也经常用来判断一个<code>URL</code>是否可连接</p>
</li>
</ul>
<h3 id="实例"><a class="header-anchor" href="#实例"></a>实例</h3>
<ul>
<li><code>curl -o linux.html http://www.linux.com</code>： 保存网页，在我们的产品中，使用这种形式进行了文件下载</li>
</ul>
<h2 id="判断文件"><a class="header-anchor" href="#判断文件"></a>判断文件</h2>
<ul>
<li><a href="https://www.cnblogs.com/37yan/p/6962563.html" target="_blank" rel="noopener">shell判断文件存在</a></li>
</ul>
<h3 id="实例-v2"><a class="header-anchor" href="#实例-v2"></a>实例</h3>
<ul>
<li>
<p>判断文件存在与否</p>
<p>if [ ! -f “/data/filename” ];then<br>
echo &quot;文件不存在&quot;<br>
else<br>
rm -f /data/filename<br>
fi</p>
</li>
<li>
<p>判断目录存在与否：将<code>-f</code>换成<code>-d</code></p>
</li>
</ul>
<pre><code>if [ -d &quot;/data/&quot; ];then
echo &quot;文件夹存在&quot;
else
echo &quot;文件夹不存在&quot;
fi
</code></pre>
<h2 id="字符串操作"><a class="header-anchor" href="#字符串操作"></a>字符串操作</h2>
<h3 id="字符串连接"><a class="header-anchor" href="#字符串连接"></a>字符串连接</h3>
<ul>
<li>直接写在一起就可以了</li>
</ul>
<h2 id="生成随机密码"><a class="header-anchor" href="#生成随机密码"></a>生成随机密码</h2>
<h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/EasonJim/p/9041957.html" target="_blank" rel="noopener">Linux下生成随机密码</a></li>
</ul>
<h3 id="实例-v3"><a class="header-anchor" href="#实例-v3"></a>实例</h3>
<ul>
<li><code>date +%s |sha256sum |base64 |head -c 32 ;echo</code> 这样的话说是根据当前时间来算的。所以安全性其实很高啊</li>
</ul>
<h2 id="截取字符串的方法"><a class="header-anchor" href="#截取字符串的方法"></a>截取字符串的方法</h2>
<ul>
<li><a href="https://www.jb51.net/article/56563.htm" target="_blank" rel="noopener">Shell脚本8种字符串截取方法总结</a></li>
</ul>
<h3 id="实例-v4"><a class="header-anchor" href="#实例-v4"></a>实例</h3>
<ul>
<li><code>var=http://www.aaa.com/123.htm</code></li>
<li><code>echo ${var#*//}</code>
<ul>
<li><code>#</code> 号是运算符，<code>*//</code> 表示从左边开始删除第一个 <code>//</code> 号及左边的所有字符</li>
<li>所以这样的话会将<code>http://</code>都给删除掉</li>
</ul>
</li>
<li><code>echo ${var##*/}</code>
<ul>
<li><code>##</code>是运算符指最后一个，<code>*/</code>表示<code>/</code>和<code>/</code>左边的所有字符。所以一个<code>#</code>是第一个，两个是最后一个。</li>
<li>这句话会删除最后一个<code>/</code>以及左边的字符， 结果只留下了<code>123.htm</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/12/06/%E5%90%84%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/12/06/%E5%90%84%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">Problems During Working</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 13:53:11" itemprop="dateCreated datePublished" datetime="2019-12-06T13:53:11+08:00">2019-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-10 10:17:50" itemprop="dateModified" datetime="2020-12-10T10:17:50+08:00">2020-12-10</time>
              </span>

          
            <span id="/hexo_blog/2019/12/06/%E5%90%84%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="post-meta-item leancloud_visitors" data-flag-title="Problems During Working" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开个新博客，来记录工作过程中碰到的各种各类的小问题。</p>
<h2 id="windows"><a class="header-anchor" href="#windows"></a>Windows</h2>
<h3 id="端口被占用"><a class="header-anchor" href="#端口被占用"></a>端口被占用</h3>
<ul>
<li><code>netstat -aon|findstr &quot;8081&quot;</code>，查看占用端口<code>8081</code>的进程</li>
<li><code>tasklist|findstr &quot;9088&quot;</code>，查看进程是哪个应用</li>
<li><code>taskkill /T /F /PID 9088</code> 杀死这个进程</li>
</ul>
<h2 id="env"><a class="header-anchor" href="#env"></a>ENV</h2>
<p>这个章节主要是包括编译啊，版本控制啊，IDE啊之类的小问题</p>
<h3 id="soapui"><a class="header-anchor" href="#soapui"></a>SoapUI</h3>
<ul>
<li>工作里面一般用<code>soapUI</code>来发送请求。之前一直发送的是<code>WSDL</code>的，也就是<code>XML</code>格式。</li>
<li>现在流行<code>REST</code>，昨天尝试了一天也没成功啊。OMG 😦</li>
<li>对应于<code>WSDL</code>的是<code>WADL</code>，用于导入<code>HTTP</code>的请求。但是坑爹的是我们代码里面没有。尝试了以下两种方式：
<ul>
<li>从<code>WSDL</code>转换成为<code>WADL</code>也是可行的。有一个小的工具搜索到： <a href="https://sourceforge.net/p/tinywsdl/wiki/wsdl11/" target="_blank" rel="noopener">tinywsdl</a>,但是可能是<code>WADL</code>不是那么流行，需要写代码来转换。</li>
<li>另一种方式要简单直接很多，就是<code>soapUI</code>的<code>import swagger</code>功能，直接右键就能看到。从<code>swagger</code>网站上面也可以导出生成<code>yaml</code>或者<code>json</code>文件。</li>
<li>不幸的是，遇到了这个错误：<a href="https://github.com/SmartBear/readyapi-swagger-plugin/issues/3" target="_blank" rel="noopener"><br>
error on creating project out of swagger spec<br>
</a></li>
<li>完全一致，<code>JSON</code>的格式报版本问题，<code>YAML</code>的格式报<code>null</code></li>
<li>按照上述网页，应该是<code>swagger</code>插件只能支持字符串格式。然鹅，我的文件里面好多不是字符串的。只能最终放弃了。</li>
</ul>
</li>
</ul>
<h3 id="ij"><a class="header-anchor" href="#ij"></a>IJ</h3>
<h4 id="command-too-long-error"><a class="header-anchor" href="#command-too-long-error"></a>command too long error</h4>
<ul>
<li>
<p>今天尝试跑Junit，结果IJ报错，说我命令行太长：</p>
<pre><code>Error running 'xxxxxxx': Command line is too long. Shorten command line for xxxxxxx or also for JUnit default configuration.
</code></pre>
</li>
<li>
<p>解决方法是在Run…的配置里面，有一个<code>shorten command line</code>选项，选成<code>classpath file</code>，这样就可以了。</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.jetbrains.com/idea/2017/10/intellij-idea-2017-3-eap-configurable-command-line-shortener-and-more/" target="_blank" rel="noopener">configurable-command-line-shortener</a></li>
<li><a href="https://stackoverflow.com/questions/47926382/how-to-configure-shorten-command-line-method-for-whole-project-in-intellij/47927544" target="_blank" rel="noopener">how-to-configure-shorten-command-line</a></li>
</ul>
</li>
</ul>
<h4 id="output-path-same"><a class="header-anchor" href="#output-path-same"></a>Output path same</h4>
<ul>
<li>编译<code>scala</code>项目的时候报的错误。意思是输出路径一样。改一下<code>module</code>的输出路径就可以了。奇怪的是，为啥会一样啊。</li>
<li><a href="https://stackoverflow.com/questions/18920334/output-path-is-shared-between-the-same-module-error/21418406#21418406" target="_blank" rel="noopener">output-path-is-shared</a></li>
</ul>
<h4 id="error-failed-to-load-project-configuration-cannot-parse-file-xxx-idea-workspace-xml-parseerror-at-row-col-1-1-message-content-is-not-allowed-in-prolog"><a class="header-anchor" href="#error-failed-to-load-project-configuration-cannot-parse-file-xxx-idea-workspace-xml-parseerror-at-row-col-1-1-message-content-is-not-allowed-in-prolog"></a>Error:Failed to load project configuration: cannot parse file xxx.idea\workspace.xml: ParseError at [row,col]:[1,1] Message: Content is not allowed in prolog.</h4>
<ul>
<li>大致含义就是这个文件坏了按照stackoverflow上面的，先删除这个文件，再点击“ started 'Invalid Caches/Restart&quot; under “File”.”就可以解决问题了</li>
<li><a href="https://stackoverflow.com/questions/29604148/workspace-xml-file-corrupted-error-on-line-1-content-is-not-allowed-in-prolog" target="_blank" rel="noopener">workspace-xml-file-corrupted</a></li>
</ul>
<h3 id="git"><a class="header-anchor" href="#git"></a>GIT</h3>
<h4 id="filename-too-long-error"><a class="header-anchor" href="#filename-too-long-error"></a>filename too long error</h4>
<ul>
<li>改一下<code>GIT</code>的配置就可以了</li>
<li><code>git config --system core.longpaths true</code></li>
<li><a href="https://ourcodeworld.com/articles/read/109/how-to-solve-filename-too-long-error-in-git-powershell-and-github-application-for-windows" target="_blank" rel="noopener">how-to-solve-filename-too-long-error</a></li>
</ul>
<h3 id="vim"><a class="header-anchor" href="#vim"></a>VIM</h3>
<h4 id="全局替换"><a class="header-anchor" href="#全局替换"></a>全局替换</h4>
<ul>
<li><code>:%s/vivian/sky/g</code>: 替换每一行中所有<code>vivian</code> 为<code>sky</code></li>
<li><a href="http://blog.sina.com.cn/s/blog_736f1c59010136ry.html" target="_blank" rel="noopener">vim替换变量</a></li>
</ul>
<h2 id="java"><a class="header-anchor" href="#java"></a>Java</h2>
<h3 id="mock"><a class="header-anchor" href="#mock"></a>Mock</h3>
<h4 id="checked-exception-is-invalid-for-this-method"><a class="header-anchor" href="#checked-exception-is-invalid-for-this-method"></a>Checked exception is invalid for this method!</h4>
<ul>
<li>用<code>thenThrow</code>时候报了这个错误，这个错误的含义其实是调用的函数并没有抛出模拟的这个函数，所以模拟不起来</li>
<li>我自己是因为在<code>scala</code>里面外面包了一层</li>
</ul>
<h2 id="cassandra"><a class="header-anchor" href="#cassandra"></a>Cassandra</h2>
<h3 id="cassandra-was-never-started"><a class="header-anchor" href="#cassandra-was-never-started"></a>Cassandra was never started</h3>
<ul>
<li>这个问题是在解决POD不断重启的问题的过程中遇到的。</li>
<li>问题的根源其实就是Cassandra的版本被替换了，用户和密码也换掉了</li>
<li>参考链接：
<ul>
<li>
<p><a href="https://docs.datastax.com/en/developer/java-driver/3.1/manual/custom_codecs/extras/" target="_blank" rel="noopener">time codecs</a></p>
<p>2020-03-26 10:39:08,280+0100 [vent Dispatcher] WARN  [com.datastax.driver.core.CodecRegistry] Ignoring codec InstantCodec [timestamp &lt;-&gt; java.time.Instant] because it collides with previously registered codec InstantCodec [timestamp &lt;-&gt; java.time.Instant]</p>
</li>
</ul>
</li>
</ul>
<h2 id="docker"><a class="header-anchor" href="#docker"></a>Docker</h2>
<h3 id="docker-login"><a class="header-anchor" href="#docker-login"></a>docker login</h3>
<pre><code> $ docker login XXXXX
    Authenticating with existing credentials...
    Stored credentials invalid or expired
    Error: Cannot perform an interactive login from a non TTY device
</code></pre>
<ul>
<li>这是由于密码更换了之后原有密码不对造成的问题。加个<code>-u username -p password</code>就能够解决</li>
<li>也可以设置环境变量来解决<code>DOCKER_USERNAME DOCKER_PASSWORD</code></li>
<li>参考链接： <a href="https://community.atlassian.com/t5/Bitbucket-questions/Piplenes-docker-login-can-not-perform-an-interactive-login-from/qaq-p/595736" target="_blank" rel="noopener">docker login can not perform an interactive login from a non TTY</a></li>
</ul>
<h3 id="docker-demon"><a class="header-anchor" href="#docker-demon"></a>docker demon</h3>
<pre><code>error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.25/version: open //./pipe/docker_engine: The system cannot find the file
specified. In the default daemon configuration on Windows, the docker client must be run elevated to connect. This error may also indicate that the docker daemon is not running.
</code></pre>
<ul>
<li><code>&quot;C:\Program Files\Docker\Docker\DockerCli.exe&quot; -SwitchDaemo</code></li>
<li>并没有研究原理啦</li>
<li>参考链接：<a href="https://stackoverflow.com/questions/40459280/docker-cannot-start-on-windows" target="_blank" rel="noopener">docker cannot start on windows</a></li>
</ul>
<h3 id="docker-image-没有名字"><a class="header-anchor" href="#docker-image-没有名字"></a>docker image 没有名字</h3>
<ul>
<li>
<p><code>docker build</code>出来的<code>image</code>没有名字，需要在命令行指定</p>
<pre><code>docker build -t image_name
</code></pre>
</li>
<li>
<p>参考链接</p>
<ul>
<li><a href="https://stackoverflow.com/questions/38986057/how-to-set-image-name-in-dockerfile" target="_blank" rel="noopener">how-to-set-image-name-in-dockerfile</a></li>
</ul>
</li>
</ul>
<h3 id="docker-for-desktop-安装"><a class="header-anchor" href="#docker-for-desktop-安装"></a>docker for desktop 安装</h3>
<ul>
<li>安装时候一直提示<code>dockerd</code>文件被<code>windows event log</code>占用了。但是按照各种<code>windows</code>的方法都找不到，最后从<code>gitbash</code>强制删除掉文件再安装就好了。</li>
</ul>
<h3 id="docker-for-desktop-如何安装dashboard"><a class="header-anchor" href="#docker-for-desktop-如何安装dashboard"></a>docker for desktop 如何安装Dashboard</h3>
<ul>
<li>安装<code>k8s</code>的<code>dashboard</code>：
<ul>
<li>使用“docker for desktop“的时候，这个<code>dashboard</code>貌似不是事先装好的。印象不深刻了。需要装一下：</li>
<li><code>kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</code></li>
<li><code>kubectl proxy</code> 再将<code>proxy</code>给弄出来，就可以访问了。</li>
<li>如下图：<br>
<img src="https://user-images.githubusercontent.com/5803001/34945022-c57b369a-fa3c-11e7-85e7-83f716d10705.png" alt=""></li>
<li>参考链接登录：
<ul>
<li><a href="https://segmentfault.com/a/1190000012850396" target="_blank" rel="noopener">config登录方式</a></li>
<li><a href="https://www.cnblogs.com/guigujun/p/8366530.html" target="_blank" rel="noopener">config登录方式2</a></li>
<li><a href="https://www.cnblogs.com/jackyfei/p/10180465.html" target="_blank" rel="noopener">token方式登录</a></li>
</ul>
</li>
<li>获取token的命令：<code>kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')</code></li>
</ul>
</li>
</ul>
<h2 id="k8s"><a class="header-anchor" href="#k8s"></a>K8S</h2>
<h3 id="连不上k8s"><a class="header-anchor" href="#连不上k8s"></a>连不上K8S</h3>
<pre><code>$ kubectl cluster-info
Kubernetes master is running at ...
To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)
</code></pre>
<ul>
<li>参考链接：<a href="https://blog.csdn.net/baobaoxiannv/article/details/83818426" target="_blank" rel="noopener">csdn博客一篇</a></li>
<li>其实就是<code>kube</code>的<code>config</code>文件: <code>~/.kube/config</code> 文件过时了。里面的<code>certification</code>需要更新。从<code>kube server</code>上面把<code>config</code>拿下来替换一些本地的就好了。</li>
</ul>
<h3 id="k8s的nodeport-service出错"><a class="header-anchor" href="#k8s的nodeport-service出错"></a>K8s的NodePort Service出错</h3>
<h4 id="nodeport-service的nodeport无法访问"><a class="header-anchor" href="#nodeport-service的nodeport无法访问"></a>NodePort Service的NodePort无法访问</h4>
<ul>
<li>在工作中碰到一个问题。<code>NodePort</code>的<code>NodePort</code>无法访问，只有我组开发的一个服务有问题，其他服务都是OK的
<ul>
<li>内部服务使用<code>clusterIP:internalPort</code>访问没有问题</li>
<li>外部机器无法访问</li>
<li>各个机器上面的端口已经完全开好了</li>
<li>只有本机可以使用<code>NodeIP:NodePort</code>访问到服务,也就是<code>deployment</code>起或者<code>pod</code>起的那台机器可以访问服务</li>
<li>只有一套环境有问题，另外一套环境没有问题。有问题的环境上面有<code>kube-proxy</code>服务，而另一套并没在<code>kube-system</code>下面找到<code>kube-proxy</code></li>
</ul>
</li>
<li>先说结论，最后发现是由于在我国抵抗疫情期间，国外友人加了<code>NetworkPolicy</code>导致的，需要在服务的<code>deployment</code>里面加上一个标准位，而添加的网络规则会根据这个标准位来放行或者阻拦<code>traffic</code>
<ul>
<li>使用<code>kubectl get networkpolicy</code>可以看到设置的网络规则，使用<code>describe</code>命令可以看到详细的信息，如下，所以需要加上这个标志位（在deployment的labels里面。）</li>
<li>后续需要进一步学习<code>NetworkPolicy</code>相关知识</li>
</ul>
</li>
</ul>
<pre><code>   Spec:
	PodSelector:     allowTraffic=true
</code></pre>
<ul>
<li>这边来看解决分析过程。
<ul>
<li>由于两套环境上一套是工作的第一反应是两套机器的差异，并且还有一个信息是春节前是工作的，春节后是不工作的。但是由于机器并不是我们自己搭的，只能猜测是环境改变了。</li>
<li><code>kube-proxy</code> 出问题了，因为所有的<code>clusterIP</code>是好的，那么猜测是中间的转发过程出问题了，于是查询看看同一个<code>node</code>上面的<code>kube-proxy</code>的日志，事实上没有任何错误。这边有几个信息，即使在日志里面看到了端口被占用的日志，也并没有什么意义，在测试中，不停地启停<code>service</code>就可能触发这个日志。</li>
<li>在排除掉<code>kube-proxy</code>之后，就怀疑是<code>iptables</code>的错误。参考以下链接，确实在<code>iptables</code>出现问题的时候可能发生类似的错误：</li>
<li>参考链接：<a href="https://stackoverflow.com/questions/46667659/kubernetes-cannot-access-nodeport-from-other-machines" target="_blank" rel="noopener">k8s的nodeport无法从其他机器访问</a></li>
<li><a href="https://www.myf5.net/post/2343.htm" target="_blank" rel="noopener">NodePort Service的请求未被分发到各个node的排错</a></li>
<li>于是看了一整天的<code>iptables</code>。由于时间紧迫，并未能看到全貌，后续会新开一篇博客来补。事实上，<code>NodePort</code>服务类型只比<code>ClusterIP</code>类型多两条规则</li>
<li>而在整个<code>ipTables</code>里面，可以很清晰地看到整个链路，一直转到<code>endpoint</code>上面。尽管里面也有上述两个链接中提到的<code>Docker</code>相关的规则，却不是在<code>filter</code>过滤表里面。而是在<code>NAT</code>转发表里，所以按照链路来看，从<code>NodePort</code>进去的请求最后确实转发到了<code>endpoint</code>，并没有到<code>Docker</code>里面。事实上，我尝试在<code>IpTables</code>里面加上了链接中的路由，并未生效。</li>
<li>在研究了一天<code>iptables</code>之后，转到了比较生硬一些却可能更有效的办法：</li>
<li>研究其他服务的代码改动。事实上，肯定是有加入这个标志位的，但是由于和一些类似格式的改动在一起，没看出来</li>
<li>查询从哪一天开始出现了问题。万幸已经知道2月6号的包有问题，年前是好的，中间并未差几天。在数次装包卸载之后发现了时间点。再比较两个包的差异，发现了这个<code>NetworkPolicy</code>的增加</li>
</ul>
</li>
</ul>
<h3 id="pod不断重启"><a class="header-anchor" href="#pod不断重启"></a>POD不断重启</h3>
<ul>
<li>仍旧是上一个问题相同的项目出的问题，这个项目怎么这么难呢 😦</li>
<li>由于这个项目是架构在<code>OSGI</code>上面的，进入<code>OSGI</code>发现有一个<code>AKKA</code>相关的<code>bundle</code>的状态不对，不是<code>ACTIVE</code>，而是<code>RESOLVED</code>，第一反应就是我在前一周做的改动不对。因为在前一天我进行了<code>IPV6</code>的改动，但是并不工作。</li>
<li>于是回滚掉<code>IPV6</code>的改动，回滚掉再之前的<code>AKKA service</code>相关的改动，然并卵，这时候也已经周五晚上12点了。只能作罢</li>
</ul>
<h4 id="为何没能够更早的发现问题"><a class="header-anchor" href="#为何没能够更早的发现问题"></a>为何没能够更早的发现问题</h4>
<ul>
<li><code>POD</code>并不是起不来，然后一直重启，而是在起来一段时间，大约10来分钟的时候会重启，所以一直没有被发现。这点是一个改变，后续需要注意。</li>
<li>测试方法的问题，我们在测试的时候因为只是功能发布之后的回归测试，仅仅测试了端口是不是通。这样很快，但是也就测不到问题了。</li>
</ul>
<h4 id="周末调试"><a class="header-anchor" href="#周末调试"></a>周末调试</h4>
<ul>
<li>周末的时候和上一次调试不一样的是，上来就选择了各种装包和对比，最后发现3月9号的包是OK的，而12号的就挂了</li>
<li>在这之间，最大的改动是<code>Cassandra</code>改动，这个改动直接导致了10号11号的包都是坏的。</li>
<li>然后再一次，我们这个项目又被国外友人给漏掉了</li>
<li>但是奇特的是，按照对比之后，我们应该连不上<code>Cassandra</code>了才对，但是实际上，整个<code>pod</code>起来的时候，<code>OSGI</code>的服务会最先检查数据库安装，并未报错，所以这点很是奇特。在解决问题后发现，应该是创了不同的<code>user</code>，<code>super user</code>仍旧是存在的。所以连接并未报错，但是实际的服务却不对了</li>
<li>对比包无效之后，回到最初的问题上面，为什么<code>POD</code>会自动重启</li>
</ul>
<h4 id="k8s-pod重启"><a class="header-anchor" href="#k8s-pod重启"></a>K8S POD重启</h4>
<ul>
<li>
<p>这里有一个命令： <code>kubectl get events</code>,使用这个命令可以看到<code>POD</code>的事务：</p>
<pre><code>$ kubectl get events
LAST SEEN   TYPE   REASON  OBJECT      MESSAGE
&lt;unknown&gt;   Normal    Scheduled                         pod/xxxxxxx Successfully assigned &lt;namespace&gt;/xxxxxx to node-10-41-82-7
</code></pre>
</li>
<li>
<p>这样可以清晰看到<code>pod</code>由于连不上<code>AKKA</code>服务的<code>2929</code>端口而重启，也就是<code>liveness</code>条件不满足了，所以<code>K8S</code>就欢快地把<code>POD</code>杀掉了。</p>
</li>
<li>
<p>然后还有一个有用的命令是<code>kubectl logs -p &lt;podName&gt;</code>这条命令可以帮助我们看到被杀的前一个pod的日志，毕竟我们看的当时，前一个pod可能已经被干掉了</p>
</li>
</ul>
<h4 id="分析"><a class="header-anchor" href="#分析"></a>分析</h4>
<ul>
<li>
<p>问题有二，<code>2929</code>端口起不来，<code>OSGI bundle</code>起不来，也可能最后都是<code>Cassandra</code>导致的。在解决之后，事实证明后一个问题确实是，前一个并不是。</p>
</li>
<li>
<p>而且两者都和<code>AKKA</code>服务相关，但是<code>AKKA</code>和<code>Cassandra</code>有个毛线相关性。</p>
</li>
<li>
<p>还有个坑爹的是，打开<code>DEBUG</code>级别的日志，可以看到除了<code>AKKA</code>相关的<code>bundle</code>之外，几乎所有的<code>bundle</code>都在报以下的错误。这个错误在<code>bundle</code>之间调用服务时候的就会出现。</p>
</li>
<li>
<p>由于<code>AKKA</code>的<code>bundle</code>是最后一个，在启动时候会check其他所有<code>bundle</code>的状态，所以这家伙就挂了。将<code>check</code>去掉就起来了。所以看起来，这个<code>bundle</code>起不来，更多的是和以下的<code>OSGI</code>错误相关，而不是和<code>AKKA</code>有关联</p>
</li>
<li>
<p>但是在从上回的<code>network Policy</code>问题以来，只有一滴滴helm chart的改动。java代码压根没动过。依赖也没改过。</p>
</li>
<li>
<p><code>OSGI</code>你报什么错啊，吐血了我！</p>
<pre><code> org.osgi.framework.ServiceException: org.apache.felix.scr.impl.manager.SingleComponentManager.getService() returned a null service object
at org.eclipse.osgi.internal.serviceregistry.ServiceUse.getService(ServiceUse.java:163) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:468) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:467) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.getService(BundleContextImpl.java:594) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.apache.felix.scr.impl.helper.BindMethod.getServiceObject(BindMethod.java:572) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.getServiceObject(DependencyManager.java:2012) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager$SingleDynamicCustomizer.prebind(DependencyManager.java:852) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.prebind(DependencyManager.java:1439) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.collectDependencies(AbstractComponentManager.java:1119) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:807) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:777) [na:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse$1.run(ServiceUse.java:141) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at java.security.AccessController.doPrivileged(Native Method) [na:1.8.0_212]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse.getService(ServiceUse.java:139) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:468) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:467) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.getService(BundleContextImpl.java:594) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.apache.felix.scr.impl.helper.BindMethod.getServiceObject(BindMethod.java:572) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.getServiceObject(DependencyManager.java:2012) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager$SingleDynamicCustomizer.prebind(DependencyManager.java:852) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.prebind(DependencyManager.java:1439) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.collectDependencies(AbstractComponentManager.java:1119) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:807) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:777) [na:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse$1.run(ServiceUse.java:141) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at java.security.AccessController.doPrivileged(Native Method) [na:1.8.0_212]
at org.eclipse.osgi.internal.serviceregistry.ServiceUse.getService(ServiceUse.java:139) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:468) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:467) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.getService(BundleContextImpl.java:594) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.apache.felix.scr.impl.helper.BindMethod.getServiceObject(BindMethod.java:572) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.getServiceObject(DependencyManager.java:2012) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager$SingleDynamicCustomizer.prebind(DependencyManager.java:852) [na:na]
at org.apache.felix.scr.impl.manager.DependencyManager.prebind(DependencyManager.java:1439) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.collectDependencies(AbstractComponentManager.java:1119) [na:na]
at org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:807) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.activateInternal(AbstractComponentManager.java:850) [na:na]
at org.apache.felix.scr.impl.manager.AbstractComponentManager.enable(AbstractComponentManager.java:419) [na:na]
at org.apache.felix.scr.impl.config.ConfigurableComponentHolder.enableComponents(ConfigurableComponentHolder.java:376) [na:na]
at org.apache.felix.scr.impl.BundleComponentActivator.initialize(BundleComponentActivator.java:172) [na:na]
at org.apache.felix.scr.impl.BundleComponentActivator.&lt;init&gt;(BundleComponentActivator.java:120) [na:na]
at org.apache.felix.scr.impl.Activator.loadComponents(Activator.java:258) [na:na]
at org.apache.felix.scr.impl.Activator.access$000(Activator.java:45) [na:na]
at org.apache.felix.scr.impl.Activator$ScrExtension.start(Activator.java:185) [na:na]
at org.apache.felix.utils.extender.AbstractExtender.createExtension(AbstractExtender.java:259) [na:na]
at org.apache.felix.utils.extender.AbstractExtender.modifiedBundle(AbstractExtender.java:232) [na:na]
at org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:479) [karaf-org.osgi.core.jar:na]
at org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:414) [karaf-org.osgi.core.jar:na]
at org.osgi.util.tracker.AbstractTracked.track(AbstractTracked.java:232) [karaf-org.osgi.core.jar:na]
at org.osgi.util.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:443) [karaf-org.osgi.core.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleContextImpl.dispatchEvent(BundleContextImpl.java:847) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEventPrivileged(Framework.java:1568) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1504) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1499) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:391) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.AbstractBundle.resume(AbstractBundle.java:390) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.Framework.resumeBundle(Framework.java:1176) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:559) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:544) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.incFWSL(StartLevelManager.java:457) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.doSetStartLevel(StartLevelManager.java:243) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.dispatchEvent(StartLevelManager.java:438) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.internal.core.StartLevelManager.dispatchEvent(StartLevelManager.java:1) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:340) [org.eclipse.osgi-3.8.2.v20130124-134944.jar:na]
</code></pre>
</li>
</ul>
<h4 id="进展"><a class="header-anchor" href="#进展"></a>进展</h4>
<ul>
<li>在做了<code>workaround</code>： 替换<code>liveness</code>的端口，这样<code>pod</code>不会在不断重启；将<code>bundle</code>的<code>check</code>去掉，这样<code>bundle</code>看着都<code>active</code>了。之后，开始重新<code>debug</code></li>
<li><code>OSGI</code>的错误在打开<code>apache</code>的<code>debug log</code>之后仍旧无从下手，这个错误在3月9号的包中也是没有的，只能回到对比包的老路上面来。</li>
<li>那么第一个仍旧是<code>Cassandra</code>的改动。这回在将这个改动加上之后，<code>OSGI</code>的错误没有了。然鹅，为什么数据库的改动会影响到<code>OSGI</code>的状态，并不知道。这个问题只能到此为止啦。</li>
<li>所以使用<code>karaf</code>仍旧是很<code>heavy</code>的，在最新的版本中已经将之移除了。</li>
</ul>
<h4 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h4>
<ul>
<li>在问题的解决过程中，查询了很多，有一些比较有用的链接如下：
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/51455551" target="_blank" rel="noopener">k8s为何杀死我的Pod</a></li>
<li><a href="https://blog.csdn.net/yzh_1346983557/article/details/89216494?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">CPU分配过少导致POD重启</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/11/15/TLS-Certification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/11/15/TLS-Certification/" class="post-title-link" itemprop="url">TLS - Certificate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-15 16:03:26" itemprop="dateCreated datePublished" datetime="2019-11-15T16:03:26+08:00">2019-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 13:54:41" itemprop="dateModified" datetime="2021-01-22T13:54:41+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo_blog/categories/security/" itemprop="url" rel="index"><span itemprop="name">security</span></a>
                </span>
            </span>

          
            <span id="/hexo_blog/2019/11/15/TLS-Certification/" class="post-meta-item leancloud_visitors" data-flag-title="TLS - Certificate" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h2>
<ul>
<li><a href="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail.png" target="_blank" rel="noopener">SSL/TLS for dummies part 3 – Understanding Certificate Authority</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a></li>
<li><a href="https://www.cnblogs.com/lhj588/p/6069873.html" target="_blank" rel="noopener">https SSL主流数字证书都有哪些格式？</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html" target="_blank" rel="noopener">Java Secure Socket Extension</a></li>
</ul>
<h2 id="为啥需要证书"><a class="header-anchor" href="#为啥需要证书"></a>为啥需要证书</h2>
<ul>
<li>我们知道在<code>TLS</code>传输中需要使用不对称加密算法，在其中有公钥，私钥。公钥用来给客户端给自己发消息，私钥用来解密收到的消息。</li>
<li>但是以下场景中即使是不对称加密也是不安全的：
<ul>
<li>小明用浏览器往百度发了个消息，然后百度将自己的公钥返回给小明。</li>
<li>攻击者在中途截住了这个公钥，并且替换为自己的公钥发给了小明。</li>
<li>小明并不清楚，用这个假的公钥加密了自己的私钥，并且发给了百度。</li>
<li>攻击者于是拥有了小明的私钥，接着用上一次截获的百度的公钥加密小明的私钥，返回给百度。</li>
<li>于是百度会认为<code>TLS</code>通道已经建立。接下来小明和百度之间的所有消息都会被攻击者得知。</li>
<li>这时候就需要证书了。证书颁发机构由<code>X.509</code>标准指定，以确保数据的完整性。证书的目的就是保证数据的完整性。啧，听上去好厉害！</li>
</ul>
</li>
</ul>
<h2 id="证书的使用过程"><a class="header-anchor" href="#证书的使用过程"></a>证书的使用过程</h2>
<ol>
<li>首先是百度作为一个服务器，向<code>CA</code>申请签名证书。这里用<code>Digicert</code>作为<code>CA</code>。<code>github</code>就是<code>Digicert</code>做的根认证 😃</li>
<li>那么<code>CA</code>会为百度创建一个证书，里面包含一些信息，比如例如服务器名称，服务器的公钥等。</li>
<li><code>Digicert</code>将创建数据（这里的数据，其实就是证书）的哈希值，并使用自己的私钥对其进行加密</li>
<li>浏览器和操作系统自带<code>Digicert</code>等权威机构的公钥。</li>
<li>当浏览器收到签名证书时，它将使用<code>Digicert</code>的公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列</li>
<li>如果两个哈希值匹配，则签名验证成功并且证书是可信的</li>
<li>现在浏览器可以使用证书中指定的百度的公钥继续进行身份验证过程。</li>
</ol>
<ul>
<li>也就是说在客户端和服务器端交换公钥秘钥的过程中，加入了<code>CA</code>的签名认证，这样保证客户端可以信任收到的公钥确实是服务器端的公钥，而不是攻击者的公钥。</li>
<li>其实就是证书服务器对自己的一份数据，这个数据包含证书服务器的信息和百度的公钥信息，还有其他一些信息。然后先进行hash运算，再用自己的私钥进行加密，然后和数据一起发给浏览器。</li>
<li>这样，浏览器对数据进行hash运算，然后，用证书服务器的公钥解密，再跟算出来的hash值进行对比。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/Certificate.png" alt="来自参考链接1"></p>
<ul>
<li>为了绕过上述机制，攻击者需要使签名来匹配数据，为了做到这点，他需要拥有<code>Digicert</code>的私钥（最初为example.com签发并签署了证书），所以攻击者此时会失败，因为他可以创建的唯一签名来自他的私钥，我们的浏览器并不会信任这一点。浏览器的证书存储区也不会有攻击者的公钥，并且在发生此类攻击时会显示证书异常，如下所示。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_not_safe.png" alt=""></p>
<h2 id="root-ca-和-中间ca"><a class="header-anchor" href="#root-ca-和-中间ca"></a>Root CA 和 中间CA</h2>
<p><code>CA</code>的一堆看得想吐啊。😦</p>
<h3 id="root-ca"><a class="header-anchor" href="#root-ca"></a>Root CA</h3>
<ul>
<li>参考链接
<ul>
<li><a href="https://support.dnsimple.com/articles/what-is-certificate-authority/" target="_blank" rel="noopener">什么是CA</a></li>
<li><a href="https://support.dnsimple.com/articles/what-is-ssl-root-certificate/" target="_blank" rel="noopener">什么是Root CA</a></li>
</ul>
</li>
<li>有两种解释，一个是被信任的机构，另一个是这个机构颁发出来的证书</li>
<li>比如<code>Digicert</code>就是一个<code>root CA</code></li>
</ul>
<h3 id="中间ca"><a class="header-anchor" href="#中间ca"></a>中间CA</h3>
<ul>
<li>简单地说，将鸡蛋放在一个篮子里面是很危险的， <code>CA</code>也是一样，如果所有的证书都由<code>root CA</code>签发，那么<code>root CA</code>的工作量繁重，而且一旦<code>root CA</code>被攻击了，后果实在不可想象</li>
<li>于是出现了中间的<code>CA</code>服务器，也就是被根<code>CA</code>服务器信任的中间服务器</li>
<li><em><code>intermediate CA</code>是<code>Root CA</code>信任的证书颁发机构。 <code>example.com</code>的证书将由<code>intermediate CA</code>颁发，<code>intermediate CA</code>还将具有将由<code>Root CA</code>签名的证书，并且只有<code>Root CA</code>的详细信息会被存储在浏览器的证书库中。</em></li>
<li>在浏览器里面能看到证书的详细信息。比如以下的这个证书。G2就是一个中间CA。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail.png" alt=""></p>
<h3 id="证书签名算法"><a class="header-anchor" href="#证书签名算法"></a>证书签名算法</h3>
<ul>
<li>在证书将数据的<code>hash值</code>用自己的私钥进行加密的时候可以选择不同的加密算法.</li>
<li><code>RSA解密加密</code>和<code>RSA签名</code>算法应该有一些差异，这里暂时并不深究。看下图中可以看到，这边签名算法用的是<code>sha256RSA</code>。<code>sha256</code>是哈希算法。</li>
<li>需要知道的是，签名是通过使用<code>intermediate CA</code>的私钥来完成的。并且签名验证由浏览器使用相应的公钥完成的。</li>
<li>数据长度超过其密钥长度，<code>RSA</code>无法加密数据。假设我们使用<code>2048</code>位密钥进行加密，那么证书数据不应超过<code>2048</code>位，也就是<code>255</code>个字节，这并不总是可行的，因为证书包含很多信息。因此，在加密之前，在证书上应用哈希函数（哈希函数又称为散列算法），该函数生成指定长度的唯一随机字符串。下图中就是<code>sha256</code>.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_algorithm.png" alt=""></p>
<h3 id="证书校验"><a class="header-anchor" href="#证书校验"></a>证书校验</h3>
<ul>
<li>浏览器是有根<code>CA</code>的公钥的，所以浏览器会先用根<code>CA</code>的公钥来验证中间<code>CA</code>的证书</li>
<li>然后就可以信任中间<code>CA</code>的公钥，再用这个公钥来解服务器的证书</li>
<li>然后得到服务器，比如百度的公钥</li>
</ul>
<h4 id="eddsa签名机制"><a class="header-anchor" href="#eddsa签名机制"></a>EdDSA签名机制</h4>
<p>这是在工作中碰到的，一看一脸懵啊，懵逼归懵逼，那老大说看一看，还是得学习一下。<br>
万能的<code>Google</code>哥和<code>stackoverflow</code>在，还是不怕的。记在这里，这样感觉没白干活啊。话说我最近好生懒散呐。😓</p>
<h5 id="什么是eddsa签名机制"><a class="header-anchor" href="#什么是eddsa签名机制"></a>什么是EdDSA签名机制</h5>
<ul>
<li>我压根看不了啊，都是数学啊：<a href="https://blog.csdn.net/zhangchen124/article/details/110815686" target="_blank" rel="noopener">区块链中的数学 - EdDSA签名机制</a></li>
<li>关键点就是这个爱德华曲线，然后在里面不会用随机数。</li>
<li>最大的区别在于没有使用随机数，这样产生的签名结果是确定性的，即每次对同一消息签名结果相同</li>
<li>当然这个玩意也是会被攻击的，细节可以参考<a href="https://www.anquanke.com/post/id/167018" target="_blank" rel="noopener">针对EdDSA的fault attack</a></li>
</ul>
<h5 id="工作中碰到的问题"><a class="header-anchor" href="#工作中碰到的问题"></a>工作中碰到的问题</h5>
<ul>
<li>工作中的问题跟这个是一样的：<a href="https://stackoverflow.com/questions/65566138/apache-mina-sshd-ssh-client-always-prints-eddsa-provider-not-supported" target="_blank" rel="noopener">Apache mina-sshd ssh client always prints EdDSA provider not supported</a></li>
</ul>
<h3 id="证书格式"><a class="header-anchor" href="#证书格式"></a>证书格式</h3>
<ul>
<li>证书的规范是<code>X.509</code>，有好几个版本。起码到<code>v3</code>,应该也是目前比较常用的一个版本。证书的内容遵循<code>asn.1</code>格式。😂 居然是<code>asn.1</code>的，久违的一个规范了。</li>
<li>最常见的两个工具是<code>Java</code>的<code>Keytool</code>和<code>openssl</code></li>
<li><code>Java</code>的<code>keytool</code>生成的证书格式是<code>JKS</code>格式的证书</li>
<li><code>openssl</code>生成<code>PEM、KEY、CRT</code>格式的证书</li>
<li>还有一些其他格式的证书，比如IBM和微软，都有自己的工具生成的自带证书
<ul>
<li><code>*.DER *.CER Certificate</code> : 这样的证书文件是二进制格式，只含有证书信息，不包含私钥。</li>
<li><code>*.CRT</code>: 这样的文件可以是二进制格式，也可以是文本格式，一般均为文本格式，功能与<code>*.DER/*.CER</code>相同。</li>
<li><code>*.PEM Privacy Enhanced Mail</code>: 一般是文本格式，可以放证书或私钥，或者两者都包含。 <code>*.PEM</code>如果只包含私钥，那一般用<code>*.KEY</code>代替。</li>
<li><code>*.PFX *.P12 Personal Information Exchange</code>是二进制格式，同时含证书和私钥，一般有密码保护</li>
<li><strong>这个博客是不是说得不对啊，证书里面哪里来的私钥，应该都是公钥才对吧</strong></li>
</ul>
</li>
<li><code>—–BEGIN CERTIFICATE—–</code> 用这个开头的，代表这个是证书</li>
<li><code>—–BEGIN RSA PRIVATE KEY—–</code> 这个开头的，说明是一个私钥。</li>
</ul>
<h4 id="证书的详细内容"><a class="header-anchor" href="#证书的详细内容"></a>证书的详细内容</h4>
<ul>
<li>以下是证书规范。看名字能明白其中包含：
<ul>
<li>证书规范的版本信息，比如<code>v3</code></li>
<li>证书序列号，证书序列号在一个<code>CA</code>机构内是唯一的，但不是全局唯一</li>
<li>证书签名算法，这个是上面已经看过了。</li>
<li>证书签发者，是一组<code>DN distributed name</code>，在用<code>openssl</code>等工具输出证书信息的时候，能看到这一栏。</li>
<li>证书有效期</li>
<li>证书里面包含的服务器的名称， 也是一个<code>DN</code>。</li>
<li>证书中包含的服务器的公钥</li>
<li>其他扩展信息：比如证书所携带的域名信息<code>SAN</code></li>
<li>签名：最后是证书签名，这个在上面已经讲过，是有证书服务器使用自己的私钥对数据进行的签名，使用证书内指定的签名算法。格式如下：</li>
</ul>
</li>
</ul>
<pre><code>   Signature = RSA(sha256(Data), IssuerPrivateKey)
</code></pre>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/certificate_detail_content.png" alt="证书的详细信息"></p>
<p><img src="https://raw.githubusercontent.com/sallyslove/Pictures/master/Security/TLS/Certificate/DN_explaination.jpg" alt="DN详解"></p>
<h4 id="证书查看和格式转换"><a class="header-anchor" href="#证书查看和格式转换"></a>证书查看和格式转换</h4>
<ul>
<li>各个证书的格式之间是可以相互转换的。</li>
<li>以下命令，将<code>JKS</code>格式转换成为<code>PFX</code>格式。事实上，用这条命令可以实现<code>JKS</code>和<code>PFX</code>的相互转换，换一下目标格式和源格式即可。</li>
</ul>
<pre><code>keytool -importkeystore -srckeystore D:\server.jks -destkeystore D:\server.pfx -srcstoretype JKS -deststoretype PKCS12
</code></pre>
<h2 id="java中的实现"><a class="header-anchor" href="#java中的实现"></a>Java中的实现</h2>
<ul>
<li>我们在工作中碰到了错误:</li>
</ul>
<pre><code>javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative names present
</code></pre>
<ul>
<li>
<p>这个错误在现在看来就比较清楚了，是客户端在校验服务器端的证书，并且对证书里面的扩展字段<code>SAN</code>有要求，但是服务器端的证书里面并没有带这个扩展字段，就错了。</p>
</li>
<li>
<p>这部分代码应该在<code>JSSE Java Secure Socket Extension</code>里面。<br>
没有unit test，很难跟代码。先将报错信息记录在这里。报错信息如下：</p>
<pre><code> javax.net.ssl.SSLHandshakeException:  
 java.security.cert.CertificateException: No subject alternative names present
 at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
 at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1964)
 at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:328)
 at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:322)
 at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1614)
 at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
 at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1052)
 at sun.security.ssl.Handshaker.process_record(Handshaker.java:987)
 at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1072)
 at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1385)
 at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1413)
 at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1397)</code></pre>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sallyslove.github.io/hexo_blog/2019/11/15/Maven-Dependency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo_blog/images/avatar.gif">
      <meta itemprop="name" content="Lynn Shen">
      <meta itemprop="description" content="35岁开始的博客，有点晚哦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo_blog/2019/11/15/Maven-Dependency/" class="post-title-link" itemprop="url">Maven Dependency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-15 13:43:28 / 修改时间：14:02:12" itemprop="dateCreated datePublished" datetime="2019-11-15T13:43:28+08:00">2019-11-15</time>
            </span>

          
            <span id="/hexo_blog/2019/11/15/Maven-Dependency/" class="post-meta-item leancloud_visitors" data-flag-title="Maven Dependency" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>maven</code>的<code>dependency</code>咋说呢，项目大了之后就有点复杂，在工作中配到一个由于<code>dependency</code>引入的问题，将一些细节记录在这里。<br>
篇幅不会很长，但是实际问题中应该很有帮助。</p>
<ul>
<li>
<p><code>mvn dependency:tree -Dverbose -Dincludes=&lt;groupID&gt;:&lt;artifiactID&gt;</code><br>
这条命令可以比较相近地打印出需要知道的包的情况。</p>
</li>
<li>
<p>在一个<code>pom</code>文件里面，同层次的排在前面的会被优先采用，而后面的一个会被忽略。<br>
比如， <code>A depend on C 0.1</code>, <code>B depend on C 0.2</code>，在<code>pom</code>里面写的时候，<code>A</code>在<code>B</code>前面，那么最终<code>C 0.1</code>会成为整个项目使用的版本</p>
</li>
<li>
<p>像上面这种情况，如果想使用<code>C 0.2</code>，那么有一个方法是在<code>A</code>的依赖加入的时候，使用<code>exclusions</code>字段将对<code>C</code>的依赖排除掉。</p>
</li>
<li>
<p>有的时候一个项目里面的相对底层的lib库，可能会被各种上层调用，比如打印log的，访问数据库的，那么更容易出现各种版本冲突，事实上，到最后没有办法来理出来，犹如一团乱麻。那么一个简单的方式就是，在顶层项目的<code>pom</code>文件里面，使用<code>dependencymanagement</code>来指定一个范围和版本号。这种实在是一招破万军。</p>
</li>
<li>
<p>使用第一条命令之后打印出来的<code>log</code>里面有</p>
</li>
<li>
<p>以下代表是<code>dependencymanagement</code>在起作用</p>
<pre><code>- version managed from 0.17; omitted for duplicate)
</code></pre>
</li>
<li>
<p>以下代表是版本冲突了</p>
<pre><code>omitted for conflict with 0.17
</code></pre>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/hexo_blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/hexo_blog/page/5/">5</a><a class="extend next" rel="next" href="/hexo_blog/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lynn Shen</p>
  <div class="site-description" itemprop="description">35岁开始的博客，有点晚哦</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo_blog/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo_blog/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynn Shen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ffyWzhHueqJEC5UEfPUhAWzF-MdYXbMMI","app_key":"vS7xTvT1vD1DxluERkmlkvme","server_url":"https://sallyslove.github.io/hexo_blog","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/hexo_blog/lib/anime.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.min.js"></script>
  <script src="/hexo_blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo_blog/js/utils.js"></script>

<script src="/hexo_blog/js/motion.js"></script>


<script src="/hexo_blog/js/schemes/muse.js"></script>


<script src="/hexo_blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
